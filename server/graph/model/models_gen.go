// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Entity interface {
	IsEntity()
	GetID() string
	GetCreatedAt() string
	GetUpdatedAt() string
	GetName() string
	GetDescription() string
}

// Representa un personaje en el mundo ficticio.
// Incluye datos generales, atributos físicos, estado de vida y relaciones con otras entidades.
type Character struct {
	// Identificador único del personaje.
	ID string `json:"_key"`
	// Fecha de creación del personaje en el sistema (ISO 8601).
	CreatedAt string `json:"createdAt"`
	// Fecha de última actualización del personaje en el sistema (ISO 8601).
	UpdatedAt string `json:"updatedAt"`
	// Nombre del personaje.
	Name string `json:"name"`
	// Descripción del personaje, incluyendo trasfondo o detalles relevantes.
	Description string `json:"description"`
	// Tipo de entidad, útil para clasificar personajes en el sistema.
	Type string `json:"type"`
	// Fecha de nacimiento del personaje en formato ISO 8601 (YYYY-MM-DD).
	BirthDate string `json:"birthDate"`
	// Altura del personaje en metros (m).
	Height float64 `json:"height"`
	// Peso del personaje en kilogramos (kg).
	Weight float64 `json:"weight"`
	// Indica si el personaje está vivo (true) o muerto (false).
	IsAlive bool `json:"isAlive"`
	// Indica si el personaje es un protagonista o figura central en la historia.
	IsMain bool `json:"isMain"`
	// Alineamiento moral o ético del personaje (según el sistema usado).
	Alignment *Alignment `json:"alignment,omitempty"`
	// Lista de relaciones con otros personajes, incluyendo amistad, enemistad o parentesco.
	Characters []*CharacterCharacter `json:"characters"`
	// Lista de relaciones del personaje con criaturas, incluyendo domesticación o conflicto.
	Creatures []*CharacterCreature `json:"creatures"`
	// Lista de relaciones del personaje con facciones, como afiliaciones o enemistades.
	Factions []*CharacterFaction `json:"factions"`
	// Lista de relaciones del personaje con eventos, como participación o influencia.
	Events []*CharacterEvent `json:"events"`
	// Lista de relaciones del personaje con ítems, como posesión, uso o creación.
	Items []*CharacterItem `json:"items"`
	// Lista de relaciones del personaje con ubicaciones, como residencia o exploración.
	Locations []*CharacterLocation `json:"locations"`
	// Lista de relaciones del personaje con mundos, como origen, exilio o conquista.
	Worlds []*CharacterWorld `json:"worlds"`
}

func (Character) IsEntity()                   {}
func (this Character) GetID() string          { return this.ID }
func (this Character) GetCreatedAt() string   { return this.CreatedAt }
func (this Character) GetUpdatedAt() string   { return this.UpdatedAt }
func (this Character) GetName() string        { return this.Name }
func (this Character) GetDescription() string { return this.Description }

// Define la relación entre dos personajes.
// Puede incluir amistad, enemistad, parentesco y otros vínculos narrativos.
type CharacterCharacter struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El personaje con el que se establece la relación.
	Character *Character `json:"character"`
	// Nivel de relación entre los personajes, desde amistad hasta enemistad extrema.
	CharacterRelationLevel CharacterRelationLevel `json:"characterRelationLevel"`
	// Relación familiar si existe un vínculo de parentesco (opcional).
	FamilyRelation *FamilyRelation `json:"familyRelation,omitempty"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Representa la relación entre un personaje y una criatura.
// Puede incluir domesticación, caza, invocación y otros vínculos narrativos.
type CharacterCreature struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El personaje que tiene la relación con la criatura.
	Character *Character `json:"character"`
	// La criatura con la que el personaje está relacionado.
	Creature *Creature `json:"creature"`
	// Tipo de relación entre el personaje y la criatura (dueño, enemigo, protector, etc.).
	Relation CharacterCreatureRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre un personaje y un evento.
// Puede representar participación directa, testimonio, organización o influencia.
type CharacterEvent struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El personaje que tiene la relación con el evento.
	Character *Character `json:"character"`
	// El evento con el que el personaje tiene una relación.
	Event *Event `json:"event"`
	// Tipo de relación entre el personaje y el evento (participante, organizador, testigo, etc.).
	Relation CharacterEventRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre un personaje y una facción.
// Incluye afiliaciones, liderazgos, enemistades e interacciones indirectas.
type CharacterFaction struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El personaje que tiene la relación con la facción.
	Character *Character `json:"character"`
	// La facción con la que el personaje tiene una relación.
	Faction *Faction `json:"faction"`
	// Tipo de relación entre el personaje y la facción (miembro, líder, enemigo, etc.).
	Relation CharacterFactionRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre un personaje y un ítem.
// Puede representar posesión, uso, creación, destrucción o influencia del objeto en el personaje.
type CharacterItem struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El personaje que tiene la relación con el ítem.
	Character *Character `json:"character"`
	// El ítem con el que el personaje tiene una relación.
	Item *Item `json:"item"`
	// Tipo de relación entre el personaje y el ítem (dueño, usuario, creador, etc.).
	Relation CharacterItemRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre un personaje y una ubicación.
// Puede representar origen, residencia, gobierno, exploración o conflicto con el lugar.
type CharacterLocation struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El personaje que tiene la relación con la ubicación.
	Character *Character `json:"character"`
	// La ubicación con la que el personaje tiene una relación.
	Location *Location `json:"location"`
	// Tipo de relación entre el personaje y la ubicación (residente, explorador, exiliado, etc.).
	Relation CharacterLocationRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre un personaje y un mundo.
// Puede representar ciudadanía, exploración, influencia o enemistad con el mundo.
type CharacterWorld struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El personaje que tiene la relación con el mundo.
	Character *Character `json:"character"`
	// El mundo con el que el personaje tiene una relación.
	World *World `json:"world"`
	// Tipo de relación entre el personaje y el mundo (nativo, explorador, conquistador, etc.).
	Relation CharacterWorldRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Estructura para crear un nuevo personaje dentro de un mundo.
type CreateCharacterInput struct {
	// ID del mundo al que pertenece el personaje.
	WorldID string `json:"worldId"`
	// Nombre del personaje.
	Name string `json:"name"`
	// Descripción del personaje, incluyendo trasfondo o detalles relevantes.
	Description string `json:"description"`
	// Tipo de entidad, útil para clasificar personajes en el sistema.
	Type string `json:"type"`
	// Fecha de nacimiento del personaje en formato ISO 8601 (YYYY-MM-DD).
	BirthDate string `json:"birthDate"`
	// Altura del personaje en metros (m).
	Height float64 `json:"height"`
	// Peso del personaje en kilogramos (kg).
	Weight float64 `json:"weight"`
	// Indica si el personaje está vivo (true) o muerto (false).
	IsAlive bool `json:"isAlive"`
	// Indica si el personaje es un protagonista o figura central en la historia.
	IsMain bool `json:"isMain"`
	// Alineamiento moral o ético del personaje (según el sistema usado).
	Alignment *Alignment `json:"alignment,omitempty"`
}

// Estructura para crear una nueva criatura dentro de un mundo.
type CreateCreatureInput struct {
	// ID del mundo al que pertenece la criatura.
	WorldID string `json:"worldId"`
	// Nombre de la criatura.
	Name string `json:"name"`
	// Descripción detallada de la criatura, incluyendo características únicas y comportamiento.
	Description string `json:"description"`
	// Tipo de entidad, útil para clasificar criaturas en el sistema.
	Type string `json:"type"`
	// Especie o categoría de la criatura (dragón, gólem, quimera, etc.).
	Species string `json:"species"`
	// Nivel de inteligencia de la criatura (bestia, sapiente, semisapiente, etc.).
	IntelligenceLevel string `json:"intelligenceLevel"`
	// Altura de la criatura en metros (m).
	Height float64 `json:"height"`
	// Peso de la criatura en kilogramos (kg).
	Weight float64 `json:"weight"`
	// Fecha de nacimiento de la criatura en formato ISO 8601 (YYYY-MM-DD).
	BirthDate string `json:"birthDate"`
	// Indica si la criatura está viva (true) o muerta (false).
	IsAlive bool `json:"isAlive"`
	// Esperanza de vida aproximada de la criatura en años.
	Lifespan *int `json:"lifespan,omitempty"`
	// Indica si la criatura es única o pertenece a una especie con múltiples individuos.
	IsUnique bool `json:"isUnique"`
	// Ambiente donde la criatura vive (bosques, montañas, océanos, etc.).
	Habitat string `json:"habitat"`
	// Comportamiento de la criatura (pacífica, territorial, agresiva, etc.).
	Behavior string `json:"behavior"`
	// Dieta de la criatura (carnívora, herbívora, omnívora, etc.).
	Diet string `json:"diet"`
	// Lista de habilidades especiales que posee la criatura (aliento de fuego, regeneración, telepatía, etc.).
	Abilities []string `json:"abilities"`
}

// Estructura para crear un nuevo evento dentro de un mundo.
type CreateEventInput struct {
	// ID del mundo en el que ocurre el evento.
	WorldID string `json:"worldId"`
	// Nombre del evento.
	Name string `json:"name"`
	// Descripción detallada del evento, incluyendo su impacto y contexto.
	Description string `json:"description"`
	// Clasificación del evento según su naturaleza (batalla, descubrimiento, ritual, etc.).
	Type EventType `json:"type"`
	// Indica la naturaleza del evento (planificado, accidental, fortuito, inevitable, etc.).
	Nature EventNature `json:"nature"`
	// Fecha de inicio del evento en formato ISO 8601 (YYYY-MM-DD).
	StartDate string `json:"startDate"`
	// Fecha de finalización del evento en formato ISO 8601 (YYYY-MM-DD).
	EndDate string `json:"endDate"`
	// Indica si el evento es recurrente (true) o único (false).
	IsRecurring bool `json:"isRecurring"`
	// Importancia del evento dentro de la historia (baja, media, alta).
	Significance EventSignificance `json:"significance"`
	// Lista de ubicaciones donde ocurrió el evento.
	Locations []string `json:"locations"`
	// Mundos en los que el evento tuvo un impacto.
	Worlds []string `json:"worlds"`
}

// Estructura para crear una nueva facción dentro de un mundo.
type CreateFactionInput struct {
	// ID del mundo al que pertenece la facción.
	WorldID string `json:"worldId"`
	// Nombre de la facción.
	Name string `json:"name"`
	// Descripción de la facción, incluyendo su historia, cultura y propósito.
	Description string `json:"description"`
	// Clasificación de la facción según su estructura y propósito.
	Type FactionType `json:"type"`
	// Ideología, valores o principios que rigen a la facción.
	Ideology string `json:"ideology"`
	// Estatus actual de la facción (activa, disuelta, exiliada, etc.).
	Status FactionStatus `json:"status"`
	// Fecha de fundación de la facción en formato ISO 8601 (YYYY-MM-DD).
	FoundedDate string `json:"foundedDate"`
	// Fecha de disolución de la facción (opcional, en caso de que ya no exista).
	DisbandedDate *string `json:"disbandedDate,omitempty"`
	// Nivel de influencia de la facción en la historia o sociedad.
	Influence FactionInfluence `json:"influence"`
	// Lista de ubicaciones donde la facción tiene presencia, dominio o influencia.
	Locations []string `json:"locations"`
	// Lista de mundos donde la facción tiene presencia, influencia o ha sido exiliada.
	Worlds []string `json:"worlds"`
}

// Estructura para crear un nuevo ítem dentro de un mundo.
type CreateItemInput struct {
	// ID del mundo al que pertenece el ítem.
	WorldID string `json:"worldId"`
	// Nombre del ítem.
	Name string `json:"name"`
	// Descripción del ítem, incluyendo su historia y propiedades únicas.
	Description string `json:"description"`
	// Clasificación del ítem según su función o propósito.
	Type ItemType `json:"type"`
	// Rareza del ítem dentro del mundo (común, poco común, raro, legendario).
	Rarity ItemRarity `json:"rarity"`
	// Espacio donde se equipa el ítem en el cuerpo o inventario.
	Slot ItemSlot `json:"slot"`
	// Material principal del que está hecho el ítem.
	Material string `json:"material"`
	// Estado del ítem (nuevo, desgastado, roto, encantado, etc.).
	Condition ItemCondition `json:"condition"`
	// Peso del ítem en kilogramos (kg).
	Weight float64 `json:"weight"`
	// Dimensiones del ítem (alto, ancho, largo).
	Dimensions string `json:"dimensions"`
	// Fecha de creación o forja del ítem (opcional).
	CreationDate *string `json:"creationDate,omitempty"`
	// Fecha de destrucción del ítem (opcional, si ya no existe).
	DestructionDate *string `json:"destructionDate,omitempty"`
	// Indica si el ítem tiene propiedades mágicas o sobrenaturales.
	IsMagical bool `json:"isMagical"`
	// Lista de habilidades o efectos que posee el ítem (si es mágico o especial).
	Abilities []string `json:"abilities"`
	// Costo del ítem en la moneda estándar del mundo.
	Value float64 `json:"value"`
}

// Estructura para crear una nueva ubicación dentro de un mundo.
type CreateLocationInput struct {
	// ID del mundo al que pertenece la ubicación.
	WorldID string `json:"worldId"`
	// Nombre de la ubicación.
	Name string `json:"name"`
	// Descripción detallada de la ubicación, incluyendo su historia y características.
	Description string `json:"description"`
	// Clasificación de la ubicación según su tipo (ciudad, bosque, mazmorra, etc.).
	Type LocationType `json:"type"`
	// Región o territorio al que pertenece la ubicación.
	Region string `json:"region"`
	// Coordenadas geográficas aproximadas (latitud, longitud).
	Coordinates string `json:"coordinates"`
	// Nivel de accesibilidad de la ubicación (pública, restringida, oculta, etc.).
	Accessibility LocationAccessibility `json:"accessibility"`
	// Indica si la ubicación es natural o artificial.
	IsNatural bool `json:"isNatural"`
	// Clima predominante en la ubicación.
	Climate string `json:"climate"`
	// Ecosistema de la ubicación (bosque, desierto, pantano, etc.).
	Ecosystem string `json:"ecosystem"`
}

// Estructura para crear un nuevo universo.
type CreateUniverseInput struct {
	// Nombre del universo.
	Name string `json:"name"`
	// Descripción del universo, incluyendo historia y detalles generales.
	Description string `json:"description"`
	// Año de creación o punto de referencia inicial del universo.
	StartYear *int `json:"startYear,omitempty"`
}

// Estructura para crear un nuevo mundo dentro de un universo.
type CreateWorldInput struct {
	// ID del universo al que pertenece el mundo.
	UniverseID string `json:"universeId"`
	// Nombre del mundo.
	Name string `json:"name"`
	// Descripción detallada del mundo, incluyendo historia y características únicas.
	Description string `json:"description"`
	// Clasificación del mundo según su naturaleza y origen.
	Type WorldType `json:"type"`
	// Nivel tecnológico predominante en el mundo (medieval, avanzado, mágico, etc.).
	TechnologyLevel string `json:"technologyLevel"`
	// Principales fuentes de energía utilizadas en el mundo.
	EnergySources []string `json:"energySources"`
	// Gravedad relativa del mundo en comparación con la Tierra (1.0 = gravedad terrestre).
	Gravity float64 `json:"gravity"`
	// Tamaño del mundo en relación a la Tierra (1.0 = tamaño terrestre).
	Size float64 `json:"size"`
	// Número de lunas o satélites naturales del mundo.
	Moons int `json:"moons"`
	// Número de soles o estrellas alrededor de las cuales orbita el mundo.
	Stars int `json:"stars"`
	// Clima predominante del mundo.
	Climate string `json:"climate"`
	// Ecosistema y bioma dominante del mundo.
	Ecosystem string `json:"ecosystem"`
	// Indica si el mundo tiene atmósfera y si es respirable por humanos.
	HasAtmosphere bool `json:"hasAtmosphere"`
	// Indica si el mundo está habitado por seres vivos.
	IsHabitable bool `json:"isHabitable"`
}

// Representa una criatura dentro del mundo ficticio.
// Incluye datos generales, atributos físicos, hábitat y relaciones con otras entidades.
type Creature struct {
	// Identificador único de la criatura.
	ID string `json:"_key"`
	// Fecha de creación de la criatura en el sistema (ISO 8601).
	CreatedAt string `json:"createdAt"`
	// Fecha de última actualización de la criatura en el sistema (ISO 8601).
	UpdatedAt string `json:"updatedAt"`
	// Nombre de la criatura.
	Name string `json:"name"`
	// Descripción de la criatura, incluyendo características únicas y comportamiento.
	Description string `json:"description"`
	// Tipo de entidad, útil para clasificar criaturas en el sistema.
	Type string `json:"type"`
	// Especie o categoría de la criatura (dragón, gólem, quimera, etc.).
	Species string `json:"species"`
	// Nivel de inteligencia de la criatura (bestia, sapiente, semisapiente, etc.).
	IntelligenceLevel string `json:"intelligenceLevel"`
	// Altura de la criatura en metros (m).
	Height float64 `json:"height"`
	// Peso de la criatura en kilogramos (kg).
	Weight float64 `json:"weight"`
	// Fecha de nacimiento de la criatura en formato ISO 8601 (YYYY-MM-DD).
	BirthDate string `json:"birthDate"`
	// Indica si la criatura está viva (true) o muerta (false).
	IsAlive bool `json:"isAlive"`
	// Esperanza de vida aproximada de la criatura en años.
	Lifespan *int `json:"lifespan,omitempty"`
	// Indica si la criatura es única o pertenece a una especie con múltiples individuos.
	IsUnique bool `json:"isUnique"`
	// Ambiente donde la criatura vive (bosques, montañas, océanos, etc.).
	Habitat string `json:"habitat"`
	// Comportamiento de la criatura (pacífica, territorial, agresiva, etc.).
	Behavior string `json:"behavior"`
	// Dieta de la criatura (carnívora, herbívora, omnívora, etc.).
	Diet string `json:"diet"`
	// Lista de habilidades especiales que posee la criatura (aliento de fuego, regeneración, telepatía, etc.).
	Abilities []string `json:"abilities"`
	// Lista de relaciones de la criatura con personajes, incluyendo domesticación o conflicto.
	Characters []*CharacterCreature `json:"characters"`
	// Lista de relaciones de la criatura con otras criaturas, incluyendo jerarquías o rivalidades.
	Creatures []*CreatureCreature `json:"creatures"`
	// Lista de relaciones de la criatura con facciones, como uso militar o veneración.
	Factions []*CreatureFaction `json:"factions"`
	// Lista de relaciones de la criatura con eventos, como participación en batallas o desastres naturales.
	Events []*CreatureEvent `json:"events"`
	// Lista de relaciones de la criatura con ubicaciones, como hábitat o migraciones.
	Locations []*CreatureLocation `json:"locations"`
	// Lista de relaciones de la criatura con mundos, como su origen o influencia interdimensional.
	Worlds []*CreatureWorld `json:"worlds"`
}

func (Creature) IsEntity()                   {}
func (this Creature) GetID() string          { return this.ID }
func (this Creature) GetCreatedAt() string   { return this.CreatedAt }
func (this Creature) GetUpdatedAt() string   { return this.UpdatedAt }
func (this Creature) GetName() string        { return this.Name }
func (this Creature) GetDescription() string { return this.Description }

// Define la relación entre dos criaturas.
// Puede representar jerarquía, rivalidad, simbiosis y otras interacciones naturales o mágicas.
type CreatureCreature struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La criatura con la que se establece la relación.
	Creature *Creature `json:"creature"`
	// Tipo de relación entre ambas criaturas (jerárquica, depredador-presa, simbiótica, etc.).
	Relation CreatureCreatureRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre una criatura y un evento.
// Puede representar participación en desastres, batallas, invocaciones y otros sucesos importantes.
type CreatureEvent struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La criatura con la que el evento tiene una relación.
	Creature *Creature `json:"creature"`
	// El evento con el que la criatura tiene una relación.
	Event *Event `json:"event"`
	// Tipo de relación entre la criatura y el evento (iniciador, participante, testigo, etc.).
	Relation CreatureEventRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre una criatura y una facción.
// Puede representar uso militar, veneración, domesticación o conflicto.
type CreatureFaction struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La criatura con la que la facción tiene una relación.
	Creature *Creature `json:"creature"`
	// La facción con la que la criatura tiene una relación.
	Faction *Faction `json:"faction"`
	// Tipo de relación entre la criatura y la facción (mascota, bestia de guerra, símbolo sagrado, etc.).
	Relation CreatureFactionRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre una criatura y una ubicación.
// Puede representar su hábitat, migraciones, dominio territorial y más.
type CreatureLocation struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La criatura con la que la ubicación tiene una relación.
	Creature *Creature `json:"creature"`
	// La ubicación con la que la criatura tiene una relación.
	Location *Location `json:"location"`
	// Tipo de relación entre la criatura y la ubicación (hábitat, migración, dominio territorial, etc.).
	Relation CreatureLocationRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre una criatura y un mundo.
// Puede representar origen, influencia interdimensional, exilio y más.
type CreatureWorld struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La criatura con la que el mundo tiene una relación.
	Creature *Creature `json:"creature"`
	// El mundo con el que la criatura tiene una relación.
	World *World `json:"world"`
	// Tipo de relación entre la criatura y el mundo (nativa, invocada, exiliada, etc.).
	Relation CreatureWorldRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Representa un evento dentro del mundo ficticio.
// Incluye datos generales, ubicación, impacto y relaciones con otras entidades.
type Event struct {
	// Identificador único del evento.
	ID string `json:"_key"`
	// Fecha de creación del evento en el sistema (ISO 8601).
	CreatedAt string `json:"createdAt"`
	// Fecha de última actualización del evento en el sistema (ISO 8601).
	UpdatedAt string `json:"updatedAt"`
	// Nombre del evento.
	Name string `json:"name"`
	// Descripción detallada del evento, incluyendo su impacto y contexto.
	Description string `json:"description"`
	// Clasificación del evento según su naturaleza (batalla, descubrimiento, ritual, etc.).
	Type EventType `json:"type"`
	// Indica la naturaleza del evento (planificado, accidental, fortuito, inevitable, etc.).
	Nature EventNature `json:"nature"`
	// Fecha de inicio del evento en formato ISO 8601 (YYYY-MM-DD).
	StartDate string `json:"startDate"`
	// Fecha de finalización del evento en formato ISO 8601 (YYYY-MM-DD).
	EndDate string `json:"endDate"`
	// Indica si el evento es recurrente (true) o único (false).
	IsRecurring bool `json:"isRecurring"`
	// Importancia del evento dentro de la historia (baja, media, alta).
	Significance EventSignificance `json:"significance"`
	// Lista de ubicaciones donde ocurrió el evento.
	Locations []*LocationEvent `json:"locations"`
	// Mundos en los que el evento tuvo un impacto.
	Worlds []*WorldEvent `json:"worlds"`
	// Lista de personajes involucrados en el evento.
	Characters []*CharacterEvent `json:"characters"`
	// Lista de criaturas que participaron en el evento.
	Creatures []*CreatureEvent `json:"creatures"`
	// Lista de facciones relacionadas con el evento.
	Factions []*FactionEvent `json:"factions"`
	// Lista de ítems asociados al evento (artefactos, armas, reliquias, etc.).
	Items []*ItemEvent `json:"items"`
	// Lista de eventos relacionados que ocurrieron antes, después o en paralelo.
	RelatedEvents []EventEvent `json:"relatedEvents"`
}

func (Event) IsEntity()                   {}
func (this Event) GetID() string          { return this.ID }
func (this Event) GetCreatedAt() string   { return this.CreatedAt }
func (this Event) GetUpdatedAt() string   { return this.UpdatedAt }
func (this Event) GetName() string        { return this.Name }
func (this Event) GetDescription() string { return this.Description }

// Representa una facción dentro del mundo ficticio.
// Incluye datos generales, estructura organizativa, ideología y relaciones con otras entidades.
type Faction struct {
	// Identificador único de la facción.
	ID string `json:"_key"`
	// Fecha de creación de la facción en el sistema (ISO 8601).
	CreatedAt string `json:"createdAt"`
	// Fecha de última actualización de la facción en el sistema (ISO 8601).
	UpdatedAt string `json:"updatedAt"`
	// Nombre de la facción.
	Name string `json:"name"`
	// Descripción de la facción, incluyendo su historia, cultura y propósito.
	Description string `json:"description"`
	// Clasificación de la facción según su estructura y propósito.
	Type FactionType `json:"type"`
	// Ideología, valores o principios que rigen a la facción.
	Ideology string `json:"ideology"`
	// Estatus actual de la facción (activa, disuelta, exiliada, etc.).
	Status FactionStatus `json:"status"`
	// Fecha de fundación de la facción en formato ISO 8601 (YYYY-MM-DD).
	FoundedDate string `json:"foundedDate"`
	// Fecha de disolución de la facción (opcional, en caso de que ya no exista).
	DisbandedDate *string `json:"disbandedDate,omitempty"`
	// Nivel de influencia de la facción en la historia o sociedad.
	Influence FactionInfluence `json:"influence"`
	// Lista de ubicaciones donde la facción tiene presencia, dominio o influencia.
	Locations []*FactionLocation `json:"locations"`
	// Lista de mundos donde la facción tiene presencia, influencia o ha sido exiliada.
	Worlds []*FactionWorld `json:"worlds"`
	// Lista de personajes afiliados a la facción.
	Characters []*CharacterFaction `json:"characters"`
	// Lista de criaturas asociadas a la facción (usadas en combate, veneradas, etc.).
	Creatures []*CreatureFaction `json:"creatures"`
	// Lista de facciones relacionadas (aliadas, enemigas, subordinadas, etc.).
	Factions []*FactionFaction `json:"factions"`
	// Lista de eventos clave en los que la facción estuvo involucrada.
	Events []*FactionEvent `json:"events"`
	// Lista de ítems asociados a la facción (armamento, reliquias, símbolos).
	Items []*FactionItem `json:"items"`
}

func (Faction) IsEntity()                   {}
func (this Faction) GetID() string          { return this.ID }
func (this Faction) GetCreatedAt() string   { return this.CreatedAt }
func (this Faction) GetUpdatedAt() string   { return this.UpdatedAt }
func (this Faction) GetName() string        { return this.Name }
func (this Faction) GetDescription() string { return this.Description }

// Define la relación entre una facción y un evento.
// Puede representar participación en batallas, diplomacia o conflictos internos.
type FactionEvent struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La facción que tiene la relación con el evento.
	Faction *Faction `json:"faction"`
	// El evento con el que la facción tiene una relación.
	Event *Event `json:"event"`
	// Tipo de relación entre la facción y el evento (participación, iniciador, oposición, etc.).
	Relation FactionEventRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre dos facciones.
// Puede incluir alianzas, enemistades, pactos y subordinación.
type FactionFaction struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La facción con la que se establece la relación.
	Faction *Faction `json:"faction"`
	// Tipo de relación entre ambas facciones (aliadas, enemigas, vasallaje, etc.).
	Relation FactionFactionRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre una facción y un ítem.
// Puede representar reliquias, símbolos de poder, armamento y más.
type FactionItem struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La facción que tiene la relación con el ítem.
	Faction *Faction `json:"faction"`
	// El ítem con el que la facción tiene una relación.
	Item *Item `json:"item"`
	// Tipo de relación entre la facción y el ítem (símbolo, reliquia, armamento, etc.).
	Relation FactionItemRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre una facción y una ubicación.
// Puede representar control, influencia, exilio o presencia estratégica.
type FactionLocation struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La facción que tiene la relación con la ubicación.
	Faction *Faction `json:"faction"`
	// La ubicación con la que la facción tiene una relación.
	Location *Location `json:"location"`
	// Tipo de relación entre la facción y la ubicación (control, influencia, exilio, etc.).
	Relation FactionLocationRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre una facción y un mundo.
// Puede representar su origen, dominio, influencia interdimensional o exilio.
type FactionWorld struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La facción que tiene la relación con el mundo.
	Faction *Faction `json:"faction"`
	// El mundo con el que la facción tiene una relación.
	World *World `json:"world"`
	// Tipo de relación entre la facción y el mundo (nativa, exiliada, gobernante, etc.).
	Relation FactionWorldRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Representa un ítem dentro del mundo ficticio.
// Incluye datos generales, características, propiedades y relaciones con otras entidades.
type Item struct {
	// Identificador único del ítem.
	ID string `json:"_key"`
	// Fecha de creación del ítem en el sistema (ISO 8601).
	CreatedAt string `json:"createdAt"`
	// Fecha de última actualización del ítem en el sistema (ISO 8601).
	UpdatedAt string `json:"updatedAt"`
	// Nombre del ítem.
	Name string `json:"name"`
	// Descripción del ítem, incluyendo su historia y propiedades únicas.
	Description string `json:"description"`
	// Clasificación del ítem según su función o propósito.
	Type ItemType `json:"type"`
	// Rareza del ítem dentro del mundo (común, poco común, raro, legendario).
	Rarity ItemRarity `json:"rarity"`
	// Espacio donde se equipa el ítem en el cuerpo o inventario.
	Slot ItemSlot `json:"slot"`
	// Material principal del que está hecho el ítem.
	Material string `json:"material"`
	// Estado del ítem (nuevo, desgastado, roto, encantado, etc.).
	Condition ItemCondition `json:"condition"`
	// Peso del ítem en kilogramos (kg).
	Weight float64 `json:"weight"`
	// Dimensiones del ítem (alto, ancho, largo).
	Dimensions string `json:"dimensions"`
	// Fecha de creación o forja del ítem (opcional).
	CreationDate *string `json:"creationDate,omitempty"`
	// Fecha de destrucción del ítem (opcional, si ya no existe).
	DestructionDate *string `json:"destructionDate,omitempty"`
	// Indica si el ítem tiene propiedades mágicas o sobrenaturales.
	IsMagical bool `json:"isMagical"`
	// Lista de habilidades o efectos que posee el ítem (si es mágico o especial).
	Abilities []string `json:"abilities"`
	// Costo del ítem en la moneda estándar del mundo.
	Value float64 `json:"value"`
	// Lista de personajes que han tenido o usado el ítem.
	Characters []*CharacterItem `json:"characters"`
	// Lista de facciones que han poseído o utilizado el ítem.
	Factions []*FactionItem `json:"factions"`
	// Lista de eventos en los que el ítem ha jugado un papel importante.
	Events []*ItemEvent `json:"events"`
	// Lista de ubicaciones donde el ítem ha estado o puede encontrarse.
	Locations []*ItemLocation `json:"locations"`
	// Lista de otros ítems relacionados (artefactos combinables, piezas de un set, etc.).
	RelatedItems []*ItemItem `json:"relatedItems"`
}

func (Item) IsEntity()                   {}
func (this Item) GetID() string          { return this.ID }
func (this Item) GetCreatedAt() string   { return this.CreatedAt }
func (this Item) GetUpdatedAt() string   { return this.UpdatedAt }
func (this Item) GetName() string        { return this.Name }
func (this Item) GetDescription() string { return this.Description }

// Define la relación entre un ítem y un evento.
// Puede representar su uso, descubrimiento, destrucción y más.
type ItemEvent struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El item con el que el evento tiene una relación.
	Item *Item `json:"item"`
	// El evento con el que el ítem tiene una relación.
	Event *Event `json:"event"`
	// Tipo de relación entre el ítem y el evento (descubrimiento, destrucción, uso, etc.).
	Relation ItemEventRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre dos ítems.
// Puede representar combinaciones, piezas de un set o evolución.
type ItemItem struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El otro ítem con el que se establece la relación.
	Item *Item `json:"item"`
	// Tipo de relación entre ambos ítems (combinables, piezas de un set, evolución, etc.).
	Relation ItemItemRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre un ítem y una ubicación.
// Puede representar su almacenamiento, hallazgo o pérdida.
type ItemLocation struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El ítem con el que la ubicación tiene una relación.
	Item *Item `json:"item"`
	// La ubicación con la que el ítem tiene una relación.
	With *Location `json:"with"`
	// Tipo de relación entre el ítem y la ubicación (almacenado, perdido, descubierto, etc.).
	Relation ItemLocationRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Representa una ubicación dentro del mundo ficticio.
// Incluye datos generales, características geográficas y relaciones con otras entidades.
type Location struct {
	// Identificador único de la ubicación.
	ID string `json:"_key"`
	// Fecha de creación de la ubicación en el sistema (ISO 8601).
	CreatedAt string `json:"createdAt"`
	// Fecha de última actualización de la ubicación en el sistema (ISO 8601).
	UpdatedAt string `json:"updatedAt"`
	// Nombre de la ubicación.
	Name string `json:"name"`
	// Descripción detallada de la ubicación, incluyendo su historia y características.
	Description string `json:"description"`
	// Clasificación de la ubicación según su tipo (ciudad, bosque, mazmorra, etc.).
	Type LocationType `json:"type"`
	// Región o territorio al que pertenece la ubicación.
	Region string `json:"region"`
	// Coordenadas geográficas aproximadas (latitud, longitud).
	Coordinates string `json:"coordinates"`
	// Nivel de accesibilidad de la ubicación (pública, restringida, oculta, etc.).
	Accessibility LocationAccessibility `json:"accessibility"`
	// Indica si la ubicación es natural o artificial.
	IsNatural bool `json:"isNatural"`
	// Clima predominante en la ubicación.
	Climate string `json:"climate"`
	// Ecosistema de la ubicación (bosque, desierto, pantano, etc.).
	Ecosystem string `json:"ecosystem"`
	// Lista de personajes que residen o han estado en la ubicación.
	Characters []*CharacterLocation `json:"characters"`
	// Lista de criaturas que habitan o han pasado por la ubicación.
	Creatures []*CreatureLocation `json:"creatures"`
	// Lista de facciones que controlan o han operado en la ubicación.
	Factions []*FactionLocation `json:"factions"`
	// Lista de eventos históricos que han ocurrido en la ubicación.
	Events []*LocationEvent `json:"events"`
	// Lista de ítems que han sido encontrados o almacenados en la ubicación.
	Items []*ItemLocation `json:"items"`
	// Lista de otras ubicaciones relacionadas (ciudades dentro de un país, conexiones mágicas, etc.).
	RelatedLocations []*LocationLocation `json:"relatedLocations"`
	// Lista de mundos en los que existe o influye esta ubicación.
	Worlds []*LocationWorld `json:"worlds"`
}

func (Location) IsEntity()                   {}
func (this Location) GetID() string          { return this.ID }
func (this Location) GetCreatedAt() string   { return this.CreatedAt }
func (this Location) GetUpdatedAt() string   { return this.UpdatedAt }
func (this Location) GetName() string        { return this.Name }
func (this Location) GetDescription() string { return this.Description }

// Define la relación entre una ubicación y un evento.
// Puede representar batallas, desastres, fundaciones y más.
type LocationEvent struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La ubicación con la que el evento tiene una relación.
	Location *Location `json:"location"`
	// El evento con el que la ubicación tiene una relación.
	Event *Event `json:"event"`
	// Tipo de relación entre la ubicación y el evento (batalla, destrucción, fundación, etc.).
	Relation LocationEventRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre dos ubicaciones.
// Puede representar conexiones geográficas, políticas o mágicas.
type LocationLocation struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La otra ubicación con la que se establece la relación.
	Location *Location `json:"location"`
	// Tipo de relación entre ambas ubicaciones (contenida dentro, conectada, capital, etc.).
	Relation LocationLocationRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre una ubicación y un mundo.
// Puede representar su existencia, conexiones interdimensionales o anomalías.
type LocationWorld struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// La ubicación con la que el mundo tiene una relación.
	Location *Location `json:"location"`
	// El mundo con el que la ubicación tiene una relación.
	World *World `json:"world"`
	// Tipo de relación entre la ubicación y el mundo (nativa, artificial, conectada, etc.).
	Relation LocationWorldRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Mutaciones para crear, actualizar y eliminar universos.
type Mutation struct {
}

// Consultas relacionadas con los universos dentro del sistema.
type Query struct {
}

type Response struct {
	Status  bool    `json:"status"`
	Message *string `json:"message,omitempty"`
}

// Representa un universo dentro del sistema de worldbuilding.
// Un universo agrupa múltiples mundos y sus respectivas entidades.
type Universe struct {
	// Identificador único del universo.
	ID string `json:"_key"`
	// Fecha de creación del universo en el sistema (ISO 8601).
	CreatedAt string `json:"createdAt"`
	// Fecha de última actualización del universo en el sistema (ISO 8601).
	UpdatedAt string `json:"updatedAt"`
	// Nombre del universo.
	Name string `json:"name"`
	// Descripción del universo, incluyendo su historia general y concepto.
	Description string `json:"description"`
	// Año de creación o punto de partida del universo en el sistema.
	StartYear int `json:"startYear"`
	// Indica si el universo está activo o archivado.
	IsActive bool `json:"isActive"`
	// Lista de mundos dentro de este universo.
	Worlds []*World `json:"worlds"`
	// Lista de facciones que operan en este universo.
	Factions []*Faction `json:"factions"`
	// Lista de personajes que pertenecen a este universo.
	Characters []*Character `json:"characters"`
	// Lista de criaturas que existen en este universo.
	Creatures []*Creature `json:"creatures"`
	// Lista de eventos importantes ocurridos en este universo.
	Events []*Event `json:"events"`
	// Lista de ubicaciones dentro de este universo.
	Locations []*Location `json:"locations"`
	// Lista de ítems únicos o de importancia en el universo.
	Items []*Item `json:"items"`
}

func (Universe) IsEntity()                   {}
func (this Universe) GetID() string          { return this.ID }
func (this Universe) GetCreatedAt() string   { return this.CreatedAt }
func (this Universe) GetUpdatedAt() string   { return this.UpdatedAt }
func (this Universe) GetName() string        { return this.Name }
func (this Universe) GetDescription() string { return this.Description }

// Estructura para actualizar un personaje existente.
type UpdateCharacterInput struct {
	// ID del personaje a modificar.
	ID string `json:"id"`
	// Nuevo nombre del personaje (opcional).
	Name *string `json:"name,omitempty"`
	// Nueva descripción del personaje (opcional).
	Description *string `json:"description,omitempty"`
	// Modificar el tipo del personaje (opcional).
	Type *string `json:"type,omitempty"`
	// Modificar la fecha de nacimiento del personaje (opcional).
	BirthDate *string `json:"birthDate,omitempty"`
	// Modificar la altura del personaje (opcional).
	Height *float64 `json:"height,omitempty"`
	// Modificar el peso del personaje (opcional).
	Weight *float64 `json:"weight,omitempty"`
	// Modificar si el personaje está vivo o muerto (opcional).
	IsAlive *bool `json:"isAlive,omitempty"`
	// Modificar si el personaje es un protagonista o no (opcional).
	IsMain *bool `json:"isMain,omitempty"`
	// Modificar el alineamiento del personaje (opcional).
	Alignment *Alignment `json:"alignment,omitempty"`
}

// Estructura para actualizar una criatura existente.
type UpdateCreatureInput struct {
	// ID de la criatura a modificar.
	ID string `json:"id"`
	// Nuevo nombre de la criatura (opcional).
	Name *string `json:"name,omitempty"`
	// Nueva descripción de la criatura (opcional).
	Description *string `json:"description,omitempty"`
	// Modificar el tipo de la criatura (opcional).
	Type *string `json:"type,omitempty"`
	// Modificar la especie de la criatura (opcional).
	Species *string `json:"species,omitempty"`
	// Modificar el nivel de inteligencia de la criatura (opcional).
	IntelligenceLevel *string `json:"intelligenceLevel,omitempty"`
	// Modificar la altura de la criatura (opcional).
	Height *float64 `json:"height,omitempty"`
	// Modificar el peso de la criatura (opcional).
	Weight *float64 `json:"weight,omitempty"`
	// Modificar la fecha de nacimiento de la criatura (opcional).
	BirthDate *string `json:"birthDate,omitempty"`
	// Modificar si la criatura está viva o muerta (opcional).
	IsAlive *bool `json:"isAlive,omitempty"`
	// Modificar la esperanza de vida de la criatura (opcional).
	Lifespan *int `json:"lifespan,omitempty"`
	// Modificar si la criatura es única o no (opcional).
	IsUnique *bool `json:"isUnique,omitempty"`
	// Modificar el hábitat de la criatura (opcional).
	Habitat *string `json:"habitat,omitempty"`
	// Modificar el comportamiento de la criatura (opcional).
	Behavior *string `json:"behavior,omitempty"`
	// Modificar la dieta de la criatura (opcional).
	Diet *string `json:"diet,omitempty"`
	// Modificar las habilidades de la criatura (opcional).
	Abilities []string `json:"abilities,omitempty"`
}

// Estructura para actualizar un evento existente.
type UpdateEventInput struct {
	// ID del evento a modificar.
	ID string `json:"id"`
	// Nuevo nombre del evento (opcional).
	Name *string `json:"name,omitempty"`
	// Nueva descripción del evento (opcional).
	Description *string `json:"description,omitempty"`
	// Modificar la clasificación del evento (opcional).
	Type *EventType `json:"type,omitempty"`
	// Modificar la naturaleza del evento (opcional).
	Nature *EventNature `json:"nature,omitempty"`
	// Modificar la fecha de inicio del evento (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Modificar la fecha de finalización del evento (opcional).
	EndDate *string `json:"endDate,omitempty"`
	// Modificar si el evento es recurrente (opcional).
	IsRecurring *bool `json:"isRecurring,omitempty"`
	// Modificar la importancia del evento en la historia (opcional).
	Significance *EventSignificance `json:"significance,omitempty"`
	// Modificar la lista de ubicaciones del evento (opcional).
	Locations []string `json:"locations,omitempty"`
	// Modificar la lista de mundos afectados por el evento (opcional).
	Worlds []string `json:"worlds,omitempty"`
}

// Estructura para actualizar una facción existente.
type UpdateFactionInput struct {
	// ID de la facción a modificar.
	ID string `json:"id"`
	// Nuevo nombre de la facción (opcional).
	Name *string `json:"name,omitempty"`
	// Nueva descripción de la facción (opcional).
	Description *string `json:"description,omitempty"`
	// Modificar la clasificación de la facción (opcional).
	Type *FactionType `json:"type,omitempty"`
	// Modificar la ideología de la facción (opcional).
	Ideology *string `json:"ideology,omitempty"`
	// Modificar el estatus actual de la facción (opcional).
	Status *FactionStatus `json:"status,omitempty"`
	// Modificar la fecha de fundación de la facción (opcional).
	FoundedDate *string `json:"foundedDate,omitempty"`
	// Modificar la fecha de disolución de la facción (opcional).
	DisbandedDate *string `json:"disbandedDate,omitempty"`
	// Modificar el nivel de influencia de la facción (opcional).
	Influence *FactionInfluence `json:"influence,omitempty"`
	// Modificar las ubicaciones donde la facción tiene presencia (opcional).
	Locations []string `json:"locations,omitempty"`
	// Modificar los mundos donde la facción tiene influencia (opcional).
	Worlds []string `json:"worlds,omitempty"`
}

// Estructura para actualizar un ítem existente.
type UpdateItemInput struct {
	// ID del ítem a modificar.
	ID string `json:"id"`
	// Nuevo nombre del ítem (opcional).
	Name *string `json:"name,omitempty"`
	// Nueva descripción del ítem (opcional).
	Description *string `json:"description,omitempty"`
	// Modificar la clasificación del ítem (opcional).
	Type *ItemType `json:"type,omitempty"`
	// Modificar la rareza del ítem (opcional).
	Rarity *ItemRarity `json:"rarity,omitempty"`
	// Modificar el espacio donde se equipa el ítem (opcional).
	Slot *ItemSlot `json:"slot,omitempty"`
	// Modificar el material del ítem (opcional).
	Material *string `json:"material,omitempty"`
	// Modificar el estado del ítem (opcional).
	Condition *ItemCondition `json:"condition,omitempty"`
	// Modificar el peso del ítem (opcional).
	Weight *float64 `json:"weight,omitempty"`
	// Modificar las dimensiones del ítem (opcional).
	Dimensions *string `json:"dimensions,omitempty"`
	// Modificar la fecha de creación del ítem (opcional).
	CreationDate *string `json:"creationDate,omitempty"`
	// Modificar la fecha de destrucción del ítem (opcional).
	DestructionDate *string `json:"destructionDate,omitempty"`
	// Modificar si el ítem tiene propiedades mágicas (opcional).
	IsMagical *bool `json:"isMagical,omitempty"`
	// Modificar las habilidades del ítem (opcional).
	Abilities []string `json:"abilities,omitempty"`
	// Modificar el costo del ítem (opcional).
	Value *float64 `json:"value,omitempty"`
}

// Estructura para actualizar una ubicación existente.
type UpdateLocationInput struct {
	// ID de la ubicación a modificar.
	ID string `json:"id"`
	// Nuevo nombre de la ubicación (opcional).
	Name *string `json:"name,omitempty"`
	// Nueva descripción de la ubicación (opcional).
	Description *string `json:"description,omitempty"`
	// Modificar la clasificación de la ubicación (opcional).
	Type *LocationType `json:"type,omitempty"`
	// Modificar la región o territorio de la ubicación (opcional).
	Region *string `json:"region,omitempty"`
	// Modificar las coordenadas de la ubicación (opcional).
	Coordinates *string `json:"coordinates,omitempty"`
	// Modificar el nivel de accesibilidad de la ubicación (opcional).
	Accessibility *LocationAccessibility `json:"accessibility,omitempty"`
	// Modificar si la ubicación es natural o artificial (opcional).
	IsNatural *bool `json:"isNatural,omitempty"`
	// Modificar el clima de la ubicación (opcional).
	Climate *string `json:"climate,omitempty"`
	// Modificar el ecosistema de la ubicación (opcional).
	Ecosystem *string `json:"ecosystem,omitempty"`
}

// Estructura para actualizar un universo existente.
type UpdateUniverseInput struct {
	// ID del universo a modificar.
	ID string `json:"id"`
	// Nuevo nombre del universo (opcional).
	Name *string `json:"name,omitempty"`
	// Nueva descripción del universo (opcional).
	Description *string `json:"description,omitempty"`
	// Modificar el año de inicio del universo (opcional).
	StartYear *int `json:"startYear,omitempty"`
	// Indicar si el universo sigue en expansión o ha finalizado (opcional).
	IsActive *bool `json:"isActive,omitempty"`
}

// Estructura para actualizar un mundo existente.
type UpdateWorldInput struct {
	// ID del mundo a modificar.
	ID string `json:"id"`
	// Nuevo nombre del mundo (opcional).
	Name *string `json:"name,omitempty"`
	// Nueva descripción del mundo (opcional).
	Description *string `json:"description,omitempty"`
	// Modificar la clasificación del mundo (opcional).
	Type *WorldType `json:"type,omitempty"`
	// Modificar el nivel tecnológico del mundo (opcional).
	TechnologyLevel *string `json:"technologyLevel,omitempty"`
	// Modificar las fuentes de energía utilizadas en el mundo (opcional).
	EnergySources []string `json:"energySources,omitempty"`
	// Modificar la gravedad del mundo (opcional).
	Gravity *float64 `json:"gravity,omitempty"`
	// Modificar el tamaño del mundo en relación a la Tierra (opcional).
	Size *float64 `json:"size,omitempty"`
	// Modificar el número de lunas del mundo (opcional).
	Moons *int `json:"moons,omitempty"`
	// Modificar el número de estrellas alrededor del mundo (opcional).
	Stars *int `json:"stars,omitempty"`
	// Modificar el clima del mundo (opcional).
	Climate *string `json:"climate,omitempty"`
	// Modificar el ecosistema y bioma del mundo (opcional).
	Ecosystem *string `json:"ecosystem,omitempty"`
	// Modificar si el mundo tiene atmósfera y si es respirable (opcional).
	HasAtmosphere *bool `json:"hasAtmosphere,omitempty"`
	// Modificar si el mundo es habitable (opcional).
	IsHabitable *bool `json:"isHabitable,omitempty"`
}

// Representa un mundo dentro de un universo ficticio.
// Incluye datos generales, características físicas y conexiones interdimensionales.
type World struct {
	// Identificador único del mundo.
	ID string `json:"_key"`
	// Fecha de creación del mundo en el sistema (ISO 8601).
	CreatedAt string `json:"createdAt"`
	// Fecha de última actualización del mundo en el sistema (ISO 8601).
	UpdatedAt string `json:"updatedAt"`
	// Nombre del mundo.
	Name string `json:"name"`
	// Descripción detallada del mundo, incluyendo su historia y características únicas.
	Description string `json:"description"`
	// Clasificación del mundo según su naturaleza y origen.
	Type WorldType `json:"type"`
	// El universo al que pertenece este mundo.
	Universe *Universe `json:"universe"`
	// Nivel tecnológico predominante en el mundo (medieval, avanzado, mágico, etc.).
	TechnologyLevel string `json:"technologyLevel"`
	// Principales fuentes de energía utilizadas en el mundo.
	EnergySources []string `json:"energySources"`
	// Gravedad relativa del mundo en comparación con la Tierra (1.0 = gravedad terrestre).
	Gravity float64 `json:"gravity"`
	// Tamaño del mundo en relación a la Tierra (1.0 = tamaño terrestre).
	Size float64 `json:"size"`
	// Número de lunas o satélites naturales del mundo.
	Moons int `json:"moons"`
	// Número de soles o estrellas alrededor de las cuales orbita el mundo.
	Stars int `json:"stars"`
	// Clima predominante del mundo.
	Climate string `json:"climate"`
	// Ecosistema y bioma dominante del mundo.
	Ecosystem string `json:"ecosystem"`
	// Indica si el mundo tiene atmósfera y si es respirable por humanos.
	HasAtmosphere bool `json:"hasAtmosphere"`
	// Indica si el mundo está habitado por seres vivos.
	IsHabitable bool `json:"isHabitable"`
	// Lista de personajes asociados a este mundo.
	Characters []*CharacterWorld `json:"characters"`
	// Lista de criaturas que existen o han existido en este mundo.
	Creatures []*CreatureWorld `json:"creatures"`
	// Lista de facciones con presencia o influencia en este mundo.
	Factions []*FactionWorld `json:"factions"`
	// Lista de eventos importantes que han ocurrido en este mundo.
	Events []*WorldEvent `json:"events"`
	// Lista de ubicaciones dentro del mundo.
	Locations []*LocationWorld `json:"locations"`
	// Lista de mundos conectados a este a través de portales o interacciones interdimensionales.
	ConnectedWorlds []*WorldWorld `json:"connectedWorlds"`
}

func (World) IsEntity()                   {}
func (this World) GetID() string          { return this.ID }
func (this World) GetCreatedAt() string   { return this.CreatedAt }
func (this World) GetUpdatedAt() string   { return this.UpdatedAt }
func (this World) GetName() string        { return this.Name }
func (this World) GetDescription() string { return this.Description }

// Define la relación entre un mundo y un evento.
// Puede representar desastres, descubrimientos, guerras y más.
type WorldEvent struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El mundo en el que ocurrió el evento.
	World *World `json:"world"`
	// El evento con el que el mundo tiene una relación.
	Event *Event `json:"event"`
	// Tipo de relación entre el mundo y el evento (destrucción, descubrimiento, alteración, etc.).
	Relation WorldEventRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

// Define la relación entre dos mundos.
// Puede representar conexiones interdimensionales, origen compartido y más.
type WorldWorld struct {
	// El id de la relación entre personajes.
	ID string `json:"_key"`
	// El otro mundo con el que se establece la relación.
	World *World `json:"world"`
	// Tipo de relación entre ambos mundos (conectados, creados uno a partir del otro, etc.).
	Relation WorldWorldRelation `json:"relation"`
	// Fecha en que comenzó la relación (opcional).
	StartDate *string `json:"startDate,omitempty"`
	// Fecha en que terminó la relación (opcional).
	EndDate *string `json:"endDate,omitempty"`
}

type Alignment string

const (
	AlignmentLawfulGood     Alignment = "LAWFUL_GOOD"
	AlignmentNeutralGood    Alignment = "NEUTRAL_GOOD"
	AlignmentChaoticGood    Alignment = "CHAOTIC_GOOD"
	AlignmentLawfulNeutral  Alignment = "LAWFUL_NEUTRAL"
	AlignmentTrueNeutral    Alignment = "TRUE_NEUTRAL"
	AlignmentChaoticNeutral Alignment = "CHAOTIC_NEUTRAL"
	AlignmentLawfulEvil     Alignment = "LAWFUL_EVIL"
	AlignmentNeutralEvil    Alignment = "NEUTRAL_EVIL"
	AlignmentChaoticEvil    Alignment = "CHAOTIC_EVIL"
)

var AllAlignment = []Alignment{
	AlignmentLawfulGood,
	AlignmentNeutralGood,
	AlignmentChaoticGood,
	AlignmentLawfulNeutral,
	AlignmentTrueNeutral,
	AlignmentChaoticNeutral,
	AlignmentLawfulEvil,
	AlignmentNeutralEvil,
	AlignmentChaoticEvil,
}

func (e Alignment) IsValid() bool {
	switch e {
	case AlignmentLawfulGood, AlignmentNeutralGood, AlignmentChaoticGood, AlignmentLawfulNeutral, AlignmentTrueNeutral, AlignmentChaoticNeutral, AlignmentLawfulEvil, AlignmentNeutralEvil, AlignmentChaoticEvil:
		return true
	}
	return false
}

func (e Alignment) String() string {
	return string(e)
}

func (e *Alignment) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Alignment(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Alignment", str)
	}
	return nil
}

func (e Alignment) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define el tipo de relación que un personaje puede tener con una criatura.
// Estos valores se usan para modelar interacciones en el mundo ficticio.
type CharacterCreatureRelation string

const (
	// El personaje es dueño de la criatura (mascota, montura, familiar).
	CharacterCreatureRelationOwner CharacterCreatureRelation = "OWNER"
	// El personaje está intentando domesticar la criatura, pero aún no tiene éxito.
	CharacterCreatureRelationTameAttempt CharacterCreatureRelation = "TAME_ATTEMPT"
	// La criatura ha sido domesticada con éxito y obedece al personaje.
	CharacterCreatureRelationTamed CharacterCreatureRelation = "TAMED"
	// La criatura protege o vigila al personaje (lobo guardián, gólem, etc.).
	CharacterCreatureRelationGuardian CharacterCreatureRelation = "GUARDIAN"
	// La criatura y el personaje son compañeros, pero sin una relación de propiedad.
	CharacterCreatureRelationCompanion CharacterCreatureRelation = "COMPANION"
	// El personaje y la criatura cazan juntos como aliados.
	CharacterCreatureRelationHuntingPartner CharacterCreatureRelation = "HUNTING_PARTNER"
	// El personaje caza activamente a la criatura.
	CharacterCreatureRelationHunted CharacterCreatureRelation = "HUNTED"
	// La criatura es hostil hacia el personaje y lo ataca al verlo.
	CharacterCreatureRelationEnemy CharacterCreatureRelation = "ENEMY"
	// El personaje venera a la criatura como una entidad divina.
	CharacterCreatureRelationWorships CharacterCreatureRelation = "WORSHIPS"
	// La criatura es una manifestación de un dios o entidad superior.
	CharacterCreatureRelationDeityAvatar CharacterCreatureRelation = "DEITY_AVATAR"
	// El personaje invocó a la criatura con un ritual (demonios, elementales, etc.).
	CharacterCreatureRelationSummoned CharacterCreatureRelation = "SUMMONED"
	// La criatura y el personaje están fusionados por un vínculo sobrenatural.
	CharacterCreatureRelationFused CharacterCreatureRelation = "FUSED"
	// La criatura fue creada a partir de una maldición lanzada por el personaje.
	CharacterCreatureRelationCursed CharacterCreatureRelation = "CURSED"
	// El personaje monta a la criatura como un medio de transporte (caballo, dragón).
	CharacterCreatureRelationRides CharacterCreatureRelation = "RIDES"
	// La criatura es un experimento creado por el personaje (quimera, mutación).
	CharacterCreatureRelationExperiment CharacterCreatureRelation = "EXPERIMENT"
)

var AllCharacterCreatureRelation = []CharacterCreatureRelation{
	CharacterCreatureRelationOwner,
	CharacterCreatureRelationTameAttempt,
	CharacterCreatureRelationTamed,
	CharacterCreatureRelationGuardian,
	CharacterCreatureRelationCompanion,
	CharacterCreatureRelationHuntingPartner,
	CharacterCreatureRelationHunted,
	CharacterCreatureRelationEnemy,
	CharacterCreatureRelationWorships,
	CharacterCreatureRelationDeityAvatar,
	CharacterCreatureRelationSummoned,
	CharacterCreatureRelationFused,
	CharacterCreatureRelationCursed,
	CharacterCreatureRelationRides,
	CharacterCreatureRelationExperiment,
}

func (e CharacterCreatureRelation) IsValid() bool {
	switch e {
	case CharacterCreatureRelationOwner, CharacterCreatureRelationTameAttempt, CharacterCreatureRelationTamed, CharacterCreatureRelationGuardian, CharacterCreatureRelationCompanion, CharacterCreatureRelationHuntingPartner, CharacterCreatureRelationHunted, CharacterCreatureRelationEnemy, CharacterCreatureRelationWorships, CharacterCreatureRelationDeityAvatar, CharacterCreatureRelationSummoned, CharacterCreatureRelationFused, CharacterCreatureRelationCursed, CharacterCreatureRelationRides, CharacterCreatureRelationExperiment:
		return true
	}
	return false
}

func (e CharacterCreatureRelation) String() string {
	return string(e)
}

func (e *CharacterCreatureRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CharacterCreatureRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CharacterCreatureRelation", str)
	}
	return nil
}

func (e CharacterCreatureRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación que un personaje puede tener con un evento en el mundo ficticio.
// Incluye participación directa, testimonio, organización, influencia y otras interacciones posibles.
type CharacterEventRelation string

const (
	// El personaje fue el principal responsable del evento. Puede ser el iniciador, el líder o el causante del suceso.
	CharacterEventRelationInitiator CharacterEventRelation = "INITIATOR"
	// El personaje participó activamente en el evento como protagonista o actor clave.
	CharacterEventRelationParticipant CharacterEventRelation = "PARTICIPANT"
	// El personaje organizó el evento, pero no participó directamente en su desarrollo.
	CharacterEventRelationOrganizer CharacterEventRelation = "ORGANIZER"
	// El personaje fue testigo del evento sin intervenir activamente.
	CharacterEventRelationWitness CharacterEventRelation = "WITNESS"
	// El personaje fue afectado por el evento, ya sea de manera positiva o negativa, pero sin participación directa.
	CharacterEventRelationAffected CharacterEventRelation = "AFFECTED"
	// El personaje influyó en el evento de alguna manera indirecta, sin estar presente.
	CharacterEventRelationInfluencer CharacterEventRelation = "INFLUENCER"
	// El personaje intentó detener el evento o evitar que sucediera.
	CharacterEventRelationOpposer CharacterEventRelation = "OPPOSER"
	// El personaje investigó o estudió el evento después de que ocurriera, sin haber estado presente en el momento.
	CharacterEventRelationInvestigator CharacterEventRelation = "INVESTIGATOR"
	// El personaje se enteró del evento y lo difundió a otras personas.
	CharacterEventRelationReporter CharacterEventRelation = "REPORTER"
	// El personaje utilizó el evento como una oportunidad para su propio beneficio (económico, político, militar, etc.).
	CharacterEventRelationOpportunist CharacterEventRelation = "OPPORTUNIST"
	// El personaje sufrió una pérdida o fue una víctima directa del evento.
	CharacterEventRelationVictim CharacterEventRelation = "VICTIM"
	// El personaje fue rescatado durante el evento o dependió de la ayuda de otros para sobrevivir.
	CharacterEventRelationRescued CharacterEventRelation = "RESCUED"
	// El personaje rescató a otras personas o ayudó a mitigar los efectos del evento.
	CharacterEventRelationSavior CharacterEventRelation = "SAVIOR"
	// El personaje creó una obra basada en el evento (arte, literatura, música, etc.).
	CharacterEventRelationChronicler CharacterEventRelation = "CHRONICLER"
)

var AllCharacterEventRelation = []CharacterEventRelation{
	CharacterEventRelationInitiator,
	CharacterEventRelationParticipant,
	CharacterEventRelationOrganizer,
	CharacterEventRelationWitness,
	CharacterEventRelationAffected,
	CharacterEventRelationInfluencer,
	CharacterEventRelationOpposer,
	CharacterEventRelationInvestigator,
	CharacterEventRelationReporter,
	CharacterEventRelationOpportunist,
	CharacterEventRelationVictim,
	CharacterEventRelationRescued,
	CharacterEventRelationSavior,
	CharacterEventRelationChronicler,
}

func (e CharacterEventRelation) IsValid() bool {
	switch e {
	case CharacterEventRelationInitiator, CharacterEventRelationParticipant, CharacterEventRelationOrganizer, CharacterEventRelationWitness, CharacterEventRelationAffected, CharacterEventRelationInfluencer, CharacterEventRelationOpposer, CharacterEventRelationInvestigator, CharacterEventRelationReporter, CharacterEventRelationOpportunist, CharacterEventRelationVictim, CharacterEventRelationRescued, CharacterEventRelationSavior, CharacterEventRelationChronicler:
		return true
	}
	return false
}

func (e CharacterEventRelation) String() string {
	return string(e)
}

func (e *CharacterEventRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CharacterEventRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CharacterEventRelation", str)
	}
	return nil
}

func (e CharacterEventRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre un personaje y una facción.
// Incluye afiliaciones, liderazgos, enemistades e interacciones indirectas.
type CharacterFactionRelation string

const (
	// El personaje es el líder absoluto de la facción (rey, emperador, comandante supremo).
	CharacterFactionRelationLeader CharacterFactionRelation = "LEADER"
	// El personaje es un miembro activo de la facción.
	CharacterFactionRelationMember CharacterFactionRelation = "MEMBER"
	// El personaje es un ex-miembro que dejó la facción de manera voluntaria o fue expulsado.
	CharacterFactionRelationFormerMember CharacterFactionRelation = "FORMER_MEMBER"
	// El personaje es un aliado de la facción sin ser miembro oficial.
	CharacterFactionRelationAlly CharacterFactionRelation = "ALLY"
	// El personaje es un enemigo de la facción y se opone a sus intereses.
	CharacterFactionRelationEnemy CharacterFactionRelation = "ENEMY"
	// El personaje financia o apoya a la facción sin ser miembro activo.
	CharacterFactionRelationSponsor CharacterFactionRelation = "SPONSOR"
	// El personaje trabaja para la facción bajo contrato, sin lealtad directa.
	CharacterFactionRelationMercenary CharacterFactionRelation = "MERCENARY"
	// El personaje ha sido capturado por la facción y está prisionero.
	CharacterFactionRelationPrisoner CharacterFactionRelation = "PRISONER"
	// El personaje es un informante o espía dentro de la facción.
	CharacterFactionRelationInformant CharacterFactionRelation = "INFORMANT"
	// El personaje está siendo manipulado por la facción sin su conocimiento.
	CharacterFactionRelationPuppet CharacterFactionRelation = "PUPPET"
)

var AllCharacterFactionRelation = []CharacterFactionRelation{
	CharacterFactionRelationLeader,
	CharacterFactionRelationMember,
	CharacterFactionRelationFormerMember,
	CharacterFactionRelationAlly,
	CharacterFactionRelationEnemy,
	CharacterFactionRelationSponsor,
	CharacterFactionRelationMercenary,
	CharacterFactionRelationPrisoner,
	CharacterFactionRelationInformant,
	CharacterFactionRelationPuppet,
}

func (e CharacterFactionRelation) IsValid() bool {
	switch e {
	case CharacterFactionRelationLeader, CharacterFactionRelationMember, CharacterFactionRelationFormerMember, CharacterFactionRelationAlly, CharacterFactionRelationEnemy, CharacterFactionRelationSponsor, CharacterFactionRelationMercenary, CharacterFactionRelationPrisoner, CharacterFactionRelationInformant, CharacterFactionRelationPuppet:
		return true
	}
	return false
}

func (e CharacterFactionRelation) String() string {
	return string(e)
}

func (e *CharacterFactionRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CharacterFactionRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CharacterFactionRelation", str)
	}
	return nil
}

func (e CharacterFactionRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre un personaje y un ítem.
// Puede representar posesión, uso, creación, destrucción o influencia del objeto en el personaje.
type CharacterItemRelation string

const (
	// El personaje es el dueño actual del ítem.
	CharacterItemRelationOwner CharacterItemRelation = "OWNER"
	// El personaje fue dueño del ítem, pero lo perdió o se deshizo de él.
	CharacterItemRelationFormerOwner CharacterItemRelation = "FORMER_OWNER"
	// El personaje usa activamente el ítem, aunque no sea el dueño.
	CharacterItemRelationUser CharacterItemRelation = "USER"
	// El personaje creó el ítem (forja, magia, ingeniería, etc.).
	CharacterItemRelationCreator CharacterItemRelation = "CREATOR"
	// El personaje destruyó el ítem o fue responsable de su pérdida.
	CharacterItemRelationDestroyer CharacterItemRelation = "DESTROYER"
	// El personaje busca obtener el ítem por algún motivo.
	CharacterItemRelationSeeker CharacterItemRelation = "SEEKER"
	// El personaje protege el ítem y evita que caiga en malas manos.
	CharacterItemRelationGuardian CharacterItemRelation = "GUARDIAN"
	// El personaje está maldito o influenciado negativamente por el ítem.
	CharacterItemRelationCursed CharacterItemRelation = "CURSED"
	// El personaje vendió, intercambió o regaló el ítem.
	CharacterItemRelationMerchant CharacterItemRelation = "MERCHANT"
	// El personaje investigó el ítem para conocer su origen y propiedades.
	CharacterItemRelationScholar CharacterItemRelation = "SCHOLAR"
)

var AllCharacterItemRelation = []CharacterItemRelation{
	CharacterItemRelationOwner,
	CharacterItemRelationFormerOwner,
	CharacterItemRelationUser,
	CharacterItemRelationCreator,
	CharacterItemRelationDestroyer,
	CharacterItemRelationSeeker,
	CharacterItemRelationGuardian,
	CharacterItemRelationCursed,
	CharacterItemRelationMerchant,
	CharacterItemRelationScholar,
}

func (e CharacterItemRelation) IsValid() bool {
	switch e {
	case CharacterItemRelationOwner, CharacterItemRelationFormerOwner, CharacterItemRelationUser, CharacterItemRelationCreator, CharacterItemRelationDestroyer, CharacterItemRelationSeeker, CharacterItemRelationGuardian, CharacterItemRelationCursed, CharacterItemRelationMerchant, CharacterItemRelationScholar:
		return true
	}
	return false
}

func (e CharacterItemRelation) String() string {
	return string(e)
}

func (e *CharacterItemRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CharacterItemRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CharacterItemRelation", str)
	}
	return nil
}

func (e CharacterItemRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre un personaje y una ubicación.
// Puede representar origen, residencia, gobierno, exploración o conflicto con el lugar.
type CharacterLocationRelation string

const (
	// El personaje nació en esta ubicación.
	CharacterLocationRelationBirthplace CharacterLocationRelation = "BIRTHPLACE"
	// El personaje vive en esta ubicación de manera permanente.
	CharacterLocationRelationResident CharacterLocationRelation = "RESIDENT"
	// El personaje gobierna la ubicación o tiene autoridad sobre ella.
	CharacterLocationRelationRuler CharacterLocationRelation = "RULER"
	// El personaje pasó por la ubicación temporalmente.
	CharacterLocationRelationVisitor CharacterLocationRelation = "VISITOR"
	// El personaje exploró la ubicación en busca de conocimiento o recursos.
	CharacterLocationRelationExplorer CharacterLocationRelation = "EXPLORER"
	// El personaje fue exiliado de la ubicación y no puede regresar.
	CharacterLocationRelationExiled CharacterLocationRelation = "EXILED"
	// El personaje está en la ubicación en contra de su voluntad (prisión, secuestro).
	CharacterLocationRelationCaptive CharacterLocationRelation = "CAPTIVE"
	// El personaje participó en una batalla que ocurrió en la ubicación.
	CharacterLocationRelationBattlefieldParticipant CharacterLocationRelation = "BATTLEFIELD_PARTICIPANT"
	// El personaje destruyó parte o toda la ubicación.
	CharacterLocationRelationDestroyer CharacterLocationRelation = "DESTROYER"
)

var AllCharacterLocationRelation = []CharacterLocationRelation{
	CharacterLocationRelationBirthplace,
	CharacterLocationRelationResident,
	CharacterLocationRelationRuler,
	CharacterLocationRelationVisitor,
	CharacterLocationRelationExplorer,
	CharacterLocationRelationExiled,
	CharacterLocationRelationCaptive,
	CharacterLocationRelationBattlefieldParticipant,
	CharacterLocationRelationDestroyer,
}

func (e CharacterLocationRelation) IsValid() bool {
	switch e {
	case CharacterLocationRelationBirthplace, CharacterLocationRelationResident, CharacterLocationRelationRuler, CharacterLocationRelationVisitor, CharacterLocationRelationExplorer, CharacterLocationRelationExiled, CharacterLocationRelationCaptive, CharacterLocationRelationBattlefieldParticipant, CharacterLocationRelationDestroyer:
		return true
	}
	return false
}

func (e CharacterLocationRelation) String() string {
	return string(e)
}

func (e *CharacterLocationRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CharacterLocationRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CharacterLocationRelation", str)
	}
	return nil
}

func (e CharacterLocationRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Representa el nivel de relación entre dos personajes.
// Incluye relaciones de amistad, rivalidad, mentoría, familia y jerarquía profesional.
type CharacterRelationLevel string

const (
	// Relación de enemistad extrema o de larga duración. Oponentes acérrimos con un conflicto prolongado.
	CharacterRelationLevelArchenemy CharacterRelationLevel = "ARCHENEMY"
	// Oposición activa con conflictos frecuentes y hostilidad evidente.
	CharacterRelationLevelEnemy CharacterRelationLevel = "ENEMY"
	// Competencia recurrente sin llegar al odio extremo. Puede incluir rivalidad deportiva, profesional o personal.
	CharacterRelationLevelRival CharacterRelationLevel = "RIVAL"
	// Relación sin una inclinación fuerte. Desconocidos o con interacciones superficiales sin impacto significativo.
	CharacterRelationLevelNeutral CharacterRelationLevel = "NEUTRAL"
	// Conocidos casuales, sin una conexión profunda. Se han cruzado en el pasado pero no tienen una relación establecida.
	CharacterRelationLevelAcquaintance CharacterRelationLevel = "ACQUAINTANCE"
	// Amistad cercana o alianza de confianza. Relación basada en apoyo mutuo y cooperación.
	CharacterRelationLevelFriend CharacterRelationLevel = "FRIEND"
	// Amistad extremadamente fuerte, cercana al concepto de familia. Puede incluir lazos de hermandad sin ser de sangre.
	CharacterRelationLevelBestFriend CharacterRelationLevel = "BEST_FRIEND"
	// Relación maestro-alumno o de enseñanza. Un personaje guía al otro en su desarrollo personal o profesional.
	CharacterRelationLevelMentor CharacterRelationLevel = "MENTOR"
	// Recíproco del mentor: el protegido o aprendiz que recibe conocimiento, entrenamiento o apoyo de un mentor.
	CharacterRelationLevelProtege CharacterRelationLevel = "PROTEGE"
	// Relación amorosa en cualquier etapa inicial. Puede ser un interés romántico, enamoramiento o relación incipiente.
	CharacterRelationLevelRomantic CharacterRelationLevel = "ROMANTIC"
	// Relación romántica establecida. Puede incluir parejas casadas, comprometidas o con un vínculo consolidado.
	CharacterRelationLevelPartner CharacterRelationLevel = "PARTNER"
	// Relación de parentesco, ya sea por sangre o adopción. Incluye lazos familiares directos o extendidos.
	CharacterRelationLevelFamily CharacterRelationLevel = "FAMILY"
	// Amor no correspondido. Un personaje siente afecto por otro, pero este no le responde de la misma manera.
	CharacterRelationLevelUnrequited CharacterRelationLevel = "UNREQUITED"
	// Amistad rota por eventos pasados. Dos personajes que fueron amigos pero cuya relación se ha deteriorado o ha terminado.
	CharacterRelationLevelFormerFriend CharacterRelationLevel = "FORMER_FRIEND"
	// Relación amorosa que terminó, pero cuyo impacto sigue presente en la historia o en la dinámica entre personajes.
	CharacterRelationLevelFormerLover CharacterRelationLevel = "FORMER_LOVER"
	// Asociación basada en un interés común, sin necesidad de amistad. Puede incluir alianzas temporales o estratégicas.
	CharacterRelationLevelAlly CharacterRelationLevel = "ALLY"
	// Miembros de la misma organización, grupo o facción. Comparten una afiliación en un contexto militar, político, religioso o social.
	CharacterRelationLevelFactionMember CharacterRelationLevel = "FACTION_MEMBER"
	// Relación de autoridad en la que un personaje tiene poder sobre otro. Puede representar jefe-subordinado o líder-miembro.
	CharacterRelationLevelSuperior CharacterRelationLevel = "SUPERIOR"
	// Relación inversa de autoridad: el personaje es subordinado o está bajo las órdenes de otro.
	CharacterRelationLevelSubordinate CharacterRelationLevel = "SUBORDINATE"
)

var AllCharacterRelationLevel = []CharacterRelationLevel{
	CharacterRelationLevelArchenemy,
	CharacterRelationLevelEnemy,
	CharacterRelationLevelRival,
	CharacterRelationLevelNeutral,
	CharacterRelationLevelAcquaintance,
	CharacterRelationLevelFriend,
	CharacterRelationLevelBestFriend,
	CharacterRelationLevelMentor,
	CharacterRelationLevelProtege,
	CharacterRelationLevelRomantic,
	CharacterRelationLevelPartner,
	CharacterRelationLevelFamily,
	CharacterRelationLevelUnrequited,
	CharacterRelationLevelFormerFriend,
	CharacterRelationLevelFormerLover,
	CharacterRelationLevelAlly,
	CharacterRelationLevelFactionMember,
	CharacterRelationLevelSuperior,
	CharacterRelationLevelSubordinate,
}

func (e CharacterRelationLevel) IsValid() bool {
	switch e {
	case CharacterRelationLevelArchenemy, CharacterRelationLevelEnemy, CharacterRelationLevelRival, CharacterRelationLevelNeutral, CharacterRelationLevelAcquaintance, CharacterRelationLevelFriend, CharacterRelationLevelBestFriend, CharacterRelationLevelMentor, CharacterRelationLevelProtege, CharacterRelationLevelRomantic, CharacterRelationLevelPartner, CharacterRelationLevelFamily, CharacterRelationLevelUnrequited, CharacterRelationLevelFormerFriend, CharacterRelationLevelFormerLover, CharacterRelationLevelAlly, CharacterRelationLevelFactionMember, CharacterRelationLevelSuperior, CharacterRelationLevelSubordinate:
		return true
	}
	return false
}

func (e CharacterRelationLevel) String() string {
	return string(e)
}

func (e *CharacterRelationLevel) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CharacterRelationLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CharacterRelationLevel", str)
	}
	return nil
}

func (e CharacterRelationLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre un personaje y un mundo.
// Puede representar ciudadanía, exploración, influencia o enemistad con el mundo.
type CharacterWorldRelation string

const (
	// El personaje nació en este mundo.
	CharacterWorldRelationNative CharacterWorldRelation = "NATIVE"
	// El personaje es un residente actual del mundo, pero no necesariamente nativo.
	CharacterWorldRelationResident CharacterWorldRelation = "RESIDENT"
	// El personaje es un extranjero que llegó desde otro mundo.
	CharacterWorldRelationOutsider CharacterWorldRelation = "OUTSIDER"
	// El personaje tiene una influencia significativa en la política, cultura o historia del mundo.
	CharacterWorldRelationInfluencer CharacterWorldRelation = "INFLUENCER"
	// El personaje busca activamente proteger el mundo o mantener su equilibrio.
	CharacterWorldRelationGuardian CharacterWorldRelation = "GUARDIAN"
	// El personaje es un conquistador que busca dominar el mundo.
	CharacterWorldRelationConqueror CharacterWorldRelation = "CONQUEROR"
	// El personaje es un destructor que quiere traer caos o aniquilación al mundo.
	CharacterWorldRelationDestroyer CharacterWorldRelation = "DESTROYER"
	// El personaje explora el mundo en busca de conocimiento o aventuras.
	CharacterWorldRelationExplorer CharacterWorldRelation = "EXPLORER"
	// El personaje fue exiliado del mundo y no puede regresar.
	CharacterWorldRelationExiled CharacterWorldRelation = "EXILED"
	// El personaje fue convocado a este mundo por medios sobrenaturales (magia, rituales, etc.).
	CharacterWorldRelationSummoned CharacterWorldRelation = "SUMMONED"
)

var AllCharacterWorldRelation = []CharacterWorldRelation{
	CharacterWorldRelationNative,
	CharacterWorldRelationResident,
	CharacterWorldRelationOutsider,
	CharacterWorldRelationInfluencer,
	CharacterWorldRelationGuardian,
	CharacterWorldRelationConqueror,
	CharacterWorldRelationDestroyer,
	CharacterWorldRelationExplorer,
	CharacterWorldRelationExiled,
	CharacterWorldRelationSummoned,
}

func (e CharacterWorldRelation) IsValid() bool {
	switch e {
	case CharacterWorldRelationNative, CharacterWorldRelationResident, CharacterWorldRelationOutsider, CharacterWorldRelationInfluencer, CharacterWorldRelationGuardian, CharacterWorldRelationConqueror, CharacterWorldRelationDestroyer, CharacterWorldRelationExplorer, CharacterWorldRelationExiled, CharacterWorldRelationSummoned:
		return true
	}
	return false
}

func (e CharacterWorldRelation) String() string {
	return string(e)
}

func (e *CharacterWorldRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CharacterWorldRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CharacterWorldRelation", str)
	}
	return nil
}

func (e CharacterWorldRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre dos criaturas.
// Puede representar jerarquía, rivalidad, simbiosis y otras interacciones naturales o mágicas.
type CreatureCreatureRelation string

const (
	// Una criatura es la líder de la otra dentro de una manada o sociedad.
	CreatureCreatureRelationLeader CreatureCreatureRelation = "LEADER"
	// Las criaturas forman parte de la misma manada, colonia o sociedad.
	CreatureCreatureRelationPackMember CreatureCreatureRelation = "PACK_MEMBER"
	// Las criaturas tienen una relación parental (madre/padre e hijo).
	CreatureCreatureRelationParent CreatureCreatureRelation = "PARENT"
	// Las criaturas son hermanos de la misma especie o camada.
	CreatureCreatureRelationSibling CreatureCreatureRelation = "SIBLING"
	// Las criaturas tienen una relación simbiótica en la que ambas se benefician.
	CreatureCreatureRelationSymbiotic CreatureCreatureRelation = "SYMBIOTIC"
	// Las criaturas tienen una relación de mutualismo, sin dependencia extrema.
	CreatureCreatureRelationMutualistic CreatureCreatureRelation = "MUTUALISTIC"
	// Una criatura protege a la otra de forma voluntaria o instintiva.
	CreatureCreatureRelationProtector CreatureCreatureRelation = "PROTECTOR"
	// Las criaturas compiten por territorio, alimento o dominio.
	CreatureCreatureRelationRival CreatureCreatureRelation = "RIVAL"
	// Las criaturas se consideran enemigas y se atacan mutuamente.
	CreatureCreatureRelationEnemy CreatureCreatureRelation = "ENEMY"
	// Una criatura es depredadora y caza a la otra como parte de su dieta.
	CreatureCreatureRelationPredator CreatureCreatureRelation = "PREDATOR"
	// Una criatura es presa natural de la otra.
	CreatureCreatureRelationPrey CreatureCreatureRelation = "PREY"
	// Una criatura fue creada artificialmente a partir de la otra (clonación, magia, experimentos).
	CreatureCreatureRelationCreatedFrom CreatureCreatureRelation = "CREATED_FROM"
	// Las criaturas están conectadas por una maldición, pacto o lazo sobrenatural.
	CreatureCreatureRelationCursed CreatureCreatureRelation = "CURSED"
)

var AllCreatureCreatureRelation = []CreatureCreatureRelation{
	CreatureCreatureRelationLeader,
	CreatureCreatureRelationPackMember,
	CreatureCreatureRelationParent,
	CreatureCreatureRelationSibling,
	CreatureCreatureRelationSymbiotic,
	CreatureCreatureRelationMutualistic,
	CreatureCreatureRelationProtector,
	CreatureCreatureRelationRival,
	CreatureCreatureRelationEnemy,
	CreatureCreatureRelationPredator,
	CreatureCreatureRelationPrey,
	CreatureCreatureRelationCreatedFrom,
	CreatureCreatureRelationCursed,
}

func (e CreatureCreatureRelation) IsValid() bool {
	switch e {
	case CreatureCreatureRelationLeader, CreatureCreatureRelationPackMember, CreatureCreatureRelationParent, CreatureCreatureRelationSibling, CreatureCreatureRelationSymbiotic, CreatureCreatureRelationMutualistic, CreatureCreatureRelationProtector, CreatureCreatureRelationRival, CreatureCreatureRelationEnemy, CreatureCreatureRelationPredator, CreatureCreatureRelationPrey, CreatureCreatureRelationCreatedFrom, CreatureCreatureRelationCursed:
		return true
	}
	return false
}

func (e CreatureCreatureRelation) String() string {
	return string(e)
}

func (e *CreatureCreatureRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreatureCreatureRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreatureCreatureRelation", str)
	}
	return nil
}

func (e CreatureCreatureRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre una criatura y un evento.
// Puede representar participación en desastres, batallas, invocaciones y otros sucesos importantes.
type CreatureEventRelation string

const (
	// La criatura inició o causó el evento (ej. plaga, destrucción, guerra).
	CreatureEventRelationInitiator CreatureEventRelation = "INITIATOR"
	// La criatura participó en el evento, pero no fue la causa principal.
	CreatureEventRelationParticipant CreatureEventRelation = "PARTICIPANT"
	// La criatura fue invocada o traída al evento de forma mágica o tecnológica.
	CreatureEventRelationSummoned CreatureEventRelation = "SUMMONED"
	// La criatura fue testigo del evento sin intervenir directamente.
	CreatureEventRelationWitness CreatureEventRelation = "WITNESS"
	// El evento afectó a la criatura, alterando su estado o comportamiento.
	CreatureEventRelationAffected CreatureEventRelation = "AFFECTED"
	// La criatura intentó detener el evento o proteger a otros de sus efectos.
	CreatureEventRelationDefender CreatureEventRelation = "DEFENDER"
	// La criatura fue rescatada durante el evento (ej. incendio, terremoto).
	CreatureEventRelationRescued CreatureEventRelation = "RESCUED"
	// La criatura rescató a otros o ayudó a mitigar los efectos del evento.
	CreatureEventRelationSavior CreatureEventRelation = "SAVIOR"
	// El evento fue interpretado como una profecía relacionada con la criatura.
	CreatureEventRelationOmen CreatureEventRelation = "OMEN"
	// El evento se originó como una maldición o consecuencia de la criatura.
	CreatureEventRelationCursed CreatureEventRelation = "CURSED"
)

var AllCreatureEventRelation = []CreatureEventRelation{
	CreatureEventRelationInitiator,
	CreatureEventRelationParticipant,
	CreatureEventRelationSummoned,
	CreatureEventRelationWitness,
	CreatureEventRelationAffected,
	CreatureEventRelationDefender,
	CreatureEventRelationRescued,
	CreatureEventRelationSavior,
	CreatureEventRelationOmen,
	CreatureEventRelationCursed,
}

func (e CreatureEventRelation) IsValid() bool {
	switch e {
	case CreatureEventRelationInitiator, CreatureEventRelationParticipant, CreatureEventRelationSummoned, CreatureEventRelationWitness, CreatureEventRelationAffected, CreatureEventRelationDefender, CreatureEventRelationRescued, CreatureEventRelationSavior, CreatureEventRelationOmen, CreatureEventRelationCursed:
		return true
	}
	return false
}

func (e CreatureEventRelation) String() string {
	return string(e)
}

func (e *CreatureEventRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreatureEventRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreatureEventRelation", str)
	}
	return nil
}

func (e CreatureEventRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre una criatura y una facción.
// Puede representar uso militar, veneración, domesticación o conflicto.
type CreatureFactionRelation string

const (
	// La criatura pertenece a la facción como una mascota, montura o bestia domesticada.
	CreatureFactionRelationAsset CreatureFactionRelation = "ASSET"
	// La criatura es utilizada como arma de guerra o para defensa militar.
	CreatureFactionRelationWarBeast CreatureFactionRelation = "WAR_BEAST"
	// La criatura es venerada como un símbolo sagrado o deidad.
	CreatureFactionRelationWorshipped CreatureFactionRelation = "WORSHIPPED"
	// La criatura fue capturada y está bajo el control de la facción.
	CreatureFactionRelationCaptured CreatureFactionRelation = "CAPTURED"
	// La criatura es considerada una amenaza y la facción busca eliminarla.
	CreatureFactionRelationHunted CreatureFactionRelation = "HUNTED"
	// La criatura ha sido una enemiga recurrente de la facción.
	CreatureFactionRelationEnemy CreatureFactionRelation = "ENEMY"
	// La criatura es vista como un símbolo de mala fortuna o castigo divino.
	CreatureFactionRelationOmen CreatureFactionRelation = "OMEN"
	// La criatura actúa como aliada de la facción sin estar controlada.
	CreatureFactionRelationAlly CreatureFactionRelation = "ALLY"
	// La criatura es utilizada como un experimento dentro de la facción.
	CreatureFactionRelationExperiment CreatureFactionRelation = "EXPERIMENT"
)

var AllCreatureFactionRelation = []CreatureFactionRelation{
	CreatureFactionRelationAsset,
	CreatureFactionRelationWarBeast,
	CreatureFactionRelationWorshipped,
	CreatureFactionRelationCaptured,
	CreatureFactionRelationHunted,
	CreatureFactionRelationEnemy,
	CreatureFactionRelationOmen,
	CreatureFactionRelationAlly,
	CreatureFactionRelationExperiment,
}

func (e CreatureFactionRelation) IsValid() bool {
	switch e {
	case CreatureFactionRelationAsset, CreatureFactionRelationWarBeast, CreatureFactionRelationWorshipped, CreatureFactionRelationCaptured, CreatureFactionRelationHunted, CreatureFactionRelationEnemy, CreatureFactionRelationOmen, CreatureFactionRelationAlly, CreatureFactionRelationExperiment:
		return true
	}
	return false
}

func (e CreatureFactionRelation) String() string {
	return string(e)
}

func (e *CreatureFactionRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreatureFactionRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreatureFactionRelation", str)
	}
	return nil
}

func (e CreatureFactionRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre una criatura y una ubicación.
// Puede representar su hábitat, migraciones, dominio territorial y más.
type CreatureLocationRelation string

const (
	// La criatura tiene su hábitat natural en esta ubicación.
	CreatureLocationRelationNative CreatureLocationRelation = "NATIVE"
	// La criatura reside en esta ubicación, pero no es su hábitat original.
	CreatureLocationRelationResident CreatureLocationRelation = "RESIDENT"
	// La criatura migró a esta ubicación desde otro lugar.
	CreatureLocationRelationMigrated CreatureLocationRelation = "MIGRATED"
	// La criatura reclama esta ubicación como su dominio y la protege.
	CreatureLocationRelationTerritorial CreatureLocationRelation = "TERRITORIAL"
	// La criatura está atrapada en esta ubicación contra su voluntad.
	CreatureLocationRelationTrapped CreatureLocationRelation = "TRAPPED"
	// La criatura fue exiliada de esta ubicación y no puede regresar.
	CreatureLocationRelationExiled CreatureLocationRelation = "EXILED"
	// La criatura es una amenaza para la ubicación y causa destrucción.
	CreatureLocationRelationThreat CreatureLocationRelation = "THREAT"
	// La criatura protege la ubicación o mantiene su equilibrio ecológico.
	CreatureLocationRelationGuardian CreatureLocationRelation = "GUARDIAN"
	// La criatura es un símbolo de la ubicación, ya sea mitológico o cultural.
	CreatureLocationRelationSymbol CreatureLocationRelation = "SYMBOL"
)

var AllCreatureLocationRelation = []CreatureLocationRelation{
	CreatureLocationRelationNative,
	CreatureLocationRelationResident,
	CreatureLocationRelationMigrated,
	CreatureLocationRelationTerritorial,
	CreatureLocationRelationTrapped,
	CreatureLocationRelationExiled,
	CreatureLocationRelationThreat,
	CreatureLocationRelationGuardian,
	CreatureLocationRelationSymbol,
}

func (e CreatureLocationRelation) IsValid() bool {
	switch e {
	case CreatureLocationRelationNative, CreatureLocationRelationResident, CreatureLocationRelationMigrated, CreatureLocationRelationTerritorial, CreatureLocationRelationTrapped, CreatureLocationRelationExiled, CreatureLocationRelationThreat, CreatureLocationRelationGuardian, CreatureLocationRelationSymbol:
		return true
	}
	return false
}

func (e CreatureLocationRelation) String() string {
	return string(e)
}

func (e *CreatureLocationRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreatureLocationRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreatureLocationRelation", str)
	}
	return nil
}

func (e CreatureLocationRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre una criatura y un mundo.
// Puede representar origen, influencia interdimensional, exilio y más.
type CreatureWorldRelation string

const (
	// La criatura es nativa de este mundo.
	CreatureWorldRelationNative CreatureWorldRelation = "NATIVE"
	// La criatura no pertenece a este mundo y proviene de otro plano o dimensión.
	CreatureWorldRelationOutsider CreatureWorldRelation = "OUTSIDER"
	// La criatura es el resultado de una mutación o adaptación a este mundo.
	CreatureWorldRelationAdapted CreatureWorldRelation = "ADAPTED"
	// La criatura tiene un impacto significativo en la ecología o historia del mundo.
	CreatureWorldRelationInfluencer CreatureWorldRelation = "INFLUENCER"
	// La criatura fue convocada a este mundo a través de medios sobrenaturales.
	CreatureWorldRelationSummoned CreatureWorldRelation = "SUMMONED"
	// La criatura protege el mundo o mantiene su equilibrio.
	CreatureWorldRelationGuardian CreatureWorldRelation = "GUARDIAN"
	// La criatura amenaza la existencia del mundo.
	CreatureWorldRelationDestroyer CreatureWorldRelation = "DESTROYER"
	// La criatura fue exiliada del mundo y no puede regresar.
	CreatureWorldRelationExiled CreatureWorldRelation = "EXILED"
)

var AllCreatureWorldRelation = []CreatureWorldRelation{
	CreatureWorldRelationNative,
	CreatureWorldRelationOutsider,
	CreatureWorldRelationAdapted,
	CreatureWorldRelationInfluencer,
	CreatureWorldRelationSummoned,
	CreatureWorldRelationGuardian,
	CreatureWorldRelationDestroyer,
	CreatureWorldRelationExiled,
}

func (e CreatureWorldRelation) IsValid() bool {
	switch e {
	case CreatureWorldRelationNative, CreatureWorldRelationOutsider, CreatureWorldRelationAdapted, CreatureWorldRelationInfluencer, CreatureWorldRelationSummoned, CreatureWorldRelationGuardian, CreatureWorldRelationDestroyer, CreatureWorldRelationExiled:
		return true
	}
	return false
}

func (e CreatureWorldRelation) String() string {
	return string(e)
}

func (e *CreatureWorldRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CreatureWorldRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CreatureWorldRelation", str)
	}
	return nil
}

func (e CreatureWorldRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre dos eventos.
// Puede representar causalidad, continuidad, interdependencia o influencia entre eventos.
type EventEvent string

const (
	// El evento A causó directamente el evento B.
	EventEventCause EventEvent = "CAUSE"
	// El evento B ocurrió como consecuencia del evento A.
	EventEventConsequence EventEvent = "CONSEQUENCE"
	// El evento B es una reacción directa al evento A (ej. represalia, respuesta diplomática).
	EventEventResponse EventEvent = "RESPONSE"
	// El evento B es una continuación lógica del evento A.
	EventEventContinuation EventEvent = "CONTINUATION"
	// El evento B es una repetición o iteración del evento A.
	EventEventReoccurrence EventEvent = "REOCCURRENCE"
	// El evento B se produce en paralelo con el evento A, sin que uno cause al otro.
	EventEventParallel EventEvent = "PARALLEL"
	// El evento A inspiró o motivó el evento B sin ser su causa directa.
	EventEventInspiration EventEvent = "INSPIRATION"
	// El evento A y el evento B están profetizados como parte de un mismo ciclo.
	EventEventProphecyLink EventEvent = "PROPHECY_LINK"
	// Ambos eventos están mágicamente o sobrenaturalmente conectados.
	EventEventSupernaturalLink EventEvent = "SUPERNATURAL_LINK"
)

var AllEventEvent = []EventEvent{
	EventEventCause,
	EventEventConsequence,
	EventEventResponse,
	EventEventContinuation,
	EventEventReoccurrence,
	EventEventParallel,
	EventEventInspiration,
	EventEventProphecyLink,
	EventEventSupernaturalLink,
}

func (e EventEvent) IsValid() bool {
	switch e {
	case EventEventCause, EventEventConsequence, EventEventResponse, EventEventContinuation, EventEventReoccurrence, EventEventParallel, EventEventInspiration, EventEventProphecyLink, EventEventSupernaturalLink:
		return true
	}
	return false
}

func (e EventEvent) String() string {
	return string(e)
}

func (e *EventEvent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventEvent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventEvent", str)
	}
	return nil
}

func (e EventEvent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indica la naturaleza del evento, diferenciando entre encuentros planificados, espontáneos o accidentales.
type EventNature string

const (
	// El evento fue planeado con anticipación (ceremonias, batallas estratégicas, reuniones).
	EventNaturePlanned EventNature = "PLANNED"
	// El evento ocurrió debido a una cita o reunión acordada entre personajes o facciones.
	EventNatureAppointment EventNature = "APPOINTMENT"
	// El evento fue provocado intencionalmente por una de las partes (ataques, conspiraciones, emboscadas).
	EventNatureIntentional EventNature = "INTENTIONAL"
	// El evento ocurrió sin planificación previa, como encuentros fortuitos o descubrimientos inesperados.
	EventNatureSpontaneous EventNature = "SPONTANEOUS"
	// El evento fue un accidente sin intención detrás (explosión accidental, tropiezo, equivocación).
	EventNatureAccidental EventNature = "ACCIDENTAL"
	// El evento ocurrió por coincidencia, sin intervención intencional de los involucrados.
	EventNatureCoincidence EventNature = "COINCIDENCE"
	// El evento era inevitable por razones naturales, sobrenaturales o predestinadas (profecía cumplida, fin del mundo).
	EventNatureInevitable EventNature = "INEVITABLE"
	// El evento ocurrió debido a fuerzas externas sin que los personajes tuvieran control sobre él (terremoto, tormenta, invasión repentina).
	EventNatureForced EventNature = "FORCED"
)

var AllEventNature = []EventNature{
	EventNaturePlanned,
	EventNatureAppointment,
	EventNatureIntentional,
	EventNatureSpontaneous,
	EventNatureAccidental,
	EventNatureCoincidence,
	EventNatureInevitable,
	EventNatureForced,
}

func (e EventNature) IsValid() bool {
	switch e {
	case EventNaturePlanned, EventNatureAppointment, EventNatureIntentional, EventNatureSpontaneous, EventNatureAccidental, EventNatureCoincidence, EventNatureInevitable, EventNatureForced:
		return true
	}
	return false
}

func (e EventNature) String() string {
	return string(e)
}

func (e *EventNature) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventNature(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventNature", str)
	}
	return nil
}

func (e EventNature) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indica la importancia de un evento dentro de la historia.
// Puede determinar su impacto en la narrativa del mundo.
type EventSignificance string

const (
	// Un evento menor con impacto limitado en la historia general.
	EventSignificanceLow EventSignificance = "LOW"
	// Un evento de relevancia media que afecta a una región o a un grupo importante de personajes.
	EventSignificanceMedium EventSignificance = "MEDIUM"
	// Un evento crucial que cambia la historia del mundo de forma permanente.
	EventSignificanceHigh EventSignificance = "HIGH"
)

var AllEventSignificance = []EventSignificance{
	EventSignificanceLow,
	EventSignificanceMedium,
	EventSignificanceHigh,
}

func (e EventSignificance) IsValid() bool {
	switch e {
	case EventSignificanceLow, EventSignificanceMedium, EventSignificanceHigh:
		return true
	}
	return false
}

func (e EventSignificance) String() string {
	return string(e)
}

func (e *EventSignificance) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventSignificance(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventSignificance", str)
	}
	return nil
}

func (e EventSignificance) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Clasifica los eventos según su naturaleza.
// Puede representar batallas, descubrimientos, rituales, catástrofes y otros sucesos.
type EventType string

const (
	// Un evento donde se produce un conflicto armado entre facciones o naciones.
	EventTypeBattle EventType = "BATTLE"
	// Un tratado, negociación o evento diplomático entre entidades.
	EventTypeDiplomaticEvent EventType = "DIPLOMATIC_EVENT"
	// Un golpe de estado, revolución o cambio radical de poder.
	EventTypePoliticalUpheaval EventType = "POLITICAL_UPHEAVAL"
	// Un evento donde se descubre un nuevo territorio o lugar significativo.
	EventTypeDiscovery EventType = "DISCOVERY"
	// Un evento donde se revela información crucial para la historia.
	EventTypeRevelation EventType = "REVELATION"
	// Un ritual realizado con propósitos religiosos, mágicos o esotéricos.
	EventTypeRitual EventType = "RITUAL"
	// Una profecía que influye en la historia del mundo.
	EventTypeProphecy EventType = "PROPHECY"
	// Un evento donde una entidad divina interviene en el mundo.
	EventTypeDivineIntervention EventType = "DIVINE_INTERVENTION"
	// Un desastre natural (terremoto, erupción volcánica, tsunami, etc.).
	EventTypeNaturalDisaster EventType = "NATURAL_DISASTER"
	// Una pandemia o plaga que afecta a una región o población.
	EventTypePlague EventType = "PLAGUE"
	// Un evento en el que se produce un incendio de gran magnitud.
	EventTypeFire EventType = "FIRE"
	// Un evento en el que se genera caos y destrucción por causas no naturales.
	EventTypeCalamity EventType = "CALAMITY"
	// Un evento festivo, celebración o competencia deportiva.
	EventTypeFestival EventType = "FESTIVAL"
	// Un evento académico, científico o reunión intelectual relevante.
	EventTypeScholarlyEvent EventType = "SCHOLARLY_EVENT"
	// Un juicio o evento de condena pública.
	EventTypeTrial EventType = "TRIAL"
	// Un evento paranormal o que desafía la lógica del mundo.
	EventTypeSupernaturalEvent EventType = "SUPERNATURAL_EVENT"
	// Un evento donde se abre un portal a otra dimensión o plano.
	EventTypeInterdimensionalRift EventType = "INTERDIMENSIONAL_RIFT"
)

var AllEventType = []EventType{
	EventTypeBattle,
	EventTypeDiplomaticEvent,
	EventTypePoliticalUpheaval,
	EventTypeDiscovery,
	EventTypeRevelation,
	EventTypeRitual,
	EventTypeProphecy,
	EventTypeDivineIntervention,
	EventTypeNaturalDisaster,
	EventTypePlague,
	EventTypeFire,
	EventTypeCalamity,
	EventTypeFestival,
	EventTypeScholarlyEvent,
	EventTypeTrial,
	EventTypeSupernaturalEvent,
	EventTypeInterdimensionalRift,
}

func (e EventType) IsValid() bool {
	switch e {
	case EventTypeBattle, EventTypeDiplomaticEvent, EventTypePoliticalUpheaval, EventTypeDiscovery, EventTypeRevelation, EventTypeRitual, EventTypeProphecy, EventTypeDivineIntervention, EventTypeNaturalDisaster, EventTypePlague, EventTypeFire, EventTypeCalamity, EventTypeFestival, EventTypeScholarlyEvent, EventTypeTrial, EventTypeSupernaturalEvent, EventTypeInterdimensionalRift:
		return true
	}
	return false
}

func (e EventType) String() string {
	return string(e)
}

func (e *EventType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventType", str)
	}
	return nil
}

func (e EventType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre una facción y un evento.
// Puede representar participación en batallas, diplomacia, rebeliones y más.
type FactionEventRelation string

const (
	// La facción inició o provocó el evento.
	FactionEventRelationInitiator FactionEventRelation = "INITIATOR"
	// La facción participó activamente en el evento.
	FactionEventRelationParticipant FactionEventRelation = "PARTICIPANT"
	// La facción organizó el evento, pero no participó directamente.
	FactionEventRelationOrganizer FactionEventRelation = "ORGANIZER"
	// La facción intentó evitar o detener el evento.
	FactionEventRelationOpposer FactionEventRelation = "OPPOSER"
	// La facción sufrió las consecuencias del evento.
	FactionEventRelationAffected FactionEventRelation = "AFFECTED"
	// La facción usó el evento como una oportunidad política o económica.
	FactionEventRelationOpportunist FactionEventRelation = "OPPORTUNIST"
	// El evento llevó a la facción a hacer un tratado de paz o alianza.
	FactionEventRelationDiplomaticShift FactionEventRelation = "DIPLOMATIC_SHIFT"
	// El evento causó la disolución de la facción.
	FactionEventRelationDissolution FactionEventRelation = "DISSOLUTION"
)

var AllFactionEventRelation = []FactionEventRelation{
	FactionEventRelationInitiator,
	FactionEventRelationParticipant,
	FactionEventRelationOrganizer,
	FactionEventRelationOpposer,
	FactionEventRelationAffected,
	FactionEventRelationOpportunist,
	FactionEventRelationDiplomaticShift,
	FactionEventRelationDissolution,
}

func (e FactionEventRelation) IsValid() bool {
	switch e {
	case FactionEventRelationInitiator, FactionEventRelationParticipant, FactionEventRelationOrganizer, FactionEventRelationOpposer, FactionEventRelationAffected, FactionEventRelationOpportunist, FactionEventRelationDiplomaticShift, FactionEventRelationDissolution:
		return true
	}
	return false
}

func (e FactionEventRelation) String() string {
	return string(e)
}

func (e *FactionEventRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FactionEventRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FactionEventRelation", str)
	}
	return nil
}

func (e FactionEventRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre dos facciones.
// Puede representar alianzas, enemistades, subordinación y competencia.
type FactionFactionRelation string

const (
	// Las facciones están aliadas y colaboran activamente.
	FactionFactionRelationAllied FactionFactionRelation = "ALLIED"
	// Una facción está subordinada a otra.
	FactionFactionRelationVassal FactionFactionRelation = "VASSAL"
	// Ambas facciones tienen un pacto de no agresión o comercio.
	FactionFactionRelationNeutralPact FactionFactionRelation = "NEUTRAL_PACT"
	// Las facciones son enemigas y están en guerra o conflicto activo.
	FactionFactionRelationEnemy FactionFactionRelation = "ENEMY"
	// Una facción busca la destrucción o disolución de la otra.
	FactionFactionRelationRivalry FactionFactionRelation = "RIVALRY"
	// Las facciones tienen desacuerdos políticos, económicos o ideológicos.
	FactionFactionRelationTension FactionFactionRelation = "TENSION"
	// Una facción ha sido absorbida por otra y ya no existe como entidad independiente.
	FactionFactionRelationAbsorbed FactionFactionRelation = "ABSORBED"
	// Las facciones están en tregua temporal tras un conflicto.
	FactionFactionRelationTruce FactionFactionRelation = "TRUCE"
)

var AllFactionFactionRelation = []FactionFactionRelation{
	FactionFactionRelationAllied,
	FactionFactionRelationVassal,
	FactionFactionRelationNeutralPact,
	FactionFactionRelationEnemy,
	FactionFactionRelationRivalry,
	FactionFactionRelationTension,
	FactionFactionRelationAbsorbed,
	FactionFactionRelationTruce,
}

func (e FactionFactionRelation) IsValid() bool {
	switch e {
	case FactionFactionRelationAllied, FactionFactionRelationVassal, FactionFactionRelationNeutralPact, FactionFactionRelationEnemy, FactionFactionRelationRivalry, FactionFactionRelationTension, FactionFactionRelationAbsorbed, FactionFactionRelationTruce:
		return true
	}
	return false
}

func (e FactionFactionRelation) String() string {
	return string(e)
}

func (e *FactionFactionRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FactionFactionRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FactionFactionRelation", str)
	}
	return nil
}

func (e FactionFactionRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indica el nivel de influencia de la facción en el mundo o sociedad.
// Determina su relevancia histórica y social.
type FactionInfluence string

const (
	// Facción menor con presencia local o influencia limitada.
	FactionInfluenceMinor FactionInfluence = "MINOR"
	// Facción con una influencia considerable en una región o sector de la sociedad.
	FactionInfluenceRegional FactionInfluence = "REGIONAL"
	// Facción con impacto significativo en múltiples regiones o áreas de poder.
	FactionInfluenceMajor FactionInfluence = "MAJOR"
	// Facción de importancia global o interdimensional.
	FactionInfluenceWorldwide FactionInfluence = "WORLDWIDE"
)

var AllFactionInfluence = []FactionInfluence{
	FactionInfluenceMinor,
	FactionInfluenceRegional,
	FactionInfluenceMajor,
	FactionInfluenceWorldwide,
}

func (e FactionInfluence) IsValid() bool {
	switch e {
	case FactionInfluenceMinor, FactionInfluenceRegional, FactionInfluenceMajor, FactionInfluenceWorldwide:
		return true
	}
	return false
}

func (e FactionInfluence) String() string {
	return string(e)
}

func (e *FactionInfluence) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FactionInfluence(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FactionInfluence", str)
	}
	return nil
}

func (e FactionInfluence) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre una facción y un ítem.
// Puede representar reliquias, símbolos de poder, armamento y más.
type FactionItemRelation string

const (
	// El ítem es un símbolo de poder o autoridad de la facción.
	FactionItemRelationSymbol FactionItemRelation = "SYMBOL"
	// El ítem es una reliquia sagrada o de gran valor para la facción.
	FactionItemRelationRelic FactionItemRelation = "RELIC"
	// El ítem es parte del armamento de la facción.
	FactionItemRelationWeapon FactionItemRelation = "WEAPON"
	// El ítem es un documento, tratado o código legal de la facción.
	FactionItemRelationDocument FactionItemRelation = "DOCUMENT"
	// El ítem está vinculado a la historia de la facción.
	FactionItemRelationHistorical FactionItemRelation = "HISTORICAL"
	// El ítem tiene un valor cultural o religioso para la facción.
	FactionItemRelationCultural FactionItemRelation = "CULTURAL"
)

var AllFactionItemRelation = []FactionItemRelation{
	FactionItemRelationSymbol,
	FactionItemRelationRelic,
	FactionItemRelationWeapon,
	FactionItemRelationDocument,
	FactionItemRelationHistorical,
	FactionItemRelationCultural,
}

func (e FactionItemRelation) IsValid() bool {
	switch e {
	case FactionItemRelationSymbol, FactionItemRelationRelic, FactionItemRelationWeapon, FactionItemRelationDocument, FactionItemRelationHistorical, FactionItemRelationCultural:
		return true
	}
	return false
}

func (e FactionItemRelation) String() string {
	return string(e)
}

func (e *FactionItemRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FactionItemRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FactionItemRelation", str)
	}
	return nil
}

func (e FactionItemRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre una facción y una ubicación.
// Puede representar dominio, influencia, exilio y más.
type FactionLocationRelation string

const (
	// La facción controla la ubicación como su territorio principal.
	FactionLocationRelationCapital FactionLocationRelation = "CAPITAL"
	// La facción posee la ubicación como parte de su territorio.
	FactionLocationRelationOwned FactionLocationRelation = "OWNED"
	// La facción ejerce influencia política, económica o militar en la ubicación.
	FactionLocationRelationInfluence FactionLocationRelation = "INFLUENCE"
	// La facción perdió la ubicación tras un conflicto o caída de poder.
	FactionLocationRelationLostTerritory FactionLocationRelation = "LOST_TERRITORY"
	// La facción fue exiliada de esta ubicación y no puede regresar.
	FactionLocationRelationExiled FactionLocationRelation = "EXILED"
	// La facción intenta conquistar la ubicación.
	FactionLocationRelationConquering FactionLocationRelation = "CONQUERING"
	// La facción ha ocupado temporalmente la ubicación mediante fuerza militar o diplomacia.
	FactionLocationRelationOccupied FactionLocationRelation = "OCCUPIED"
	// La facción tiene presencia en la ubicación, pero no la controla.
	FactionLocationRelationOutpost FactionLocationRelation = "OUTPOST"
	// La facción considera la ubicación sagrada o importante por razones religiosas o culturales.
	FactionLocationRelationSacredSite FactionLocationRelation = "SACRED_SITE"
)

var AllFactionLocationRelation = []FactionLocationRelation{
	FactionLocationRelationCapital,
	FactionLocationRelationOwned,
	FactionLocationRelationInfluence,
	FactionLocationRelationLostTerritory,
	FactionLocationRelationExiled,
	FactionLocationRelationConquering,
	FactionLocationRelationOccupied,
	FactionLocationRelationOutpost,
	FactionLocationRelationSacredSite,
}

func (e FactionLocationRelation) IsValid() bool {
	switch e {
	case FactionLocationRelationCapital, FactionLocationRelationOwned, FactionLocationRelationInfluence, FactionLocationRelationLostTerritory, FactionLocationRelationExiled, FactionLocationRelationConquering, FactionLocationRelationOccupied, FactionLocationRelationOutpost, FactionLocationRelationSacredSite:
		return true
	}
	return false
}

func (e FactionLocationRelation) String() string {
	return string(e)
}

func (e *FactionLocationRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FactionLocationRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FactionLocationRelation", str)
	}
	return nil
}

func (e FactionLocationRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indica el estado actual de la facción en la historia.
// Puede estar activa, disuelta, exiliada, entre otros.
type FactionStatus string

const (
	// La facción sigue operativa y tiene actividad en el mundo.
	FactionStatusActive FactionStatus = "ACTIVE"
	// La facción se ha disuelto y ya no existe como organización.
	FactionStatusDisbanded FactionStatus = "DISBANDED"
	// La facción fue exiliada y ya no tiene territorio propio.
	FactionStatusExiled FactionStatus = "EXILED"
	// La facción opera en secreto y no es reconocida públicamente.
	FactionStatusUnderground FactionStatus = "UNDERGROUND"
	// La facción está en decadencia y perdiendo influencia.
	FactionStatusDeclining FactionStatus = "DECLINING"
	// La facción está en auge y expandiendo su poder.
	FactionStatusAscending FactionStatus = "ASCENDING"
)

var AllFactionStatus = []FactionStatus{
	FactionStatusActive,
	FactionStatusDisbanded,
	FactionStatusExiled,
	FactionStatusUnderground,
	FactionStatusDeclining,
	FactionStatusAscending,
}

func (e FactionStatus) IsValid() bool {
	switch e {
	case FactionStatusActive, FactionStatusDisbanded, FactionStatusExiled, FactionStatusUnderground, FactionStatusDeclining, FactionStatusAscending:
		return true
	}
	return false
}

func (e FactionStatus) String() string {
	return string(e)
}

func (e *FactionStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FactionStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FactionStatus", str)
	}
	return nil
}

func (e FactionStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Clasifica las facciones según su estructura y propósito.
// Incluye gobiernos, cultos, gremios, clanes, ejércitos y más.
type FactionType string

const (
	// Una nación o reino gobernado por una autoridad central.
	FactionTypeNation FactionType = "NATION"
	// Un estado independiente o ciudad-estado con gobierno propio.
	FactionTypeCityState FactionType = "CITY_STATE"
	// Un imperio con dominio sobre múltiples territorios.
	FactionTypeEmpire FactionType = "EMPIRE"
	// Un grupo de resistencia o revolución contra el poder establecido.
	FactionTypeRebellion FactionType = "REBELLION"
	// Una organización religiosa con dogmas y seguidores.
	FactionTypeReligiousOrder FactionType = "RELIGIOUS_ORDER"
	// Un culto dedicado a una deidad, entidad o creencia específica.
	FactionTypeCult FactionType = "CULT"
	// Una hermandad secreta o sociedad con propósitos ocultos.
	FactionTypeSecretSociety FactionType = "SECRET_SOCIETY"
	// Un ejército formal al servicio de un estado o gobernante.
	FactionTypeMilitary FactionType = "MILITARY"
	// Un grupo de mercenarios que ofrece servicios de combate o protección.
	FactionTypeMercenaryCompany FactionType = "MERCENARY_COMPANY"
	// Una banda de saqueadores, piratas o criminales organizados.
	FactionTypeRaiders FactionType = "RAIDERS"
	// Un gremio de artesanos, comerciantes o profesionales.
	FactionTypeGuild FactionType = "GUILD"
	// Una megacorporación o grupo empresarial con gran influencia económica.
	FactionTypeMegacorporation FactionType = "MEGACORPORATION"
	// Una tribu con una cultura propia y gobierno descentralizado.
	FactionTypeTribe FactionType = "TRIBE"
	// Un clan familiar con influencia en una región o esfera de poder.
	FactionTypeClan FactionType = "CLAN"
)

var AllFactionType = []FactionType{
	FactionTypeNation,
	FactionTypeCityState,
	FactionTypeEmpire,
	FactionTypeRebellion,
	FactionTypeReligiousOrder,
	FactionTypeCult,
	FactionTypeSecretSociety,
	FactionTypeMilitary,
	FactionTypeMercenaryCompany,
	FactionTypeRaiders,
	FactionTypeGuild,
	FactionTypeMegacorporation,
	FactionTypeTribe,
	FactionTypeClan,
}

func (e FactionType) IsValid() bool {
	switch e {
	case FactionTypeNation, FactionTypeCityState, FactionTypeEmpire, FactionTypeRebellion, FactionTypeReligiousOrder, FactionTypeCult, FactionTypeSecretSociety, FactionTypeMilitary, FactionTypeMercenaryCompany, FactionTypeRaiders, FactionTypeGuild, FactionTypeMegacorporation, FactionTypeTribe, FactionTypeClan:
		return true
	}
	return false
}

func (e FactionType) String() string {
	return string(e)
}

func (e *FactionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FactionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FactionType", str)
	}
	return nil
}

func (e FactionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre una facción y un mundo.
// Puede representar su origen, dominio, influencia interdimensional y más.
type FactionWorldRelation string

const (
	// La facción fue fundada en este mundo y es nativa de él.
	FactionWorldRelationNative FactionWorldRelation = "NATIVE"
	// La facción se expandió a este mundo desde otro plano de existencia.
	FactionWorldRelationExpanded FactionWorldRelation = "EXPANDED"
	// La facción gobierna o tiene control absoluto sobre este mundo.
	FactionWorldRelationRuler FactionWorldRelation = "RULER"
	// La facción ha sido exiliada de este mundo y no puede regresar.
	FactionWorldRelationExiled FactionWorldRelation = "EXILED"
	// La facción tiene influencia política, económica o militar en este mundo.
	FactionWorldRelationInfluence FactionWorldRelation = "INFLUENCE"
	// La facción opera en este mundo, pero sin un territorio propio.
	FactionWorldRelationOperatesHere FactionWorldRelation = "OPERATES_HERE"
	// La facción ha sido eliminada de este mundo y ya no existe en él.
	FactionWorldRelationEradicated FactionWorldRelation = "ERADICATED"
	// La facción usa este mundo como punto de acceso para otros planos o dimensiones.
	FactionWorldRelationInterplanarBase FactionWorldRelation = "INTERPLANAR_BASE"
	// La facción es una anomalía en este mundo y no pertenece a su realidad.
	FactionWorldRelationAnomaly FactionWorldRelation = "ANOMALY"
)

var AllFactionWorldRelation = []FactionWorldRelation{
	FactionWorldRelationNative,
	FactionWorldRelationExpanded,
	FactionWorldRelationRuler,
	FactionWorldRelationExiled,
	FactionWorldRelationInfluence,
	FactionWorldRelationOperatesHere,
	FactionWorldRelationEradicated,
	FactionWorldRelationInterplanarBase,
	FactionWorldRelationAnomaly,
}

func (e FactionWorldRelation) IsValid() bool {
	switch e {
	case FactionWorldRelationNative, FactionWorldRelationExpanded, FactionWorldRelationRuler, FactionWorldRelationExiled, FactionWorldRelationInfluence, FactionWorldRelationOperatesHere, FactionWorldRelationEradicated, FactionWorldRelationInterplanarBase, FactionWorldRelationAnomaly:
		return true
	}
	return false
}

func (e FactionWorldRelation) String() string {
	return string(e)
}

func (e *FactionWorldRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FactionWorldRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FactionWorldRelation", str)
	}
	return nil
}

func (e FactionWorldRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Representa relaciones familiares entre personajes, incluyendo parentescos directos e indirectos.
// Distingue entre lazos de sangre, adopción y vínculos familiares extendidos.
type FamilyRelation string

const (
	// Padre o madre biológico/a del personaje.
	FamilyRelationParent FamilyRelation = "PARENT"
	// Hijo o hija biológico/a del personaje.
	FamilyRelationChild FamilyRelation = "CHILD"
	// Hermano o hermana del personaje, comparten al menos uno de los padres.
	FamilyRelationSibling FamilyRelation = "SIBLING"
	// Abuelo o abuela del personaje, ascendencia dos generaciones atrás.
	FamilyRelationGrandparent FamilyRelation = "GRANDPARENT"
	// Nieto o nieta del personaje, descendencia dos generaciones adelante.
	FamilyRelationGrandchild FamilyRelation = "GRANDCHILD"
	// Tío o tía del personaje, hermano/a del padre o la madre.
	FamilyRelationUncleAunt FamilyRelation = "UNCLE_AUNT"
	// Sobrino o sobrina del personaje, hijo/a de un hermano o hermana.
	FamilyRelationNephewNiece FamilyRelation = "NEPHEW_NIECE"
	// Primo o prima del personaje, hijo/a de los tíos o tías.
	FamilyRelationCousin FamilyRelation = "COUSIN"
	// Esposo o esposa del personaje, relación legalmente reconocida o establecida románticamente.
	FamilyRelationSpouse FamilyRelation = "SPOUSE"
	// Exesposo/a del personaje. Relación con lazos matrimoniales que han sido disueltos.
	FamilyRelationExSpouse FamilyRelation = "EX_SPOUSE"
	// Padrastro o madrastra del personaje. Relación por matrimonio con uno de los padres del personaje.
	FamilyRelationStepParent FamilyRelation = "STEP_PARENT"
	// Hijastro o hijastra del personaje. Hijo/a de su pareja en una relación previa.
	FamilyRelationStepChild FamilyRelation = "STEP_CHILD"
	// Medio hermano/a del personaje. Comparten solo uno de los padres.
	FamilyRelationHalfSibling FamilyRelation = "HALF_SIBLING"
	// Padre o madre adoptivo/a del personaje. Relación establecida legalmente sin lazo de sangre.
	FamilyRelationAdoptiveParent FamilyRelation = "ADOPTIVE_PARENT"
	// Hijo o hija adoptivo/a del personaje. Relación establecida legalmente sin lazo de sangre.
	FamilyRelationAdoptiveChild FamilyRelation = "ADOPTIVE_CHILD"
	// Tutor legal del personaje. Puede ser una figura parental, un mentor o protector.
	FamilyRelationGuardian FamilyRelation = "GUARDIAN"
	// Menor bajo tutela legal de otro personaje. No es necesariamente hijo adoptivo.
	FamilyRelationWard FamilyRelation = "WARD"
)

var AllFamilyRelation = []FamilyRelation{
	FamilyRelationParent,
	FamilyRelationChild,
	FamilyRelationSibling,
	FamilyRelationGrandparent,
	FamilyRelationGrandchild,
	FamilyRelationUncleAunt,
	FamilyRelationNephewNiece,
	FamilyRelationCousin,
	FamilyRelationSpouse,
	FamilyRelationExSpouse,
	FamilyRelationStepParent,
	FamilyRelationStepChild,
	FamilyRelationHalfSibling,
	FamilyRelationAdoptiveParent,
	FamilyRelationAdoptiveChild,
	FamilyRelationGuardian,
	FamilyRelationWard,
}

func (e FamilyRelation) IsValid() bool {
	switch e {
	case FamilyRelationParent, FamilyRelationChild, FamilyRelationSibling, FamilyRelationGrandparent, FamilyRelationGrandchild, FamilyRelationUncleAunt, FamilyRelationNephewNiece, FamilyRelationCousin, FamilyRelationSpouse, FamilyRelationExSpouse, FamilyRelationStepParent, FamilyRelationStepChild, FamilyRelationHalfSibling, FamilyRelationAdoptiveParent, FamilyRelationAdoptiveChild, FamilyRelationGuardian, FamilyRelationWard:
		return true
	}
	return false
}

func (e FamilyRelation) String() string {
	return string(e)
}

func (e *FamilyRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FamilyRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FamilyRelation", str)
	}
	return nil
}

func (e FamilyRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define el estado físico de un ítem, indicando su grado de desgaste o conservación.
type ItemCondition string

const (
	// El ítem está en perfectas condiciones, sin daños ni desgaste.
	ItemConditionPristine ItemCondition = "PRISTINE"
	// El ítem muestra signos de uso, pero aún está en buen estado.
	ItemConditionUsed ItemCondition = "USED"
	// El ítem está dañado o desgastado, pero sigue siendo funcional.
	ItemConditionWorn ItemCondition = "WORN"
	// El ítem está roto o inutilizable en su estado actual.
	ItemConditionBroken ItemCondition = "BROKEN"
	// El ítem ha sido encantado o alterado mágicamente.
	ItemConditionEnchanted ItemCondition = "ENCHANTED"
	// El ítem está corroído o en proceso de deterioro.
	ItemConditionCorroded ItemCondition = "CORRODED"
)

var AllItemCondition = []ItemCondition{
	ItemConditionPristine,
	ItemConditionUsed,
	ItemConditionWorn,
	ItemConditionBroken,
	ItemConditionEnchanted,
	ItemConditionCorroded,
}

func (e ItemCondition) IsValid() bool {
	switch e {
	case ItemConditionPristine, ItemConditionUsed, ItemConditionWorn, ItemConditionBroken, ItemConditionEnchanted, ItemConditionCorroded:
		return true
	}
	return false
}

func (e ItemCondition) String() string {
	return string(e)
}

func (e *ItemCondition) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemCondition(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemCondition", str)
	}
	return nil
}

func (e ItemCondition) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre un ítem y un evento.
// Puede representar su uso, descubrimiento, destrucción y más.
type ItemEventRelation string

const (
	// El ítem fue descubierto o adquirido durante el evento.
	ItemEventRelationDiscovered ItemEventRelation = "DISCOVERED"
	// El ítem fue entregado o transferido a otra entidad en el evento.
	ItemEventRelationTraded ItemEventRelation = "TRADED"
	// El ítem fue robado o perdido durante el evento.
	ItemEventRelationStolen ItemEventRelation = "STOLEN"
	// El ítem fue utilizado activamente en el evento.
	ItemEventRelationUsed ItemEventRelation = "USED"
	// El ítem fue clave para el desarrollo o desenlace del evento.
	ItemEventRelationKeyItem ItemEventRelation = "KEY_ITEM"
	// El ítem fue destruido o inutilizado durante el evento.
	ItemEventRelationDestroyed ItemEventRelation = "DESTROYED"
)

var AllItemEventRelation = []ItemEventRelation{
	ItemEventRelationDiscovered,
	ItemEventRelationTraded,
	ItemEventRelationStolen,
	ItemEventRelationUsed,
	ItemEventRelationKeyItem,
	ItemEventRelationDestroyed,
}

func (e ItemEventRelation) IsValid() bool {
	switch e {
	case ItemEventRelationDiscovered, ItemEventRelationTraded, ItemEventRelationStolen, ItemEventRelationUsed, ItemEventRelationKeyItem, ItemEventRelationDestroyed:
		return true
	}
	return false
}

func (e ItemEventRelation) String() string {
	return string(e)
}

func (e *ItemEventRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemEventRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemEventRelation", str)
	}
	return nil
}

func (e ItemEventRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre dos ítems.
// Puede representar combinaciones, piezas de un set, transformación y otras interacciones.
type ItemItemRelation string

const (
	// Los ítems se pueden combinar para formar un nuevo objeto.
	ItemItemRelationCombinable ItemItemRelation = "COMBINABLE"
	// Uno de los ítems es un componente necesario para otro.
	ItemItemRelationComponent ItemItemRelation = "COMPONENT"
	// Los ítems forman parte de un set o conjunto especial.
	ItemItemRelationSetItem ItemItemRelation = "SET_ITEM"
	// Un ítem puede evolucionar en otro mediante uso o mejora.
	ItemItemRelationEvolution ItemItemRelation = "EVOLUTION"
	// Los ítems son opuestos o tienen efectos que se anulan mutuamente.
	ItemItemRelationOpposite ItemItemRelation = "OPPOSITE"
	// Los ítems tienen una conexión histórica o mitológica.
	ItemItemRelationLinkedHistory ItemItemRelation = "LINKED_HISTORY"
	// Uno de los ítems fue creado a partir del otro.
	ItemItemRelationDerivedFrom ItemItemRelation = "DERIVED_FROM"
)

var AllItemItemRelation = []ItemItemRelation{
	ItemItemRelationCombinable,
	ItemItemRelationComponent,
	ItemItemRelationSetItem,
	ItemItemRelationEvolution,
	ItemItemRelationOpposite,
	ItemItemRelationLinkedHistory,
	ItemItemRelationDerivedFrom,
}

func (e ItemItemRelation) IsValid() bool {
	switch e {
	case ItemItemRelationCombinable, ItemItemRelationComponent, ItemItemRelationSetItem, ItemItemRelationEvolution, ItemItemRelationOpposite, ItemItemRelationLinkedHistory, ItemItemRelationDerivedFrom:
		return true
	}
	return false
}

func (e ItemItemRelation) String() string {
	return string(e)
}

func (e *ItemItemRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemItemRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemItemRelation", str)
	}
	return nil
}

func (e ItemItemRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre un ítem y una ubicación.
// Puede representar su almacenamiento, hallazgo o pérdida.
type ItemLocationRelation string

const (
	// El ítem está guardado o almacenado en la ubicación.
	ItemLocationRelationStored ItemLocationRelation = "STORED"
	// El ítem fue encontrado en la ubicación.
	ItemLocationRelationDiscovered ItemLocationRelation = "DISCOVERED"
	// El ítem está oculto o sellado en la ubicación.
	ItemLocationRelationSealed ItemLocationRelation = "SEALED"
	// El ítem está perdido o abandonado en la ubicación.
	ItemLocationRelationLost ItemLocationRelation = "LOST"
	// El ítem fue forjado, creado o ensamblado en la ubicación.
	ItemLocationRelationCreated ItemLocationRelation = "CREATED"
	// El ítem fue destruido o desmantelado en la ubicación.
	ItemLocationRelationDestroyed ItemLocationRelation = "DESTROYED"
)

var AllItemLocationRelation = []ItemLocationRelation{
	ItemLocationRelationStored,
	ItemLocationRelationDiscovered,
	ItemLocationRelationSealed,
	ItemLocationRelationLost,
	ItemLocationRelationCreated,
	ItemLocationRelationDestroyed,
}

func (e ItemLocationRelation) IsValid() bool {
	switch e {
	case ItemLocationRelationStored, ItemLocationRelationDiscovered, ItemLocationRelationSealed, ItemLocationRelationLost, ItemLocationRelationCreated, ItemLocationRelationDestroyed:
		return true
	}
	return false
}

func (e ItemLocationRelation) String() string {
	return string(e)
}

func (e *ItemLocationRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemLocationRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemLocationRelation", str)
	}
	return nil
}

func (e ItemLocationRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Clasifica los ítems según su rareza dentro del mundo ficticio.
type ItemRarity string

const (
	// Ítems comunes y de fácil acceso en el mundo.
	ItemRarityCommon ItemRarity = "COMMON"
	// Ítems poco comunes, difíciles de encontrar pero no únicos.
	ItemRarityUncommon ItemRarity = "UNCOMMON"
	// Ítems raros, con habilidades especiales o historias únicas.
	ItemRarityRare ItemRarity = "RARE"
	// Ítems extremadamente raros, con gran poder o significado.
	ItemRarityLegendary ItemRarity = "LEGENDARY"
	// Ítems únicos, con una sola existencia en el mundo.
	ItemRarityUnique ItemRarity = "UNIQUE"
)

var AllItemRarity = []ItemRarity{
	ItemRarityCommon,
	ItemRarityUncommon,
	ItemRarityRare,
	ItemRarityLegendary,
	ItemRarityUnique,
}

func (e ItemRarity) IsValid() bool {
	switch e {
	case ItemRarityCommon, ItemRarityUncommon, ItemRarityRare, ItemRarityLegendary, ItemRarityUnique:
		return true
	}
	return false
}

func (e ItemRarity) String() string {
	return string(e)
}

func (e *ItemRarity) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemRarity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemRarity", str)
	}
	return nil
}

func (e ItemRarity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define en qué parte del cuerpo o en qué espacio del inventario se equipa un ítem.
// Incluye armaduras, armas, accesorios y objetos especiales.
type ItemSlot string

const (
	// Casco, corona o cualquier tipo de protección para la cabeza.
	ItemSlotHead ItemSlot = "HEAD"
	// Pendientes o accesorios equipados en las orejas.
	ItemSlotEars ItemSlot = "EARS"
	// Collares, amuletos u objetos usados en el cuello.
	ItemSlotNeck ItemSlot = "NECK"
	// Hombreras o protecciones colocadas en los hombros.
	ItemSlotShoulders ItemSlot = "SHOULDERS"
	// Capa, manto o cualquier accesorio usado en la espalda.
	ItemSlotBack ItemSlot = "BACK"
	// Protecciones o equipamiento en los brazos (manguitos, brazales, etc.).
	ItemSlotArms ItemSlot = "ARMS"
	// Muñequeras, pulseras o protecciones en las muñecas.
	ItemSlotWrists ItemSlot = "WRISTS"
	// Guantes, garras o cualquier ítem usado en las manos.
	ItemSlotHands ItemSlot = "HANDS"
	// Anillos y sortijas usados en los dedos.
	ItemSlotFingers ItemSlot = "FINGERS"
	// Armadura o vestimenta que cubre el torso del personaje.
	ItemSlotChest ItemSlot = "CHEST"
	// Cinturones, fajines u otros objetos equipados en la cintura.
	ItemSlotWaist ItemSlot = "WAIST"
	// Armaduras o vestimenta que cubre las piernas completas.
	ItemSlotLegs ItemSlot = "LEGS"
	// Equipamiento para la parte inferior de las piernas (grebas, espinilleras).
	ItemSlotLowerLegs ItemSlot = "LOWER_LEGS"
	// Equipamiento para la parte superior de las piernas (musleras, faldones).
	ItemSlotUpperLegs ItemSlot = "UPPER_LEGS"
	// Protecciones específicas para las rodillas (rodilleras).
	ItemSlotKnees ItemSlot = "KNEES"
	// Botas, sandalias o cualquier calzado usado en los pies.
	ItemSlotFeet ItemSlot = "FEET"
	// Arma de combate cuerpo a cuerpo de una mano.
	ItemSlotMeleeOneHand ItemSlot = "MELEE_ONE_HAND"
	// Arma de combate cuerpo a cuerpo de dos manos.
	ItemSlotMeleeTwoHand ItemSlot = "MELEE_TWO_HAND"
	// Arma a distancia de una mano (pistolas, dagas arrojadizas).
	ItemSlotRangedOneHand ItemSlot = "RANGED_ONE_HAND"
	// Arma a distancia de dos manos (arcos, ballestas, rifles).
	ItemSlotRangedTwoHand ItemSlot = "RANGED_TWO_HAND"
	// Arma híbrida de una mano (arma que puede ser usada cuerpo a cuerpo y a distancia).
	ItemSlotHybridOneHand ItemSlot = "HYBRID_ONE_HAND"
	// Arma híbrida de dos manos (arma de uso mixto con ambas manos).
	ItemSlotHybridTwoHand ItemSlot = "HYBRID_TWO_HAND"
	// Escudos y defensas que se pueden equipar en una mano.
	ItemSlotShield ItemSlot = "SHIELD"
	// Tabardos o emblemas que representan facciones o grupos.
	ItemSlotTabard ItemSlot = "TABARD"
	// Camisas y prendas interiores que no afectan la armadura.
	ItemSlotShirt ItemSlot = "SHIRT"
	// Objetos especiales con habilidades activas o pasivas.
	ItemSlotTrinket ItemSlot = "TRINKET"
	// Reliquias o artefactos sagrados de gran poder.
	ItemSlotRelic ItemSlot = "RELIC"
)

var AllItemSlot = []ItemSlot{
	ItemSlotHead,
	ItemSlotEars,
	ItemSlotNeck,
	ItemSlotShoulders,
	ItemSlotBack,
	ItemSlotArms,
	ItemSlotWrists,
	ItemSlotHands,
	ItemSlotFingers,
	ItemSlotChest,
	ItemSlotWaist,
	ItemSlotLegs,
	ItemSlotLowerLegs,
	ItemSlotUpperLegs,
	ItemSlotKnees,
	ItemSlotFeet,
	ItemSlotMeleeOneHand,
	ItemSlotMeleeTwoHand,
	ItemSlotRangedOneHand,
	ItemSlotRangedTwoHand,
	ItemSlotHybridOneHand,
	ItemSlotHybridTwoHand,
	ItemSlotShield,
	ItemSlotTabard,
	ItemSlotShirt,
	ItemSlotTrinket,
	ItemSlotRelic,
}

func (e ItemSlot) IsValid() bool {
	switch e {
	case ItemSlotHead, ItemSlotEars, ItemSlotNeck, ItemSlotShoulders, ItemSlotBack, ItemSlotArms, ItemSlotWrists, ItemSlotHands, ItemSlotFingers, ItemSlotChest, ItemSlotWaist, ItemSlotLegs, ItemSlotLowerLegs, ItemSlotUpperLegs, ItemSlotKnees, ItemSlotFeet, ItemSlotMeleeOneHand, ItemSlotMeleeTwoHand, ItemSlotRangedOneHand, ItemSlotRangedTwoHand, ItemSlotHybridOneHand, ItemSlotHybridTwoHand, ItemSlotShield, ItemSlotTabard, ItemSlotShirt, ItemSlotTrinket, ItemSlotRelic:
		return true
	}
	return false
}

func (e ItemSlot) String() string {
	return string(e)
}

func (e *ItemSlot) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemSlot(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemSlot", str)
	}
	return nil
}

func (e ItemSlot) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Clasifica los ítems según su función o propósito dentro del mundo ficticio.
type ItemType string

const (
	// Un arma utilizada en combate (espada, lanza, arco, etc.).
	ItemTypeWeapon ItemType = "WEAPON"
	// Armadura o escudo diseñado para la protección del usuario.
	ItemTypeArmor ItemType = "ARMOR"
	// Accesorios de combate como anillos, amuletos, brazales.
	ItemTypeCombatAccessory ItemType = "COMBAT_ACCESSORY"
	// Un artefacto mágico con habilidades únicas.
	ItemTypeArtifact ItemType = "ARTIFACT"
	// Un pergamino o tomo con conocimientos ocultos o conjuros.
	ItemTypeSpellbook ItemType = "SPELLBOOK"
	// Un ítem maldito que tiene efectos negativos sobre su portador.
	ItemTypeCursedItem ItemType = "CURSED_ITEM"
	// Herramientas de uso general como llaves, brújulas, o dagas multiusos.
	ItemTypeTool ItemType = "TOOL"
	// Pociones y consumibles que otorgan efectos temporales.
	ItemTypePotion ItemType = "POTION"
	// Un mapa que proporciona información sobre el mundo o una región.
	ItemTypeMap ItemType = "MAP"
	// Un ítem con importancia histórica o cultural.
	ItemTypeRelic ItemType = "RELIC"
	// Un documento escrito, como un tratado, un contrato o un diario.
	ItemTypeDocument ItemType = "DOCUMENT"
	// Un objeto de alto valor simbólico o representativo de una facción.
	ItemTypeSymbol ItemType = "SYMBOL"
)

var AllItemType = []ItemType{
	ItemTypeWeapon,
	ItemTypeArmor,
	ItemTypeCombatAccessory,
	ItemTypeArtifact,
	ItemTypeSpellbook,
	ItemTypeCursedItem,
	ItemTypeTool,
	ItemTypePotion,
	ItemTypeMap,
	ItemTypeRelic,
	ItemTypeDocument,
	ItemTypeSymbol,
}

func (e ItemType) IsValid() bool {
	switch e {
	case ItemTypeWeapon, ItemTypeArmor, ItemTypeCombatAccessory, ItemTypeArtifact, ItemTypeSpellbook, ItemTypeCursedItem, ItemTypeTool, ItemTypePotion, ItemTypeMap, ItemTypeRelic, ItemTypeDocument, ItemTypeSymbol:
		return true
	}
	return false
}

func (e ItemType) String() string {
	return string(e)
}

func (e *ItemType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ItemType", str)
	}
	return nil
}

func (e ItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define el nivel de accesibilidad de una ubicación.
// Indica si es pública, restringida, oculta o de difícil acceso.
type LocationAccessibility string

const (
	// Ubicación de libre acceso para cualquier persona.
	LocationAccessibilityPublic LocationAccessibility = "PUBLIC"
	// Ubicación restringida, accesible solo para ciertos grupos o con permisos especiales.
	LocationAccessibilityRestricted LocationAccessibility = "RESTRICTED"
	// Ubicación oculta o secreta, su existencia no es de conocimiento público.
	LocationAccessibilityHidden LocationAccessibility = "HIDDEN"
	// Ubicación de acceso extremadamente difícil por razones naturales o mágicas.
	LocationAccessibilityInaccessible LocationAccessibility = "INACCESSIBLE"
)

var AllLocationAccessibility = []LocationAccessibility{
	LocationAccessibilityPublic,
	LocationAccessibilityRestricted,
	LocationAccessibilityHidden,
	LocationAccessibilityInaccessible,
}

func (e LocationAccessibility) IsValid() bool {
	switch e {
	case LocationAccessibilityPublic, LocationAccessibilityRestricted, LocationAccessibilityHidden, LocationAccessibilityInaccessible:
		return true
	}
	return false
}

func (e LocationAccessibility) String() string {
	return string(e)
}

func (e *LocationAccessibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationAccessibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LocationAccessibility", str)
	}
	return nil
}

func (e LocationAccessibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre una ubicación y un evento.
// Puede representar batallas, desastres, fundaciones y más.
type LocationEventRelation string

const (
	// El evento ocurrió en esta ubicación.
	LocationEventRelationOccurredHere LocationEventRelation = "OCCURRED_HERE"
	// La ubicación fue destruida o gravemente afectada por el evento.
	LocationEventRelationDestroyed LocationEventRelation = "DESTROYED"
	// El evento llevó a la fundación de la ubicación.
	LocationEventRelationFounded LocationEventRelation = "FOUNDED"
	// La ubicación fue abandonada como resultado del evento.
	LocationEventRelationAbandoned LocationEventRelation = "ABANDONED"
)

var AllLocationEventRelation = []LocationEventRelation{
	LocationEventRelationOccurredHere,
	LocationEventRelationDestroyed,
	LocationEventRelationFounded,
	LocationEventRelationAbandoned,
}

func (e LocationEventRelation) IsValid() bool {
	switch e {
	case LocationEventRelationOccurredHere, LocationEventRelationDestroyed, LocationEventRelationFounded, LocationEventRelationAbandoned:
		return true
	}
	return false
}

func (e LocationEventRelation) String() string {
	return string(e)
}

func (e *LocationEventRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationEventRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LocationEventRelation", str)
	}
	return nil
}

func (e LocationEventRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre dos ubicaciones.
// Puede representar conexiones geográficas, políticas o mágicas.
type LocationLocationRelation string

const (
	// Una ubicación está dentro de otra (ej. ciudad dentro de un reino).
	LocationLocationRelationContainedWithin LocationLocationRelation = "CONTAINED_WITHIN"
	// Las ubicaciones están conectadas por caminos, túneles o portales.
	LocationLocationRelationConnected LocationLocationRelation = "CONNECTED"
	// Una ubicación es la capital o centro administrativo de otra.
	LocationLocationRelationCapital LocationLocationRelation = "CAPITAL"
	// Las ubicaciones son rivales o han tenido conflictos históricos.
	LocationLocationRelationRivalry LocationLocationRelation = "RIVALRY"
)

var AllLocationLocationRelation = []LocationLocationRelation{
	LocationLocationRelationContainedWithin,
	LocationLocationRelationConnected,
	LocationLocationRelationCapital,
	LocationLocationRelationRivalry,
}

func (e LocationLocationRelation) IsValid() bool {
	switch e {
	case LocationLocationRelationContainedWithin, LocationLocationRelationConnected, LocationLocationRelationCapital, LocationLocationRelationRivalry:
		return true
	}
	return false
}

func (e LocationLocationRelation) String() string {
	return string(e)
}

func (e *LocationLocationRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationLocationRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LocationLocationRelation", str)
	}
	return nil
}

func (e LocationLocationRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Clasifica las ubicaciones según su naturaleza y propósito.
// Incluye ciudades, mazmorras, asentamientos y entornos naturales.
type LocationType string

const (
	// Una ciudad grande con estructuras avanzadas y una alta población.
	LocationTypeCity LocationType = "CITY"
	// Una pequeña aldea o comunidad rural.
	LocationTypeVillage LocationType = "VILLAGE"
	// Un castillo o fortaleza con fines defensivos o administrativos.
	LocationTypeFortress LocationType = "FORTRESS"
	// Un puesto comercial o enclave en una zona aislada.
	LocationTypeOutpost LocationType = "OUTPOST"
	// Un bosque denso con vegetación abundante.
	LocationTypeForest LocationType = "FOREST"
	// Una región desértica con escasez de agua y temperaturas extremas.
	LocationTypeDesert LocationType = "DESERT"
	// Una cueva natural o sistema de cavernas subterráneas.
	LocationTypeCave LocationType = "CAVE"
	// Un cuerpo de agua, como un lago, río o mar.
	LocationTypeWaterBody LocationType = "WATER_BODY"
	// Una cadena montañosa o área rocosa con elevaciones pronunciadas.
	LocationTypeMountains LocationType = "MOUNTAINS"
	// Una isla o archipiélago rodeado de agua.
	LocationTypeIsland LocationType = "ISLAND"
	// Una zona pantanosa con terrenos inestables y humedad alta.
	LocationTypeSwamp LocationType = "SWAMP"
	// Una mazmorra o estructura subterránea con secretos ocultos.
	LocationTypeDungeon LocationType = "DUNGEON"
	// Un templo o santuario con significado religioso o espiritual.
	LocationTypeTemple LocationType = "TEMPLE"
	// Un portal interdimensional o conexión con otro plano de existencia.
	LocationTypePortal LocationType = "PORTAL"
	// Un laboratorio o taller donde se realizan experimentos científicos o mágicos.
	LocationTypeLaboratory LocationType = "LABORATORY"
)

var AllLocationType = []LocationType{
	LocationTypeCity,
	LocationTypeVillage,
	LocationTypeFortress,
	LocationTypeOutpost,
	LocationTypeForest,
	LocationTypeDesert,
	LocationTypeCave,
	LocationTypeWaterBody,
	LocationTypeMountains,
	LocationTypeIsland,
	LocationTypeSwamp,
	LocationTypeDungeon,
	LocationTypeTemple,
	LocationTypePortal,
	LocationTypeLaboratory,
}

func (e LocationType) IsValid() bool {
	switch e {
	case LocationTypeCity, LocationTypeVillage, LocationTypeFortress, LocationTypeOutpost, LocationTypeForest, LocationTypeDesert, LocationTypeCave, LocationTypeWaterBody, LocationTypeMountains, LocationTypeIsland, LocationTypeSwamp, LocationTypeDungeon, LocationTypeTemple, LocationTypePortal, LocationTypeLaboratory:
		return true
	}
	return false
}

func (e LocationType) String() string {
	return string(e)
}

func (e *LocationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LocationType", str)
	}
	return nil
}

func (e LocationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre una ubicación y un mundo.
// Puede representar su existencia, influencia interdimensional y más.
type LocationWorldRelation string

const (
	// La ubicación es originaria de este mundo.
	LocationWorldRelationNative LocationWorldRelation = "NATIVE"
	// La ubicación fue creada artificialmente en este mundo.
	LocationWorldRelationArtificial LocationWorldRelation = "ARTIFICIAL"
	// La ubicación existe en múltiples mundos al mismo tiempo (multiversal, interdimensional).
	LocationWorldRelationMultiverseExistence LocationWorldRelation = "MULTIVERSE_EXISTENCE"
	// La ubicación tiene portales o conexiones con este mundo.
	LocationWorldRelationConnected LocationWorldRelation = "CONNECTED"
	// La ubicación es inaccesible desde este mundo sin medios especiales.
	LocationWorldRelationInaccessible LocationWorldRelation = "INACCESSIBLE"
	// La ubicación es una anomalía dentro del mundo (cambio de realidad, error mágico).
	LocationWorldRelationAnomaly LocationWorldRelation = "ANOMALY"
)

var AllLocationWorldRelation = []LocationWorldRelation{
	LocationWorldRelationNative,
	LocationWorldRelationArtificial,
	LocationWorldRelationMultiverseExistence,
	LocationWorldRelationConnected,
	LocationWorldRelationInaccessible,
	LocationWorldRelationAnomaly,
}

func (e LocationWorldRelation) IsValid() bool {
	switch e {
	case LocationWorldRelationNative, LocationWorldRelationArtificial, LocationWorldRelationMultiverseExistence, LocationWorldRelationConnected, LocationWorldRelationInaccessible, LocationWorldRelationAnomaly:
		return true
	}
	return false
}

func (e LocationWorldRelation) String() string {
	return string(e)
}

func (e *LocationWorldRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LocationWorldRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LocationWorldRelation", str)
	}
	return nil
}

func (e LocationWorldRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre un mundo y un evento.
// Puede representar desastres, descubrimientos, guerras y más.
type WorldEventRelation string

const (
	// El evento ocurrió en este mundo.
	WorldEventRelationOccurredHere WorldEventRelation = "OCCURRED_HERE"
	// El evento llevó a la destrucción parcial o total del mundo.
	WorldEventRelationDevastated WorldEventRelation = "DEVASTATED"
	// El evento llevó al descubrimiento del mundo por otras civilizaciones.
	WorldEventRelationDiscovered WorldEventRelation = "DISCOVERED"
	// El evento alteró la realidad o estructura del mundo de manera significativa.
	WorldEventRelationAltered WorldEventRelation = "ALTERED"
)

var AllWorldEventRelation = []WorldEventRelation{
	WorldEventRelationOccurredHere,
	WorldEventRelationDevastated,
	WorldEventRelationDiscovered,
	WorldEventRelationAltered,
}

func (e WorldEventRelation) IsValid() bool {
	switch e {
	case WorldEventRelationOccurredHere, WorldEventRelationDevastated, WorldEventRelationDiscovered, WorldEventRelationAltered:
		return true
	}
	return false
}

func (e WorldEventRelation) String() string {
	return string(e)
}

func (e *WorldEventRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorldEventRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorldEventRelation", str)
	}
	return nil
}

func (e WorldEventRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Clasifica los mundos según su naturaleza, origen y características principales.
type WorldType string

const (
	// Un mundo con características similares a la Tierra.
	WorldTypeTerrestrial WorldType = "TERRESTRIAL"
	// Un mundo desértico, árido y con escasez de agua.
	WorldTypeDesert WorldType = "DESERT"
	// Un mundo oceánico con vastas masas de agua y pocas tierras emergidas.
	WorldTypeOceanic WorldType = "OCEANIC"
	// Un mundo cubierto de hielo y nieve con temperaturas extremas.
	WorldTypeIce WorldType = "ICE"
	// Un mundo volcánico, con actividad geológica intensa.
	WorldTypeVolcanic WorldType = "VOLCANIC"
	// Un mundo gaseoso sin superficie sólida (tipo Júpiter o Saturno).
	WorldTypeGasGiant WorldType = "GAS_GIANT"
	// Un mundo conectado a lo divino o gobernado por entidades celestiales.
	WorldTypeDivineRealm WorldType = "DIVINE_REALM"
	// Un mundo demoníaco, caótico o infernal.
	WorldTypeHellish WorldType = "HELLISH"
	// Un mundo de sueños, ilusiones o materialización del pensamiento.
	WorldTypeDreamRealm WorldType = "DREAM_REALM"
	// Un mundo que existe en múltiples dimensiones simultáneamente.
	WorldTypeMultidimensional WorldType = "MULTIDIMENSIONAL"
	// Un mundo artificialmente construido, como una megaestructura o nave-mundo.
	WorldTypeArtificial WorldType = "ARTIFICIAL"
	// Un mundo apocalíptico o en ruinas, con civilizaciones colapsadas.
	WorldTypePostApocalyptic WorldType = "POST_APOCALYPTIC"
	// Un mundo que ha sido abandonado o en el que la vida ha desaparecido.
	WorldTypeDeadWorld WorldType = "DEAD_WORLD"
)

var AllWorldType = []WorldType{
	WorldTypeTerrestrial,
	WorldTypeDesert,
	WorldTypeOceanic,
	WorldTypeIce,
	WorldTypeVolcanic,
	WorldTypeGasGiant,
	WorldTypeDivineRealm,
	WorldTypeHellish,
	WorldTypeDreamRealm,
	WorldTypeMultidimensional,
	WorldTypeArtificial,
	WorldTypePostApocalyptic,
	WorldTypeDeadWorld,
}

func (e WorldType) IsValid() bool {
	switch e {
	case WorldTypeTerrestrial, WorldTypeDesert, WorldTypeOceanic, WorldTypeIce, WorldTypeVolcanic, WorldTypeGasGiant, WorldTypeDivineRealm, WorldTypeHellish, WorldTypeDreamRealm, WorldTypeMultidimensional, WorldTypeArtificial, WorldTypePostApocalyptic, WorldTypeDeadWorld:
		return true
	}
	return false
}

func (e WorldType) String() string {
	return string(e)
}

func (e *WorldType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorldType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorldType", str)
	}
	return nil
}

func (e WorldType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Define la relación entre dos mundos.
// Puede representar conexiones interdimensionales, origen compartido y más.
type WorldWorldRelation string

const (
	// Los mundos están conectados por portales, magia o tecnología avanzada.
	WorldWorldRelationConnected WorldWorldRelation = "CONNECTED"
	// Un mundo es una versión alternativa o divergente del otro.
	WorldWorldRelationAlternateVersion WorldWorldRelation = "ALTERNATE_VERSION"
	// Uno de los mundos fue creado artificialmente a partir del otro.
	WorldWorldRelationCreatedFrom WorldWorldRelation = "CREATED_FROM"
	// Los mundos comparten un mismo origen cósmico o mitológico.
	WorldWorldRelationSharedOrigin WorldWorldRelation = "SHARED_ORIGIN"
)

var AllWorldWorldRelation = []WorldWorldRelation{
	WorldWorldRelationConnected,
	WorldWorldRelationAlternateVersion,
	WorldWorldRelationCreatedFrom,
	WorldWorldRelationSharedOrigin,
}

func (e WorldWorldRelation) IsValid() bool {
	switch e {
	case WorldWorldRelationConnected, WorldWorldRelationAlternateVersion, WorldWorldRelationCreatedFrom, WorldWorldRelationSharedOrigin:
		return true
	}
	return false
}

func (e WorldWorldRelation) String() string {
	return string(e)
}

func (e *WorldWorldRelation) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WorldWorldRelation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WorldWorldRelation", str)
	}
	return nil
}

func (e WorldWorldRelation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
