// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gentypes

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"ordo-map/graph/model"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Character struct {
		Alignment   func(childComplexity int) int
		BirthDate   func(childComplexity int) int
		Characters  func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Creatures   func(childComplexity int) int
		Description func(childComplexity int) int
		Events      func(childComplexity int) int
		Factions    func(childComplexity int) int
		Height      func(childComplexity int) int
		ID          func(childComplexity int) int
		IsAlive     func(childComplexity int) int
		IsMain      func(childComplexity int) int
		Items       func(childComplexity int) int
		Locations   func(childComplexity int) int
		Name        func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Weight      func(childComplexity int) int
		Worlds      func(childComplexity int) int
	}

	CharacterCharacter struct {
		Character              func(childComplexity int) int
		CharacterRelationLevel func(childComplexity int) int
		EndDate                func(childComplexity int) int
		FamilyRelation         func(childComplexity int) int
		ID                     func(childComplexity int) int
		StartDate              func(childComplexity int) int
	}

	CharacterCreature struct {
		Character func(childComplexity int) int
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CharacterEvent struct {
		Character func(childComplexity int) int
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CharacterFaction struct {
		Character func(childComplexity int) int
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CharacterItem struct {
		Character func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CharacterLocation struct {
		Character func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CharacterWorld struct {
		Character func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}

	Creature struct {
		Abilities         func(childComplexity int) int
		Behavior          func(childComplexity int) int
		BirthDate         func(childComplexity int) int
		Characters        func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		Creatures         func(childComplexity int) int
		Description       func(childComplexity int) int
		Diet              func(childComplexity int) int
		Events            func(childComplexity int) int
		Factions          func(childComplexity int) int
		Habitat           func(childComplexity int) int
		Height            func(childComplexity int) int
		ID                func(childComplexity int) int
		IntelligenceLevel func(childComplexity int) int
		IsAlive           func(childComplexity int) int
		IsUnique          func(childComplexity int) int
		Lifespan          func(childComplexity int) int
		Locations         func(childComplexity int) int
		Name              func(childComplexity int) int
		Species           func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		Weight            func(childComplexity int) int
		Worlds            func(childComplexity int) int
	}

	CreatureCreature struct {
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CreatureEvent struct {
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CreatureFaction struct {
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CreatureLocation struct {
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CreatureWorld struct {
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}

	Event struct {
		Characters    func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		Creatures     func(childComplexity int) int
		Description   func(childComplexity int) int
		EndDate       func(childComplexity int) int
		Factions      func(childComplexity int) int
		ID            func(childComplexity int) int
		IsRecurring   func(childComplexity int) int
		Items         func(childComplexity int) int
		Locations     func(childComplexity int) int
		Name          func(childComplexity int) int
		Nature        func(childComplexity int) int
		RelatedEvents func(childComplexity int) int
		Significance  func(childComplexity int) int
		StartDate     func(childComplexity int) int
		Type          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Worlds        func(childComplexity int) int
	}

	Faction struct {
		Characters    func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		Creatures     func(childComplexity int) int
		Description   func(childComplexity int) int
		DisbandedDate func(childComplexity int) int
		Events        func(childComplexity int) int
		Factions      func(childComplexity int) int
		FoundedDate   func(childComplexity int) int
		ID            func(childComplexity int) int
		Ideology      func(childComplexity int) int
		Influence     func(childComplexity int) int
		Items         func(childComplexity int) int
		Locations     func(childComplexity int) int
		Name          func(childComplexity int) int
		Status        func(childComplexity int) int
		Type          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Worlds        func(childComplexity int) int
	}

	FactionEvent struct {
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	FactionFaction struct {
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	FactionItem struct {
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	FactionLocation struct {
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	FactionWorld struct {
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}

	Item struct {
		Abilities       func(childComplexity int) int
		Characters      func(childComplexity int) int
		Condition       func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		CreationDate    func(childComplexity int) int
		Description     func(childComplexity int) int
		DestructionDate func(childComplexity int) int
		Dimensions      func(childComplexity int) int
		Events          func(childComplexity int) int
		Factions        func(childComplexity int) int
		ID              func(childComplexity int) int
		IsMagical       func(childComplexity int) int
		Locations       func(childComplexity int) int
		Material        func(childComplexity int) int
		Name            func(childComplexity int) int
		Rarity          func(childComplexity int) int
		RelatedItems    func(childComplexity int) int
		Slot            func(childComplexity int) int
		Type            func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		Value           func(childComplexity int) int
		Weight          func(childComplexity int) int
	}

	ItemEvent struct {
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	ItemItem struct {
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	ItemLocation struct {
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		With      func(childComplexity int) int
	}

	Location struct {
		Accessibility    func(childComplexity int) int
		Characters       func(childComplexity int) int
		Climate          func(childComplexity int) int
		Coordinates      func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Creatures        func(childComplexity int) int
		Description      func(childComplexity int) int
		Ecosystem        func(childComplexity int) int
		Events           func(childComplexity int) int
		Factions         func(childComplexity int) int
		ID               func(childComplexity int) int
		IsNatural        func(childComplexity int) int
		Items            func(childComplexity int) int
		Name             func(childComplexity int) int
		Region           func(childComplexity int) int
		RelatedLocations func(childComplexity int) int
		Type             func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		Worlds           func(childComplexity int) int
	}

	LocationEvent struct {
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	LocationLocation struct {
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	LocationWorld struct {
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}

	Mutation struct {
		CreateCharacter func(childComplexity int, input model.CreateCharacterInput) int
		CreateCreature  func(childComplexity int, input model.CreateCreatureInput) int
		CreateEvent     func(childComplexity int, input model.CreateEventInput) int
		CreateFaction   func(childComplexity int, input model.CreateFactionInput) int
		CreateItem      func(childComplexity int, input model.CreateItemInput) int
		CreateLocation  func(childComplexity int, input model.CreateLocationInput) int
		CreateUniverse  func(childComplexity int, input model.CreateUniverseInput) int
		CreateWorld     func(childComplexity int, input model.CreateWorldInput) int
		DeleteCharacter func(childComplexity int, id string) int
		DeleteCreature  func(childComplexity int, id string) int
		DeleteEvent     func(childComplexity int, id string) int
		DeleteFaction   func(childComplexity int, id string) int
		DeleteItem      func(childComplexity int, id string) int
		DeleteLocation  func(childComplexity int, id string) int
		DeleteUniverse  func(childComplexity int, id string) int
		DeleteWorld     func(childComplexity int, id string) int
		UpdateCharacter func(childComplexity int, input model.UpdateCharacterInput) int
		UpdateCreature  func(childComplexity int, input model.UpdateCreatureInput) int
		UpdateEvent     func(childComplexity int, input model.UpdateEventInput) int
		UpdateFaction   func(childComplexity int, input model.UpdateFactionInput) int
		UpdateItem      func(childComplexity int, input model.UpdateItemInput) int
		UpdateLocation  func(childComplexity int, input model.UpdateLocationInput) int
		UpdateUniverse  func(childComplexity int, input model.UpdateUniverseInput) int
		UpdateWorld     func(childComplexity int, input model.UpdateWorldInput) int
	}

	Query struct {
		Character  func(childComplexity int, id string) int
		Characters func(childComplexity int, worldID string, limit *int, offset *int) int
		Creature   func(childComplexity int, id string) int
		Creatures  func(childComplexity int, worldID string, limit *int, offset *int) int
		Event      func(childComplexity int, id string) int
		Events     func(childComplexity int, worldID string, limit *int, offset *int) int
		Faction    func(childComplexity int, id string) int
		Factions   func(childComplexity int, worldID string, limit *int, offset *int) int
		Item       func(childComplexity int, id string) int
		Items      func(childComplexity int, worldID string, limit *int, offset *int) int
		Location   func(childComplexity int, id string) int
		Locations  func(childComplexity int, worldID string, limit *int, offset *int) int
		Universe   func(childComplexity int, id string) int
		Universes  func(childComplexity int, limit *int, offset *int) int
		World      func(childComplexity int, id string) int
		Worlds     func(childComplexity int, universeID string, limit *int, offset *int) int
	}

	Response struct {
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	Universe struct {
		Characters  func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Creatures   func(childComplexity int) int
		Description func(childComplexity int) int
		Events      func(childComplexity int) int
		Factions    func(childComplexity int) int
		ID          func(childComplexity int) int
		IsActive    func(childComplexity int) int
		Items       func(childComplexity int) int
		Locations   func(childComplexity int) int
		Name        func(childComplexity int) int
		StartYear   func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Worlds      func(childComplexity int) int
	}

	World struct {
		Characters      func(childComplexity int) int
		Climate         func(childComplexity int) int
		ConnectedWorlds func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Creatures       func(childComplexity int) int
		Description     func(childComplexity int) int
		Ecosystem       func(childComplexity int) int
		EnergySources   func(childComplexity int) int
		Events          func(childComplexity int) int
		Factions        func(childComplexity int) int
		Gravity         func(childComplexity int) int
		HasAtmosphere   func(childComplexity int) int
		ID              func(childComplexity int) int
		IsHabitable     func(childComplexity int) int
		Locations       func(childComplexity int) int
		Moons           func(childComplexity int) int
		Name            func(childComplexity int) int
		Size            func(childComplexity int) int
		Stars           func(childComplexity int) int
		TechnologyLevel func(childComplexity int) int
		Type            func(childComplexity int) int
		Universe        func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
	}

	WorldEvent struct {
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}

	WorldWorld struct {
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateCharacter(ctx context.Context, input model.CreateCharacterInput) (*model.Character, error)
	UpdateCharacter(ctx context.Context, input model.UpdateCharacterInput) (*model.Character, error)
	DeleteCharacter(ctx context.Context, id string) (bool, error)
	CreateCreature(ctx context.Context, input model.CreateCreatureInput) (*model.Creature, error)
	UpdateCreature(ctx context.Context, input model.UpdateCreatureInput) (*model.Creature, error)
	DeleteCreature(ctx context.Context, id string) (bool, error)
	CreateItem(ctx context.Context, input model.CreateItemInput) (*model.Item, error)
	UpdateItem(ctx context.Context, input model.UpdateItemInput) (*model.Item, error)
	DeleteItem(ctx context.Context, id string) (bool, error)
	CreateLocation(ctx context.Context, input model.CreateLocationInput) (*model.Location, error)
	UpdateLocation(ctx context.Context, input model.UpdateLocationInput) (*model.Location, error)
	DeleteLocation(ctx context.Context, id string) (bool, error)
	CreateFaction(ctx context.Context, input model.CreateFactionInput) (*model.Faction, error)
	UpdateFaction(ctx context.Context, input model.UpdateFactionInput) (*model.Faction, error)
	DeleteFaction(ctx context.Context, id string) (bool, error)
	CreateEvent(ctx context.Context, input model.CreateEventInput) (*model.Event, error)
	UpdateEvent(ctx context.Context, input model.UpdateEventInput) (*model.Event, error)
	DeleteEvent(ctx context.Context, id string) (bool, error)
	CreateWorld(ctx context.Context, input model.CreateWorldInput) (*model.World, error)
	UpdateWorld(ctx context.Context, input model.UpdateWorldInput) (*model.World, error)
	DeleteWorld(ctx context.Context, id string) (bool, error)
	CreateUniverse(ctx context.Context, input model.CreateUniverseInput) (*model.Universe, error)
	UpdateUniverse(ctx context.Context, input model.UpdateUniverseInput) (*model.Universe, error)
	DeleteUniverse(ctx context.Context, id string) (bool, error)
}
type QueryResolver interface {
	Character(ctx context.Context, id string) (*model.Character, error)
	Characters(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Character, error)
	Creature(ctx context.Context, id string) (*model.Creature, error)
	Creatures(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Creature, error)
	Item(ctx context.Context, id string) (*model.Item, error)
	Items(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Item, error)
	Location(ctx context.Context, id string) (*model.Location, error)
	Locations(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Location, error)
	Faction(ctx context.Context, id string) (*model.Faction, error)
	Factions(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Faction, error)
	Event(ctx context.Context, id string) (*model.Event, error)
	Events(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Event, error)
	World(ctx context.Context, id string) (*model.World, error)
	Worlds(ctx context.Context, universeID string, limit *int, offset *int) ([]*model.World, error)
	Universe(ctx context.Context, id string) (*model.Universe, error)
	Universes(ctx context.Context, limit *int, offset *int) ([]*model.Universe, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Character.alignment":
		if e.complexity.Character.Alignment == nil {
			break
		}

		return e.complexity.Character.Alignment(childComplexity), true

	case "Character.birthDate":
		if e.complexity.Character.BirthDate == nil {
			break
		}

		return e.complexity.Character.BirthDate(childComplexity), true

	case "Character.characters":
		if e.complexity.Character.Characters == nil {
			break
		}

		return e.complexity.Character.Characters(childComplexity), true

	case "Character.createdAt":
		if e.complexity.Character.CreatedAt == nil {
			break
		}

		return e.complexity.Character.CreatedAt(childComplexity), true

	case "Character.creatures":
		if e.complexity.Character.Creatures == nil {
			break
		}

		return e.complexity.Character.Creatures(childComplexity), true

	case "Character.description":
		if e.complexity.Character.Description == nil {
			break
		}

		return e.complexity.Character.Description(childComplexity), true

	case "Character.events":
		if e.complexity.Character.Events == nil {
			break
		}

		return e.complexity.Character.Events(childComplexity), true

	case "Character.factions":
		if e.complexity.Character.Factions == nil {
			break
		}

		return e.complexity.Character.Factions(childComplexity), true

	case "Character.height":
		if e.complexity.Character.Height == nil {
			break
		}

		return e.complexity.Character.Height(childComplexity), true

	case "Character.id":
		if e.complexity.Character.ID == nil {
			break
		}

		return e.complexity.Character.ID(childComplexity), true

	case "Character.isAlive":
		if e.complexity.Character.IsAlive == nil {
			break
		}

		return e.complexity.Character.IsAlive(childComplexity), true

	case "Character.isMain":
		if e.complexity.Character.IsMain == nil {
			break
		}

		return e.complexity.Character.IsMain(childComplexity), true

	case "Character.items":
		if e.complexity.Character.Items == nil {
			break
		}

		return e.complexity.Character.Items(childComplexity), true

	case "Character.locations":
		if e.complexity.Character.Locations == nil {
			break
		}

		return e.complexity.Character.Locations(childComplexity), true

	case "Character.name":
		if e.complexity.Character.Name == nil {
			break
		}

		return e.complexity.Character.Name(childComplexity), true

	case "Character.type":
		if e.complexity.Character.Type == nil {
			break
		}

		return e.complexity.Character.Type(childComplexity), true

	case "Character.updatedAt":
		if e.complexity.Character.UpdatedAt == nil {
			break
		}

		return e.complexity.Character.UpdatedAt(childComplexity), true

	case "Character.weight":
		if e.complexity.Character.Weight == nil {
			break
		}

		return e.complexity.Character.Weight(childComplexity), true

	case "Character.worlds":
		if e.complexity.Character.Worlds == nil {
			break
		}

		return e.complexity.Character.Worlds(childComplexity), true

	case "CharacterCharacter.character":
		if e.complexity.CharacterCharacter.Character == nil {
			break
		}

		return e.complexity.CharacterCharacter.Character(childComplexity), true

	case "CharacterCharacter.characterRelationLevel":
		if e.complexity.CharacterCharacter.CharacterRelationLevel == nil {
			break
		}

		return e.complexity.CharacterCharacter.CharacterRelationLevel(childComplexity), true

	case "CharacterCharacter.endDate":
		if e.complexity.CharacterCharacter.EndDate == nil {
			break
		}

		return e.complexity.CharacterCharacter.EndDate(childComplexity), true

	case "CharacterCharacter.familyRelation":
		if e.complexity.CharacterCharacter.FamilyRelation == nil {
			break
		}

		return e.complexity.CharacterCharacter.FamilyRelation(childComplexity), true

	case "CharacterCharacter.id":
		if e.complexity.CharacterCharacter.ID == nil {
			break
		}

		return e.complexity.CharacterCharacter.ID(childComplexity), true

	case "CharacterCharacter.startDate":
		if e.complexity.CharacterCharacter.StartDate == nil {
			break
		}

		return e.complexity.CharacterCharacter.StartDate(childComplexity), true

	case "CharacterCreature.character":
		if e.complexity.CharacterCreature.Character == nil {
			break
		}

		return e.complexity.CharacterCreature.Character(childComplexity), true

	case "CharacterCreature.creature":
		if e.complexity.CharacterCreature.Creature == nil {
			break
		}

		return e.complexity.CharacterCreature.Creature(childComplexity), true

	case "CharacterCreature.endDate":
		if e.complexity.CharacterCreature.EndDate == nil {
			break
		}

		return e.complexity.CharacterCreature.EndDate(childComplexity), true

	case "CharacterCreature.id":
		if e.complexity.CharacterCreature.ID == nil {
			break
		}

		return e.complexity.CharacterCreature.ID(childComplexity), true

	case "CharacterCreature.relation":
		if e.complexity.CharacterCreature.Relation == nil {
			break
		}

		return e.complexity.CharacterCreature.Relation(childComplexity), true

	case "CharacterCreature.startDate":
		if e.complexity.CharacterCreature.StartDate == nil {
			break
		}

		return e.complexity.CharacterCreature.StartDate(childComplexity), true

	case "CharacterEvent.character":
		if e.complexity.CharacterEvent.Character == nil {
			break
		}

		return e.complexity.CharacterEvent.Character(childComplexity), true

	case "CharacterEvent.endDate":
		if e.complexity.CharacterEvent.EndDate == nil {
			break
		}

		return e.complexity.CharacterEvent.EndDate(childComplexity), true

	case "CharacterEvent.event":
		if e.complexity.CharacterEvent.Event == nil {
			break
		}

		return e.complexity.CharacterEvent.Event(childComplexity), true

	case "CharacterEvent.id":
		if e.complexity.CharacterEvent.ID == nil {
			break
		}

		return e.complexity.CharacterEvent.ID(childComplexity), true

	case "CharacterEvent.relation":
		if e.complexity.CharacterEvent.Relation == nil {
			break
		}

		return e.complexity.CharacterEvent.Relation(childComplexity), true

	case "CharacterEvent.startDate":
		if e.complexity.CharacterEvent.StartDate == nil {
			break
		}

		return e.complexity.CharacterEvent.StartDate(childComplexity), true

	case "CharacterFaction.character":
		if e.complexity.CharacterFaction.Character == nil {
			break
		}

		return e.complexity.CharacterFaction.Character(childComplexity), true

	case "CharacterFaction.endDate":
		if e.complexity.CharacterFaction.EndDate == nil {
			break
		}

		return e.complexity.CharacterFaction.EndDate(childComplexity), true

	case "CharacterFaction.faction":
		if e.complexity.CharacterFaction.Faction == nil {
			break
		}

		return e.complexity.CharacterFaction.Faction(childComplexity), true

	case "CharacterFaction.id":
		if e.complexity.CharacterFaction.ID == nil {
			break
		}

		return e.complexity.CharacterFaction.ID(childComplexity), true

	case "CharacterFaction.relation":
		if e.complexity.CharacterFaction.Relation == nil {
			break
		}

		return e.complexity.CharacterFaction.Relation(childComplexity), true

	case "CharacterFaction.startDate":
		if e.complexity.CharacterFaction.StartDate == nil {
			break
		}

		return e.complexity.CharacterFaction.StartDate(childComplexity), true

	case "CharacterItem.character":
		if e.complexity.CharacterItem.Character == nil {
			break
		}

		return e.complexity.CharacterItem.Character(childComplexity), true

	case "CharacterItem.endDate":
		if e.complexity.CharacterItem.EndDate == nil {
			break
		}

		return e.complexity.CharacterItem.EndDate(childComplexity), true

	case "CharacterItem.id":
		if e.complexity.CharacterItem.ID == nil {
			break
		}

		return e.complexity.CharacterItem.ID(childComplexity), true

	case "CharacterItem.item":
		if e.complexity.CharacterItem.Item == nil {
			break
		}

		return e.complexity.CharacterItem.Item(childComplexity), true

	case "CharacterItem.relation":
		if e.complexity.CharacterItem.Relation == nil {
			break
		}

		return e.complexity.CharacterItem.Relation(childComplexity), true

	case "CharacterItem.startDate":
		if e.complexity.CharacterItem.StartDate == nil {
			break
		}

		return e.complexity.CharacterItem.StartDate(childComplexity), true

	case "CharacterLocation.character":
		if e.complexity.CharacterLocation.Character == nil {
			break
		}

		return e.complexity.CharacterLocation.Character(childComplexity), true

	case "CharacterLocation.endDate":
		if e.complexity.CharacterLocation.EndDate == nil {
			break
		}

		return e.complexity.CharacterLocation.EndDate(childComplexity), true

	case "CharacterLocation.id":
		if e.complexity.CharacterLocation.ID == nil {
			break
		}

		return e.complexity.CharacterLocation.ID(childComplexity), true

	case "CharacterLocation.location":
		if e.complexity.CharacterLocation.Location == nil {
			break
		}

		return e.complexity.CharacterLocation.Location(childComplexity), true

	case "CharacterLocation.relation":
		if e.complexity.CharacterLocation.Relation == nil {
			break
		}

		return e.complexity.CharacterLocation.Relation(childComplexity), true

	case "CharacterLocation.startDate":
		if e.complexity.CharacterLocation.StartDate == nil {
			break
		}

		return e.complexity.CharacterLocation.StartDate(childComplexity), true

	case "CharacterWorld.character":
		if e.complexity.CharacterWorld.Character == nil {
			break
		}

		return e.complexity.CharacterWorld.Character(childComplexity), true

	case "CharacterWorld.endDate":
		if e.complexity.CharacterWorld.EndDate == nil {
			break
		}

		return e.complexity.CharacterWorld.EndDate(childComplexity), true

	case "CharacterWorld.id":
		if e.complexity.CharacterWorld.ID == nil {
			break
		}

		return e.complexity.CharacterWorld.ID(childComplexity), true

	case "CharacterWorld.relation":
		if e.complexity.CharacterWorld.Relation == nil {
			break
		}

		return e.complexity.CharacterWorld.Relation(childComplexity), true

	case "CharacterWorld.startDate":
		if e.complexity.CharacterWorld.StartDate == nil {
			break
		}

		return e.complexity.CharacterWorld.StartDate(childComplexity), true

	case "CharacterWorld.world":
		if e.complexity.CharacterWorld.World == nil {
			break
		}

		return e.complexity.CharacterWorld.World(childComplexity), true

	case "Creature.abilities":
		if e.complexity.Creature.Abilities == nil {
			break
		}

		return e.complexity.Creature.Abilities(childComplexity), true

	case "Creature.behavior":
		if e.complexity.Creature.Behavior == nil {
			break
		}

		return e.complexity.Creature.Behavior(childComplexity), true

	case "Creature.birthDate":
		if e.complexity.Creature.BirthDate == nil {
			break
		}

		return e.complexity.Creature.BirthDate(childComplexity), true

	case "Creature.characters":
		if e.complexity.Creature.Characters == nil {
			break
		}

		return e.complexity.Creature.Characters(childComplexity), true

	case "Creature.createdAt":
		if e.complexity.Creature.CreatedAt == nil {
			break
		}

		return e.complexity.Creature.CreatedAt(childComplexity), true

	case "Creature.creatures":
		if e.complexity.Creature.Creatures == nil {
			break
		}

		return e.complexity.Creature.Creatures(childComplexity), true

	case "Creature.description":
		if e.complexity.Creature.Description == nil {
			break
		}

		return e.complexity.Creature.Description(childComplexity), true

	case "Creature.diet":
		if e.complexity.Creature.Diet == nil {
			break
		}

		return e.complexity.Creature.Diet(childComplexity), true

	case "Creature.events":
		if e.complexity.Creature.Events == nil {
			break
		}

		return e.complexity.Creature.Events(childComplexity), true

	case "Creature.factions":
		if e.complexity.Creature.Factions == nil {
			break
		}

		return e.complexity.Creature.Factions(childComplexity), true

	case "Creature.habitat":
		if e.complexity.Creature.Habitat == nil {
			break
		}

		return e.complexity.Creature.Habitat(childComplexity), true

	case "Creature.height":
		if e.complexity.Creature.Height == nil {
			break
		}

		return e.complexity.Creature.Height(childComplexity), true

	case "Creature.id":
		if e.complexity.Creature.ID == nil {
			break
		}

		return e.complexity.Creature.ID(childComplexity), true

	case "Creature.intelligenceLevel":
		if e.complexity.Creature.IntelligenceLevel == nil {
			break
		}

		return e.complexity.Creature.IntelligenceLevel(childComplexity), true

	case "Creature.isAlive":
		if e.complexity.Creature.IsAlive == nil {
			break
		}

		return e.complexity.Creature.IsAlive(childComplexity), true

	case "Creature.isUnique":
		if e.complexity.Creature.IsUnique == nil {
			break
		}

		return e.complexity.Creature.IsUnique(childComplexity), true

	case "Creature.lifespan":
		if e.complexity.Creature.Lifespan == nil {
			break
		}

		return e.complexity.Creature.Lifespan(childComplexity), true

	case "Creature.locations":
		if e.complexity.Creature.Locations == nil {
			break
		}

		return e.complexity.Creature.Locations(childComplexity), true

	case "Creature.name":
		if e.complexity.Creature.Name == nil {
			break
		}

		return e.complexity.Creature.Name(childComplexity), true

	case "Creature.species":
		if e.complexity.Creature.Species == nil {
			break
		}

		return e.complexity.Creature.Species(childComplexity), true

	case "Creature.type":
		if e.complexity.Creature.Type == nil {
			break
		}

		return e.complexity.Creature.Type(childComplexity), true

	case "Creature.updatedAt":
		if e.complexity.Creature.UpdatedAt == nil {
			break
		}

		return e.complexity.Creature.UpdatedAt(childComplexity), true

	case "Creature.weight":
		if e.complexity.Creature.Weight == nil {
			break
		}

		return e.complexity.Creature.Weight(childComplexity), true

	case "Creature.worlds":
		if e.complexity.Creature.Worlds == nil {
			break
		}

		return e.complexity.Creature.Worlds(childComplexity), true

	case "CreatureCreature.creature":
		if e.complexity.CreatureCreature.Creature == nil {
			break
		}

		return e.complexity.CreatureCreature.Creature(childComplexity), true

	case "CreatureCreature.endDate":
		if e.complexity.CreatureCreature.EndDate == nil {
			break
		}

		return e.complexity.CreatureCreature.EndDate(childComplexity), true

	case "CreatureCreature.id":
		if e.complexity.CreatureCreature.ID == nil {
			break
		}

		return e.complexity.CreatureCreature.ID(childComplexity), true

	case "CreatureCreature.relation":
		if e.complexity.CreatureCreature.Relation == nil {
			break
		}

		return e.complexity.CreatureCreature.Relation(childComplexity), true

	case "CreatureCreature.startDate":
		if e.complexity.CreatureCreature.StartDate == nil {
			break
		}

		return e.complexity.CreatureCreature.StartDate(childComplexity), true

	case "CreatureEvent.creature":
		if e.complexity.CreatureEvent.Creature == nil {
			break
		}

		return e.complexity.CreatureEvent.Creature(childComplexity), true

	case "CreatureEvent.endDate":
		if e.complexity.CreatureEvent.EndDate == nil {
			break
		}

		return e.complexity.CreatureEvent.EndDate(childComplexity), true

	case "CreatureEvent.event":
		if e.complexity.CreatureEvent.Event == nil {
			break
		}

		return e.complexity.CreatureEvent.Event(childComplexity), true

	case "CreatureEvent.id":
		if e.complexity.CreatureEvent.ID == nil {
			break
		}

		return e.complexity.CreatureEvent.ID(childComplexity), true

	case "CreatureEvent.relation":
		if e.complexity.CreatureEvent.Relation == nil {
			break
		}

		return e.complexity.CreatureEvent.Relation(childComplexity), true

	case "CreatureEvent.startDate":
		if e.complexity.CreatureEvent.StartDate == nil {
			break
		}

		return e.complexity.CreatureEvent.StartDate(childComplexity), true

	case "CreatureFaction.creature":
		if e.complexity.CreatureFaction.Creature == nil {
			break
		}

		return e.complexity.CreatureFaction.Creature(childComplexity), true

	case "CreatureFaction.endDate":
		if e.complexity.CreatureFaction.EndDate == nil {
			break
		}

		return e.complexity.CreatureFaction.EndDate(childComplexity), true

	case "CreatureFaction.faction":
		if e.complexity.CreatureFaction.Faction == nil {
			break
		}

		return e.complexity.CreatureFaction.Faction(childComplexity), true

	case "CreatureFaction.id":
		if e.complexity.CreatureFaction.ID == nil {
			break
		}

		return e.complexity.CreatureFaction.ID(childComplexity), true

	case "CreatureFaction.relation":
		if e.complexity.CreatureFaction.Relation == nil {
			break
		}

		return e.complexity.CreatureFaction.Relation(childComplexity), true

	case "CreatureFaction.startDate":
		if e.complexity.CreatureFaction.StartDate == nil {
			break
		}

		return e.complexity.CreatureFaction.StartDate(childComplexity), true

	case "CreatureLocation.creature":
		if e.complexity.CreatureLocation.Creature == nil {
			break
		}

		return e.complexity.CreatureLocation.Creature(childComplexity), true

	case "CreatureLocation.endDate":
		if e.complexity.CreatureLocation.EndDate == nil {
			break
		}

		return e.complexity.CreatureLocation.EndDate(childComplexity), true

	case "CreatureLocation.id":
		if e.complexity.CreatureLocation.ID == nil {
			break
		}

		return e.complexity.CreatureLocation.ID(childComplexity), true

	case "CreatureLocation.location":
		if e.complexity.CreatureLocation.Location == nil {
			break
		}

		return e.complexity.CreatureLocation.Location(childComplexity), true

	case "CreatureLocation.relation":
		if e.complexity.CreatureLocation.Relation == nil {
			break
		}

		return e.complexity.CreatureLocation.Relation(childComplexity), true

	case "CreatureLocation.startDate":
		if e.complexity.CreatureLocation.StartDate == nil {
			break
		}

		return e.complexity.CreatureLocation.StartDate(childComplexity), true

	case "CreatureWorld.creature":
		if e.complexity.CreatureWorld.Creature == nil {
			break
		}

		return e.complexity.CreatureWorld.Creature(childComplexity), true

	case "CreatureWorld.endDate":
		if e.complexity.CreatureWorld.EndDate == nil {
			break
		}

		return e.complexity.CreatureWorld.EndDate(childComplexity), true

	case "CreatureWorld.id":
		if e.complexity.CreatureWorld.ID == nil {
			break
		}

		return e.complexity.CreatureWorld.ID(childComplexity), true

	case "CreatureWorld.relation":
		if e.complexity.CreatureWorld.Relation == nil {
			break
		}

		return e.complexity.CreatureWorld.Relation(childComplexity), true

	case "CreatureWorld.startDate":
		if e.complexity.CreatureWorld.StartDate == nil {
			break
		}

		return e.complexity.CreatureWorld.StartDate(childComplexity), true

	case "CreatureWorld.world":
		if e.complexity.CreatureWorld.World == nil {
			break
		}

		return e.complexity.CreatureWorld.World(childComplexity), true

	case "Event.characters":
		if e.complexity.Event.Characters == nil {
			break
		}

		return e.complexity.Event.Characters(childComplexity), true

	case "Event.createdAt":
		if e.complexity.Event.CreatedAt == nil {
			break
		}

		return e.complexity.Event.CreatedAt(childComplexity), true

	case "Event.creatures":
		if e.complexity.Event.Creatures == nil {
			break
		}

		return e.complexity.Event.Creatures(childComplexity), true

	case "Event.description":
		if e.complexity.Event.Description == nil {
			break
		}

		return e.complexity.Event.Description(childComplexity), true

	case "Event.endDate":
		if e.complexity.Event.EndDate == nil {
			break
		}

		return e.complexity.Event.EndDate(childComplexity), true

	case "Event.factions":
		if e.complexity.Event.Factions == nil {
			break
		}

		return e.complexity.Event.Factions(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.isRecurring":
		if e.complexity.Event.IsRecurring == nil {
			break
		}

		return e.complexity.Event.IsRecurring(childComplexity), true

	case "Event.items":
		if e.complexity.Event.Items == nil {
			break
		}

		return e.complexity.Event.Items(childComplexity), true

	case "Event.locations":
		if e.complexity.Event.Locations == nil {
			break
		}

		return e.complexity.Event.Locations(childComplexity), true

	case "Event.name":
		if e.complexity.Event.Name == nil {
			break
		}

		return e.complexity.Event.Name(childComplexity), true

	case "Event.nature":
		if e.complexity.Event.Nature == nil {
			break
		}

		return e.complexity.Event.Nature(childComplexity), true

	case "Event.relatedEvents":
		if e.complexity.Event.RelatedEvents == nil {
			break
		}

		return e.complexity.Event.RelatedEvents(childComplexity), true

	case "Event.significance":
		if e.complexity.Event.Significance == nil {
			break
		}

		return e.complexity.Event.Significance(childComplexity), true

	case "Event.startDate":
		if e.complexity.Event.StartDate == nil {
			break
		}

		return e.complexity.Event.StartDate(childComplexity), true

	case "Event.type":
		if e.complexity.Event.Type == nil {
			break
		}

		return e.complexity.Event.Type(childComplexity), true

	case "Event.updatedAt":
		if e.complexity.Event.UpdatedAt == nil {
			break
		}

		return e.complexity.Event.UpdatedAt(childComplexity), true

	case "Event.worlds":
		if e.complexity.Event.Worlds == nil {
			break
		}

		return e.complexity.Event.Worlds(childComplexity), true

	case "Faction.characters":
		if e.complexity.Faction.Characters == nil {
			break
		}

		return e.complexity.Faction.Characters(childComplexity), true

	case "Faction.createdAt":
		if e.complexity.Faction.CreatedAt == nil {
			break
		}

		return e.complexity.Faction.CreatedAt(childComplexity), true

	case "Faction.creatures":
		if e.complexity.Faction.Creatures == nil {
			break
		}

		return e.complexity.Faction.Creatures(childComplexity), true

	case "Faction.description":
		if e.complexity.Faction.Description == nil {
			break
		}

		return e.complexity.Faction.Description(childComplexity), true

	case "Faction.disbandedDate":
		if e.complexity.Faction.DisbandedDate == nil {
			break
		}

		return e.complexity.Faction.DisbandedDate(childComplexity), true

	case "Faction.events":
		if e.complexity.Faction.Events == nil {
			break
		}

		return e.complexity.Faction.Events(childComplexity), true

	case "Faction.factions":
		if e.complexity.Faction.Factions == nil {
			break
		}

		return e.complexity.Faction.Factions(childComplexity), true

	case "Faction.foundedDate":
		if e.complexity.Faction.FoundedDate == nil {
			break
		}

		return e.complexity.Faction.FoundedDate(childComplexity), true

	case "Faction.id":
		if e.complexity.Faction.ID == nil {
			break
		}

		return e.complexity.Faction.ID(childComplexity), true

	case "Faction.ideology":
		if e.complexity.Faction.Ideology == nil {
			break
		}

		return e.complexity.Faction.Ideology(childComplexity), true

	case "Faction.influence":
		if e.complexity.Faction.Influence == nil {
			break
		}

		return e.complexity.Faction.Influence(childComplexity), true

	case "Faction.items":
		if e.complexity.Faction.Items == nil {
			break
		}

		return e.complexity.Faction.Items(childComplexity), true

	case "Faction.locations":
		if e.complexity.Faction.Locations == nil {
			break
		}

		return e.complexity.Faction.Locations(childComplexity), true

	case "Faction.name":
		if e.complexity.Faction.Name == nil {
			break
		}

		return e.complexity.Faction.Name(childComplexity), true

	case "Faction.status":
		if e.complexity.Faction.Status == nil {
			break
		}

		return e.complexity.Faction.Status(childComplexity), true

	case "Faction.type":
		if e.complexity.Faction.Type == nil {
			break
		}

		return e.complexity.Faction.Type(childComplexity), true

	case "Faction.updatedAt":
		if e.complexity.Faction.UpdatedAt == nil {
			break
		}

		return e.complexity.Faction.UpdatedAt(childComplexity), true

	case "Faction.worlds":
		if e.complexity.Faction.Worlds == nil {
			break
		}

		return e.complexity.Faction.Worlds(childComplexity), true

	case "FactionEvent.endDate":
		if e.complexity.FactionEvent.EndDate == nil {
			break
		}

		return e.complexity.FactionEvent.EndDate(childComplexity), true

	case "FactionEvent.event":
		if e.complexity.FactionEvent.Event == nil {
			break
		}

		return e.complexity.FactionEvent.Event(childComplexity), true

	case "FactionEvent.faction":
		if e.complexity.FactionEvent.Faction == nil {
			break
		}

		return e.complexity.FactionEvent.Faction(childComplexity), true

	case "FactionEvent.id":
		if e.complexity.FactionEvent.ID == nil {
			break
		}

		return e.complexity.FactionEvent.ID(childComplexity), true

	case "FactionEvent.relation":
		if e.complexity.FactionEvent.Relation == nil {
			break
		}

		return e.complexity.FactionEvent.Relation(childComplexity), true

	case "FactionEvent.startDate":
		if e.complexity.FactionEvent.StartDate == nil {
			break
		}

		return e.complexity.FactionEvent.StartDate(childComplexity), true

	case "FactionFaction.endDate":
		if e.complexity.FactionFaction.EndDate == nil {
			break
		}

		return e.complexity.FactionFaction.EndDate(childComplexity), true

	case "FactionFaction.faction":
		if e.complexity.FactionFaction.Faction == nil {
			break
		}

		return e.complexity.FactionFaction.Faction(childComplexity), true

	case "FactionFaction.id":
		if e.complexity.FactionFaction.ID == nil {
			break
		}

		return e.complexity.FactionFaction.ID(childComplexity), true

	case "FactionFaction.relation":
		if e.complexity.FactionFaction.Relation == nil {
			break
		}

		return e.complexity.FactionFaction.Relation(childComplexity), true

	case "FactionFaction.startDate":
		if e.complexity.FactionFaction.StartDate == nil {
			break
		}

		return e.complexity.FactionFaction.StartDate(childComplexity), true

	case "FactionItem.endDate":
		if e.complexity.FactionItem.EndDate == nil {
			break
		}

		return e.complexity.FactionItem.EndDate(childComplexity), true

	case "FactionItem.faction":
		if e.complexity.FactionItem.Faction == nil {
			break
		}

		return e.complexity.FactionItem.Faction(childComplexity), true

	case "FactionItem.id":
		if e.complexity.FactionItem.ID == nil {
			break
		}

		return e.complexity.FactionItem.ID(childComplexity), true

	case "FactionItem.item":
		if e.complexity.FactionItem.Item == nil {
			break
		}

		return e.complexity.FactionItem.Item(childComplexity), true

	case "FactionItem.relation":
		if e.complexity.FactionItem.Relation == nil {
			break
		}

		return e.complexity.FactionItem.Relation(childComplexity), true

	case "FactionItem.startDate":
		if e.complexity.FactionItem.StartDate == nil {
			break
		}

		return e.complexity.FactionItem.StartDate(childComplexity), true

	case "FactionLocation.endDate":
		if e.complexity.FactionLocation.EndDate == nil {
			break
		}

		return e.complexity.FactionLocation.EndDate(childComplexity), true

	case "FactionLocation.faction":
		if e.complexity.FactionLocation.Faction == nil {
			break
		}

		return e.complexity.FactionLocation.Faction(childComplexity), true

	case "FactionLocation.id":
		if e.complexity.FactionLocation.ID == nil {
			break
		}

		return e.complexity.FactionLocation.ID(childComplexity), true

	case "FactionLocation.location":
		if e.complexity.FactionLocation.Location == nil {
			break
		}

		return e.complexity.FactionLocation.Location(childComplexity), true

	case "FactionLocation.relation":
		if e.complexity.FactionLocation.Relation == nil {
			break
		}

		return e.complexity.FactionLocation.Relation(childComplexity), true

	case "FactionLocation.startDate":
		if e.complexity.FactionLocation.StartDate == nil {
			break
		}

		return e.complexity.FactionLocation.StartDate(childComplexity), true

	case "FactionWorld.endDate":
		if e.complexity.FactionWorld.EndDate == nil {
			break
		}

		return e.complexity.FactionWorld.EndDate(childComplexity), true

	case "FactionWorld.faction":
		if e.complexity.FactionWorld.Faction == nil {
			break
		}

		return e.complexity.FactionWorld.Faction(childComplexity), true

	case "FactionWorld.id":
		if e.complexity.FactionWorld.ID == nil {
			break
		}

		return e.complexity.FactionWorld.ID(childComplexity), true

	case "FactionWorld.relation":
		if e.complexity.FactionWorld.Relation == nil {
			break
		}

		return e.complexity.FactionWorld.Relation(childComplexity), true

	case "FactionWorld.startDate":
		if e.complexity.FactionWorld.StartDate == nil {
			break
		}

		return e.complexity.FactionWorld.StartDate(childComplexity), true

	case "FactionWorld.world":
		if e.complexity.FactionWorld.World == nil {
			break
		}

		return e.complexity.FactionWorld.World(childComplexity), true

	case "Item.abilities":
		if e.complexity.Item.Abilities == nil {
			break
		}

		return e.complexity.Item.Abilities(childComplexity), true

	case "Item.characters":
		if e.complexity.Item.Characters == nil {
			break
		}

		return e.complexity.Item.Characters(childComplexity), true

	case "Item.condition":
		if e.complexity.Item.Condition == nil {
			break
		}

		return e.complexity.Item.Condition(childComplexity), true

	case "Item.createdAt":
		if e.complexity.Item.CreatedAt == nil {
			break
		}

		return e.complexity.Item.CreatedAt(childComplexity), true

	case "Item.creationDate":
		if e.complexity.Item.CreationDate == nil {
			break
		}

		return e.complexity.Item.CreationDate(childComplexity), true

	case "Item.description":
		if e.complexity.Item.Description == nil {
			break
		}

		return e.complexity.Item.Description(childComplexity), true

	case "Item.destructionDate":
		if e.complexity.Item.DestructionDate == nil {
			break
		}

		return e.complexity.Item.DestructionDate(childComplexity), true

	case "Item.dimensions":
		if e.complexity.Item.Dimensions == nil {
			break
		}

		return e.complexity.Item.Dimensions(childComplexity), true

	case "Item.events":
		if e.complexity.Item.Events == nil {
			break
		}

		return e.complexity.Item.Events(childComplexity), true

	case "Item.factions":
		if e.complexity.Item.Factions == nil {
			break
		}

		return e.complexity.Item.Factions(childComplexity), true

	case "Item.id":
		if e.complexity.Item.ID == nil {
			break
		}

		return e.complexity.Item.ID(childComplexity), true

	case "Item.isMagical":
		if e.complexity.Item.IsMagical == nil {
			break
		}

		return e.complexity.Item.IsMagical(childComplexity), true

	case "Item.locations":
		if e.complexity.Item.Locations == nil {
			break
		}

		return e.complexity.Item.Locations(childComplexity), true

	case "Item.material":
		if e.complexity.Item.Material == nil {
			break
		}

		return e.complexity.Item.Material(childComplexity), true

	case "Item.name":
		if e.complexity.Item.Name == nil {
			break
		}

		return e.complexity.Item.Name(childComplexity), true

	case "Item.rarity":
		if e.complexity.Item.Rarity == nil {
			break
		}

		return e.complexity.Item.Rarity(childComplexity), true

	case "Item.relatedItems":
		if e.complexity.Item.RelatedItems == nil {
			break
		}

		return e.complexity.Item.RelatedItems(childComplexity), true

	case "Item.slot":
		if e.complexity.Item.Slot == nil {
			break
		}

		return e.complexity.Item.Slot(childComplexity), true

	case "Item.type":
		if e.complexity.Item.Type == nil {
			break
		}

		return e.complexity.Item.Type(childComplexity), true

	case "Item.updatedAt":
		if e.complexity.Item.UpdatedAt == nil {
			break
		}

		return e.complexity.Item.UpdatedAt(childComplexity), true

	case "Item.value":
		if e.complexity.Item.Value == nil {
			break
		}

		return e.complexity.Item.Value(childComplexity), true

	case "Item.weight":
		if e.complexity.Item.Weight == nil {
			break
		}

		return e.complexity.Item.Weight(childComplexity), true

	case "ItemEvent.endDate":
		if e.complexity.ItemEvent.EndDate == nil {
			break
		}

		return e.complexity.ItemEvent.EndDate(childComplexity), true

	case "ItemEvent.event":
		if e.complexity.ItemEvent.Event == nil {
			break
		}

		return e.complexity.ItemEvent.Event(childComplexity), true

	case "ItemEvent.id":
		if e.complexity.ItemEvent.ID == nil {
			break
		}

		return e.complexity.ItemEvent.ID(childComplexity), true

	case "ItemEvent.item":
		if e.complexity.ItemEvent.Item == nil {
			break
		}

		return e.complexity.ItemEvent.Item(childComplexity), true

	case "ItemEvent.relation":
		if e.complexity.ItemEvent.Relation == nil {
			break
		}

		return e.complexity.ItemEvent.Relation(childComplexity), true

	case "ItemEvent.startDate":
		if e.complexity.ItemEvent.StartDate == nil {
			break
		}

		return e.complexity.ItemEvent.StartDate(childComplexity), true

	case "ItemItem.endDate":
		if e.complexity.ItemItem.EndDate == nil {
			break
		}

		return e.complexity.ItemItem.EndDate(childComplexity), true

	case "ItemItem.id":
		if e.complexity.ItemItem.ID == nil {
			break
		}

		return e.complexity.ItemItem.ID(childComplexity), true

	case "ItemItem.item":
		if e.complexity.ItemItem.Item == nil {
			break
		}

		return e.complexity.ItemItem.Item(childComplexity), true

	case "ItemItem.relation":
		if e.complexity.ItemItem.Relation == nil {
			break
		}

		return e.complexity.ItemItem.Relation(childComplexity), true

	case "ItemItem.startDate":
		if e.complexity.ItemItem.StartDate == nil {
			break
		}

		return e.complexity.ItemItem.StartDate(childComplexity), true

	case "ItemLocation.endDate":
		if e.complexity.ItemLocation.EndDate == nil {
			break
		}

		return e.complexity.ItemLocation.EndDate(childComplexity), true

	case "ItemLocation.id":
		if e.complexity.ItemLocation.ID == nil {
			break
		}

		return e.complexity.ItemLocation.ID(childComplexity), true

	case "ItemLocation.item":
		if e.complexity.ItemLocation.Item == nil {
			break
		}

		return e.complexity.ItemLocation.Item(childComplexity), true

	case "ItemLocation.relation":
		if e.complexity.ItemLocation.Relation == nil {
			break
		}

		return e.complexity.ItemLocation.Relation(childComplexity), true

	case "ItemLocation.startDate":
		if e.complexity.ItemLocation.StartDate == nil {
			break
		}

		return e.complexity.ItemLocation.StartDate(childComplexity), true

	case "ItemLocation.with":
		if e.complexity.ItemLocation.With == nil {
			break
		}

		return e.complexity.ItemLocation.With(childComplexity), true

	case "Location.accessibility":
		if e.complexity.Location.Accessibility == nil {
			break
		}

		return e.complexity.Location.Accessibility(childComplexity), true

	case "Location.characters":
		if e.complexity.Location.Characters == nil {
			break
		}

		return e.complexity.Location.Characters(childComplexity), true

	case "Location.climate":
		if e.complexity.Location.Climate == nil {
			break
		}

		return e.complexity.Location.Climate(childComplexity), true

	case "Location.coordinates":
		if e.complexity.Location.Coordinates == nil {
			break
		}

		return e.complexity.Location.Coordinates(childComplexity), true

	case "Location.createdAt":
		if e.complexity.Location.CreatedAt == nil {
			break
		}

		return e.complexity.Location.CreatedAt(childComplexity), true

	case "Location.creatures":
		if e.complexity.Location.Creatures == nil {
			break
		}

		return e.complexity.Location.Creatures(childComplexity), true

	case "Location.description":
		if e.complexity.Location.Description == nil {
			break
		}

		return e.complexity.Location.Description(childComplexity), true

	case "Location.ecosystem":
		if e.complexity.Location.Ecosystem == nil {
			break
		}

		return e.complexity.Location.Ecosystem(childComplexity), true

	case "Location.events":
		if e.complexity.Location.Events == nil {
			break
		}

		return e.complexity.Location.Events(childComplexity), true

	case "Location.factions":
		if e.complexity.Location.Factions == nil {
			break
		}

		return e.complexity.Location.Factions(childComplexity), true

	case "Location.id":
		if e.complexity.Location.ID == nil {
			break
		}

		return e.complexity.Location.ID(childComplexity), true

	case "Location.isNatural":
		if e.complexity.Location.IsNatural == nil {
			break
		}

		return e.complexity.Location.IsNatural(childComplexity), true

	case "Location.items":
		if e.complexity.Location.Items == nil {
			break
		}

		return e.complexity.Location.Items(childComplexity), true

	case "Location.name":
		if e.complexity.Location.Name == nil {
			break
		}

		return e.complexity.Location.Name(childComplexity), true

	case "Location.region":
		if e.complexity.Location.Region == nil {
			break
		}

		return e.complexity.Location.Region(childComplexity), true

	case "Location.relatedLocations":
		if e.complexity.Location.RelatedLocations == nil {
			break
		}

		return e.complexity.Location.RelatedLocations(childComplexity), true

	case "Location.type":
		if e.complexity.Location.Type == nil {
			break
		}

		return e.complexity.Location.Type(childComplexity), true

	case "Location.updatedAt":
		if e.complexity.Location.UpdatedAt == nil {
			break
		}

		return e.complexity.Location.UpdatedAt(childComplexity), true

	case "Location.worlds":
		if e.complexity.Location.Worlds == nil {
			break
		}

		return e.complexity.Location.Worlds(childComplexity), true

	case "LocationEvent.endDate":
		if e.complexity.LocationEvent.EndDate == nil {
			break
		}

		return e.complexity.LocationEvent.EndDate(childComplexity), true

	case "LocationEvent.event":
		if e.complexity.LocationEvent.Event == nil {
			break
		}

		return e.complexity.LocationEvent.Event(childComplexity), true

	case "LocationEvent.id":
		if e.complexity.LocationEvent.ID == nil {
			break
		}

		return e.complexity.LocationEvent.ID(childComplexity), true

	case "LocationEvent.location":
		if e.complexity.LocationEvent.Location == nil {
			break
		}

		return e.complexity.LocationEvent.Location(childComplexity), true

	case "LocationEvent.relation":
		if e.complexity.LocationEvent.Relation == nil {
			break
		}

		return e.complexity.LocationEvent.Relation(childComplexity), true

	case "LocationEvent.startDate":
		if e.complexity.LocationEvent.StartDate == nil {
			break
		}

		return e.complexity.LocationEvent.StartDate(childComplexity), true

	case "LocationLocation.endDate":
		if e.complexity.LocationLocation.EndDate == nil {
			break
		}

		return e.complexity.LocationLocation.EndDate(childComplexity), true

	case "LocationLocation.id":
		if e.complexity.LocationLocation.ID == nil {
			break
		}

		return e.complexity.LocationLocation.ID(childComplexity), true

	case "LocationLocation.location":
		if e.complexity.LocationLocation.Location == nil {
			break
		}

		return e.complexity.LocationLocation.Location(childComplexity), true

	case "LocationLocation.relation":
		if e.complexity.LocationLocation.Relation == nil {
			break
		}

		return e.complexity.LocationLocation.Relation(childComplexity), true

	case "LocationLocation.startDate":
		if e.complexity.LocationLocation.StartDate == nil {
			break
		}

		return e.complexity.LocationLocation.StartDate(childComplexity), true

	case "LocationWorld.endDate":
		if e.complexity.LocationWorld.EndDate == nil {
			break
		}

		return e.complexity.LocationWorld.EndDate(childComplexity), true

	case "LocationWorld.id":
		if e.complexity.LocationWorld.ID == nil {
			break
		}

		return e.complexity.LocationWorld.ID(childComplexity), true

	case "LocationWorld.location":
		if e.complexity.LocationWorld.Location == nil {
			break
		}

		return e.complexity.LocationWorld.Location(childComplexity), true

	case "LocationWorld.relation":
		if e.complexity.LocationWorld.Relation == nil {
			break
		}

		return e.complexity.LocationWorld.Relation(childComplexity), true

	case "LocationWorld.startDate":
		if e.complexity.LocationWorld.StartDate == nil {
			break
		}

		return e.complexity.LocationWorld.StartDate(childComplexity), true

	case "LocationWorld.world":
		if e.complexity.LocationWorld.World == nil {
			break
		}

		return e.complexity.LocationWorld.World(childComplexity), true

	case "Mutation.createCharacter":
		if e.complexity.Mutation.CreateCharacter == nil {
			break
		}

		args, err := ec.field_Mutation_createCharacter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCharacter(childComplexity, args["input"].(model.CreateCharacterInput)), true

	case "Mutation.createCreature":
		if e.complexity.Mutation.CreateCreature == nil {
			break
		}

		args, err := ec.field_Mutation_createCreature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCreature(childComplexity, args["input"].(model.CreateCreatureInput)), true

	case "Mutation.createEvent":
		if e.complexity.Mutation.CreateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_createEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEvent(childComplexity, args["input"].(model.CreateEventInput)), true

	case "Mutation.createFaction":
		if e.complexity.Mutation.CreateFaction == nil {
			break
		}

		args, err := ec.field_Mutation_createFaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFaction(childComplexity, args["input"].(model.CreateFactionInput)), true

	case "Mutation.createItem":
		if e.complexity.Mutation.CreateItem == nil {
			break
		}

		args, err := ec.field_Mutation_createItem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateItem(childComplexity, args["input"].(model.CreateItemInput)), true

	case "Mutation.createLocation":
		if e.complexity.Mutation.CreateLocation == nil {
			break
		}

		args, err := ec.field_Mutation_createLocation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLocation(childComplexity, args["input"].(model.CreateLocationInput)), true

	case "Mutation.createUniverse":
		if e.complexity.Mutation.CreateUniverse == nil {
			break
		}

		args, err := ec.field_Mutation_createUniverse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUniverse(childComplexity, args["input"].(model.CreateUniverseInput)), true

	case "Mutation.createWorld":
		if e.complexity.Mutation.CreateWorld == nil {
			break
		}

		args, err := ec.field_Mutation_createWorld_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateWorld(childComplexity, args["input"].(model.CreateWorldInput)), true

	case "Mutation.deleteCharacter":
		if e.complexity.Mutation.DeleteCharacter == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCharacter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCharacter(childComplexity, args["id"].(string)), true

	case "Mutation.deleteCreature":
		if e.complexity.Mutation.DeleteCreature == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCreature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCreature(childComplexity, args["id"].(string)), true

	case "Mutation.deleteEvent":
		if e.complexity.Mutation.DeleteEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEvent(childComplexity, args["id"].(string)), true

	case "Mutation.deleteFaction":
		if e.complexity.Mutation.DeleteFaction == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFaction(childComplexity, args["id"].(string)), true

	case "Mutation.deleteItem":
		if e.complexity.Mutation.DeleteItem == nil {
			break
		}

		args, err := ec.field_Mutation_deleteItem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteItem(childComplexity, args["id"].(string)), true

	case "Mutation.deleteLocation":
		if e.complexity.Mutation.DeleteLocation == nil {
			break
		}

		args, err := ec.field_Mutation_deleteLocation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteLocation(childComplexity, args["id"].(string)), true

	case "Mutation.deleteUniverse":
		if e.complexity.Mutation.DeleteUniverse == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUniverse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUniverse(childComplexity, args["id"].(string)), true

	case "Mutation.deleteWorld":
		if e.complexity.Mutation.DeleteWorld == nil {
			break
		}

		args, err := ec.field_Mutation_deleteWorld_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteWorld(childComplexity, args["id"].(string)), true

	case "Mutation.updateCharacter":
		if e.complexity.Mutation.UpdateCharacter == nil {
			break
		}

		args, err := ec.field_Mutation_updateCharacter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCharacter(childComplexity, args["input"].(model.UpdateCharacterInput)), true

	case "Mutation.updateCreature":
		if e.complexity.Mutation.UpdateCreature == nil {
			break
		}

		args, err := ec.field_Mutation_updateCreature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCreature(childComplexity, args["input"].(model.UpdateCreatureInput)), true

	case "Mutation.updateEvent":
		if e.complexity.Mutation.UpdateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEvent(childComplexity, args["input"].(model.UpdateEventInput)), true

	case "Mutation.updateFaction":
		if e.complexity.Mutation.UpdateFaction == nil {
			break
		}

		args, err := ec.field_Mutation_updateFaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFaction(childComplexity, args["input"].(model.UpdateFactionInput)), true

	case "Mutation.updateItem":
		if e.complexity.Mutation.UpdateItem == nil {
			break
		}

		args, err := ec.field_Mutation_updateItem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateItem(childComplexity, args["input"].(model.UpdateItemInput)), true

	case "Mutation.updateLocation":
		if e.complexity.Mutation.UpdateLocation == nil {
			break
		}

		args, err := ec.field_Mutation_updateLocation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLocation(childComplexity, args["input"].(model.UpdateLocationInput)), true

	case "Mutation.updateUniverse":
		if e.complexity.Mutation.UpdateUniverse == nil {
			break
		}

		args, err := ec.field_Mutation_updateUniverse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUniverse(childComplexity, args["input"].(model.UpdateUniverseInput)), true

	case "Mutation.updateWorld":
		if e.complexity.Mutation.UpdateWorld == nil {
			break
		}

		args, err := ec.field_Mutation_updateWorld_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateWorld(childComplexity, args["input"].(model.UpdateWorldInput)), true

	case "Query.character":
		if e.complexity.Query.Character == nil {
			break
		}

		args, err := ec.field_Query_character_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Character(childComplexity, args["id"].(string)), true

	case "Query.characters":
		if e.complexity.Query.Characters == nil {
			break
		}

		args, err := ec.field_Query_characters_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Characters(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.creature":
		if e.complexity.Query.Creature == nil {
			break
		}

		args, err := ec.field_Query_creature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Creature(childComplexity, args["id"].(string)), true

	case "Query.creatures":
		if e.complexity.Query.Creatures == nil {
			break
		}

		args, err := ec.field_Query_creatures_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Creatures(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.event":
		if e.complexity.Query.Event == nil {
			break
		}

		args, err := ec.field_Query_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Event(childComplexity, args["id"].(string)), true

	case "Query.events":
		if e.complexity.Query.Events == nil {
			break
		}

		args, err := ec.field_Query_events_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Events(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.faction":
		if e.complexity.Query.Faction == nil {
			break
		}

		args, err := ec.field_Query_faction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Faction(childComplexity, args["id"].(string)), true

	case "Query.factions":
		if e.complexity.Query.Factions == nil {
			break
		}

		args, err := ec.field_Query_factions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Factions(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.item":
		if e.complexity.Query.Item == nil {
			break
		}

		args, err := ec.field_Query_item_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Item(childComplexity, args["id"].(string)), true

	case "Query.items":
		if e.complexity.Query.Items == nil {
			break
		}

		args, err := ec.field_Query_items_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Items(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.location":
		if e.complexity.Query.Location == nil {
			break
		}

		args, err := ec.field_Query_location_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Location(childComplexity, args["id"].(string)), true

	case "Query.locations":
		if e.complexity.Query.Locations == nil {
			break
		}

		args, err := ec.field_Query_locations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Locations(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.universe":
		if e.complexity.Query.Universe == nil {
			break
		}

		args, err := ec.field_Query_universe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Universe(childComplexity, args["id"].(string)), true

	case "Query.universes":
		if e.complexity.Query.Universes == nil {
			break
		}

		args, err := ec.field_Query_universes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Universes(childComplexity, args["limit"].(*int), args["offset"].(*int)), true

	case "Query.world":
		if e.complexity.Query.World == nil {
			break
		}

		args, err := ec.field_Query_world_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.World(childComplexity, args["id"].(string)), true

	case "Query.worlds":
		if e.complexity.Query.Worlds == nil {
			break
		}

		args, err := ec.field_Query_worlds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Worlds(childComplexity, args["universeId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Response.message":
		if e.complexity.Response.Message == nil {
			break
		}

		return e.complexity.Response.Message(childComplexity), true

	case "Response.status":
		if e.complexity.Response.Status == nil {
			break
		}

		return e.complexity.Response.Status(childComplexity), true

	case "Universe.characters":
		if e.complexity.Universe.Characters == nil {
			break
		}

		return e.complexity.Universe.Characters(childComplexity), true

	case "Universe.createdAt":
		if e.complexity.Universe.CreatedAt == nil {
			break
		}

		return e.complexity.Universe.CreatedAt(childComplexity), true

	case "Universe.creatures":
		if e.complexity.Universe.Creatures == nil {
			break
		}

		return e.complexity.Universe.Creatures(childComplexity), true

	case "Universe.description":
		if e.complexity.Universe.Description == nil {
			break
		}

		return e.complexity.Universe.Description(childComplexity), true

	case "Universe.events":
		if e.complexity.Universe.Events == nil {
			break
		}

		return e.complexity.Universe.Events(childComplexity), true

	case "Universe.factions":
		if e.complexity.Universe.Factions == nil {
			break
		}

		return e.complexity.Universe.Factions(childComplexity), true

	case "Universe.id":
		if e.complexity.Universe.ID == nil {
			break
		}

		return e.complexity.Universe.ID(childComplexity), true

	case "Universe.isActive":
		if e.complexity.Universe.IsActive == nil {
			break
		}

		return e.complexity.Universe.IsActive(childComplexity), true

	case "Universe.items":
		if e.complexity.Universe.Items == nil {
			break
		}

		return e.complexity.Universe.Items(childComplexity), true

	case "Universe.locations":
		if e.complexity.Universe.Locations == nil {
			break
		}

		return e.complexity.Universe.Locations(childComplexity), true

	case "Universe.name":
		if e.complexity.Universe.Name == nil {
			break
		}

		return e.complexity.Universe.Name(childComplexity), true

	case "Universe.startYear":
		if e.complexity.Universe.StartYear == nil {
			break
		}

		return e.complexity.Universe.StartYear(childComplexity), true

	case "Universe.updatedAt":
		if e.complexity.Universe.UpdatedAt == nil {
			break
		}

		return e.complexity.Universe.UpdatedAt(childComplexity), true

	case "Universe.worlds":
		if e.complexity.Universe.Worlds == nil {
			break
		}

		return e.complexity.Universe.Worlds(childComplexity), true

	case "World.characters":
		if e.complexity.World.Characters == nil {
			break
		}

		return e.complexity.World.Characters(childComplexity), true

	case "World.climate":
		if e.complexity.World.Climate == nil {
			break
		}

		return e.complexity.World.Climate(childComplexity), true

	case "World.connectedWorlds":
		if e.complexity.World.ConnectedWorlds == nil {
			break
		}

		return e.complexity.World.ConnectedWorlds(childComplexity), true

	case "World.createdAt":
		if e.complexity.World.CreatedAt == nil {
			break
		}

		return e.complexity.World.CreatedAt(childComplexity), true

	case "World.creatures":
		if e.complexity.World.Creatures == nil {
			break
		}

		return e.complexity.World.Creatures(childComplexity), true

	case "World.description":
		if e.complexity.World.Description == nil {
			break
		}

		return e.complexity.World.Description(childComplexity), true

	case "World.ecosystem":
		if e.complexity.World.Ecosystem == nil {
			break
		}

		return e.complexity.World.Ecosystem(childComplexity), true

	case "World.energySources":
		if e.complexity.World.EnergySources == nil {
			break
		}

		return e.complexity.World.EnergySources(childComplexity), true

	case "World.events":
		if e.complexity.World.Events == nil {
			break
		}

		return e.complexity.World.Events(childComplexity), true

	case "World.factions":
		if e.complexity.World.Factions == nil {
			break
		}

		return e.complexity.World.Factions(childComplexity), true

	case "World.gravity":
		if e.complexity.World.Gravity == nil {
			break
		}

		return e.complexity.World.Gravity(childComplexity), true

	case "World.hasAtmosphere":
		if e.complexity.World.HasAtmosphere == nil {
			break
		}

		return e.complexity.World.HasAtmosphere(childComplexity), true

	case "World.id":
		if e.complexity.World.ID == nil {
			break
		}

		return e.complexity.World.ID(childComplexity), true

	case "World.isHabitable":
		if e.complexity.World.IsHabitable == nil {
			break
		}

		return e.complexity.World.IsHabitable(childComplexity), true

	case "World.locations":
		if e.complexity.World.Locations == nil {
			break
		}

		return e.complexity.World.Locations(childComplexity), true

	case "World.moons":
		if e.complexity.World.Moons == nil {
			break
		}

		return e.complexity.World.Moons(childComplexity), true

	case "World.name":
		if e.complexity.World.Name == nil {
			break
		}

		return e.complexity.World.Name(childComplexity), true

	case "World.size":
		if e.complexity.World.Size == nil {
			break
		}

		return e.complexity.World.Size(childComplexity), true

	case "World.stars":
		if e.complexity.World.Stars == nil {
			break
		}

		return e.complexity.World.Stars(childComplexity), true

	case "World.technologyLevel":
		if e.complexity.World.TechnologyLevel == nil {
			break
		}

		return e.complexity.World.TechnologyLevel(childComplexity), true

	case "World.type":
		if e.complexity.World.Type == nil {
			break
		}

		return e.complexity.World.Type(childComplexity), true

	case "World.universe":
		if e.complexity.World.Universe == nil {
			break
		}

		return e.complexity.World.Universe(childComplexity), true

	case "World.updatedAt":
		if e.complexity.World.UpdatedAt == nil {
			break
		}

		return e.complexity.World.UpdatedAt(childComplexity), true

	case "WorldEvent.endDate":
		if e.complexity.WorldEvent.EndDate == nil {
			break
		}

		return e.complexity.WorldEvent.EndDate(childComplexity), true

	case "WorldEvent.event":
		if e.complexity.WorldEvent.Event == nil {
			break
		}

		return e.complexity.WorldEvent.Event(childComplexity), true

	case "WorldEvent.id":
		if e.complexity.WorldEvent.ID == nil {
			break
		}

		return e.complexity.WorldEvent.ID(childComplexity), true

	case "WorldEvent.relation":
		if e.complexity.WorldEvent.Relation == nil {
			break
		}

		return e.complexity.WorldEvent.Relation(childComplexity), true

	case "WorldEvent.startDate":
		if e.complexity.WorldEvent.StartDate == nil {
			break
		}

		return e.complexity.WorldEvent.StartDate(childComplexity), true

	case "WorldEvent.world":
		if e.complexity.WorldEvent.World == nil {
			break
		}

		return e.complexity.WorldEvent.World(childComplexity), true

	case "WorldWorld.endDate":
		if e.complexity.WorldWorld.EndDate == nil {
			break
		}

		return e.complexity.WorldWorld.EndDate(childComplexity), true

	case "WorldWorld.id":
		if e.complexity.WorldWorld.ID == nil {
			break
		}

		return e.complexity.WorldWorld.ID(childComplexity), true

	case "WorldWorld.relation":
		if e.complexity.WorldWorld.Relation == nil {
			break
		}

		return e.complexity.WorldWorld.Relation(childComplexity), true

	case "WorldWorld.startDate":
		if e.complexity.WorldWorld.StartDate == nil {
			break
		}

		return e.complexity.WorldWorld.StartDate(childComplexity), true

	case "WorldWorld.world":
		if e.complexity.WorldWorld.World == nil {
			break
		}

		return e.complexity.WorldWorld.World(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateCharacterInput,
		ec.unmarshalInputCreateCreatureInput,
		ec.unmarshalInputCreateEventInput,
		ec.unmarshalInputCreateFactionInput,
		ec.unmarshalInputCreateItemInput,
		ec.unmarshalInputCreateLocationInput,
		ec.unmarshalInputCreateUniverseInput,
		ec.unmarshalInputCreateWorldInput,
		ec.unmarshalInputUpdateCharacterInput,
		ec.unmarshalInputUpdateCreatureInput,
		ec.unmarshalInputUpdateEventInput,
		ec.unmarshalInputUpdateFactionInput,
		ec.unmarshalInputUpdateItemInput,
		ec.unmarshalInputUpdateLocationInput,
		ec.unmarshalInputUpdateUniverseInput,
		ec.unmarshalInputUpdateWorldInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../graphql/Character/enum.graphqls", Input: `"""
Representa el nivel de relacin entre dos personajes.
Incluye relaciones de amistad, rivalidad, mentora, familia y jerarqua profesional.
"""
enum CharacterRelationLevel {
    # Relaciones de enemistad y rivalidad
    """
    Relacin de enemistad extrema o de larga duracin. Oponentes acrrimos con un conflicto prolongado.
    """
    ARCHENEMY

    """
    Oposicin activa con conflictos frecuentes y hostilidad evidente.
    """
    ENEMY

    """
    Competencia recurrente sin llegar al odio extremo. Puede incluir rivalidad deportiva, profesional o personal.
    """
    RIVAL

    # Relaciones neutrales y superficiales
    """
    Relacin sin una inclinacin fuerte. Desconocidos o con interacciones superficiales sin impacto significativo.
    """
    NEUTRAL

    """
    Conocidos casuales, sin una conexin profunda. Se han cruzado en el pasado pero no tienen una relacin establecida.
    """
    ACQUAINTANCE

    # Relaciones de amistad
    """
    Amistad cercana o alianza de confianza. Relacin basada en apoyo mutuo y cooperacin.
    """
    FRIEND

    """
    Amistad extremadamente fuerte, cercana al concepto de familia. Puede incluir lazos de hermandad sin ser de sangre.
    """
    BEST_FRIEND

    # Relaciones de mentora y aprendizaje
    """
    Relacin maestro-alumno o de enseanza. Un personaje gua al otro en su desarrollo personal o profesional.
    """
    MENTOR

    """
    Recproco del mentor: el protegido o aprendiz que recibe conocimiento, entrenamiento o apoyo de un mentor.
    """
    PROTEGE

    # Relaciones romnticas y familiares
    """
    Relacin amorosa en cualquier etapa inicial. Puede ser un inters romntico, enamoramiento o relacin incipiente.
    """
    ROMANTIC

    """
    Relacin romntica establecida. Puede incluir parejas casadas, comprometidas o con un vnculo consolidado.
    """
    PARTNER

    """
    Relacin de parentesco, ya sea por sangre o adopcin. Incluye lazos familiares directos o extendidos.
    """
    FAMILY

    """
    Amor no correspondido. Un personaje siente afecto por otro, pero este no le responde de la misma manera.
    """
    UNREQUITED

    """
    Amistad rota por eventos pasados. Dos personajes que fueron amigos pero cuya relacin se ha deteriorado o ha terminado.
    """
    FORMER_FRIEND

    """
    Relacin amorosa que termin, pero cuyo impacto sigue presente en la historia o en la dinmica entre personajes.
    """
    FORMER_LOVER

    # Relaciones de jerarqua y organizacin
    """
    Asociacin basada en un inters comn, sin necesidad de amistad. Puede incluir alianzas temporales o estratgicas.
    """
    ALLY

    """
    Miembros de la misma organizacin, grupo o faccin. Comparten una afiliacin en un contexto militar, poltico, religioso o social.
    """
    FACTION_MEMBER

    """
    Relacin de autoridad en la que un personaje tiene poder sobre otro. Puede representar jefe-subordinado o lder-miembro.
    """
    SUPERIOR

    """
    Relacin inversa de autoridad: el personaje es subordinado o est bajo las rdenes de otro.
    """
    SUBORDINATE
}

"""
Representa relaciones familiares entre personajes, incluyendo parentescos directos e indirectos.
Distingue entre lazos de sangre, adopcin y vnculos familiares extendidos.
"""
enum FamilyRelation {
    # Relacin familiar directa

    """
    Padre o madre biolgico/a del personaje.
    """
    PARENT

    """
    Hijo o hija biolgico/a del personaje.
    """
    CHILD

    """
    Hermano o hermana del personaje, comparten al menos uno de los padres.
    """
    SIBLING

    """
    Abuelo o abuela del personaje, ascendencia dos generaciones atrs.
    """
    GRANDPARENT

    """
    Nieto o nieta del personaje, descendencia dos generaciones adelante.
    """
    GRANDCHILD

    # Familia extendida

    """
    To o ta del personaje, hermano/a del padre o la madre.
    """
    UNCLE_AUNT

    """
    Sobrino o sobrina del personaje, hijo/a de un hermano o hermana.
    """
    NEPHEW_NIECE

    """
    Primo o prima del personaje, hijo/a de los tos o tas.
    """
    COUSIN

    # Relaciones conyugales

    """
    Esposo o esposa del personaje, relacin legalmente reconocida o establecida romnticamente.
    """
    SPOUSE

    """
    Exesposo/a del personaje. Relacin con lazos matrimoniales que han sido disueltos.
    """
    EX_SPOUSE

    # Relaciones familiares no biolgicas

    """
    Padrastro o madrastra del personaje. Relacin por matrimonio con uno de los padres del personaje.
    """
    STEP_PARENT

    """
    Hijastro o hijastra del personaje. Hijo/a de su pareja en una relacin previa.
    """
    STEP_CHILD

    """
    Medio hermano/a del personaje. Comparten solo uno de los padres.
    """
    HALF_SIBLING

    """
    Padre o madre adoptivo/a del personaje. Relacin establecida legalmente sin lazo de sangre.
    """
    ADOPTIVE_PARENT

    """
    Hijo o hija adoptivo/a del personaje. Relacin establecida legalmente sin lazo de sangre.
    """
    ADOPTIVE_CHILD

    # Relaciones de tutela

    """
    Tutor legal del personaje. Puede ser una figura parental, un mentor o protector.
    """
    GUARDIAN

    """
    Menor bajo tutela legal de otro personaje. No es necesariamente hijo adoptivo.
    """
    WARD
}

"""
Define el tipo de relacin que un personaje puede tener con una criatura.
Estos valores se usan para modelar interacciones en el mundo ficticio.
"""
enum CharacterCreatureRelation {
    # Relaciones de propiedad y domesticacin

    """
    El personaje es dueo de la criatura (mascota, montura, familiar).
    """
    OWNER

    """
    El personaje est intentando domesticar la criatura, pero an no tiene xito.
    """
    TAME_ATTEMPT

    """
    La criatura ha sido domesticada con xito y obedece al personaje.
    """
    TAMED

    """
    La criatura protege o vigila al personaje (lobo guardin, glem, etc.).
    """
    GUARDIAN

    # Relaciones de combate y caza

    """
    La criatura y el personaje son compaeros, pero sin una relacin de propiedad.
    """
    COMPANION

    """
    El personaje y la criatura cazan juntos como aliados.
    """
    HUNTING_PARTNER

    """
    El personaje caza activamente a la criatura.
    """
    HUNTED

    """
    La criatura es hostil hacia el personaje y lo ataca al verlo.
    """
    ENEMY

    # Relaciones mgicas y sobrenaturales

    """
    El personaje venera a la criatura como una entidad divina.
    """
    WORSHIPS

    """
    La criatura es una manifestacin de un dios o entidad superior.
    """
    DEITY_AVATAR

    """
    El personaje invoc a la criatura con un ritual (demonios, elementales, etc.).
    """
    SUMMONED

    """
    La criatura y el personaje estn fusionados por un vnculo sobrenatural.
    """
    FUSED

    """
    La criatura fue creada a partir de una maldicin lanzada por el personaje.
    """
    CURSED

    # Relaciones de utilidad y transporte

    """
    El personaje monta a la criatura como un medio de transporte (caballo, dragn).
    """
    RIDES

    """
    La criatura es un experimento creado por el personaje (quimera, mutacin).
    """
    EXPERIMENT
}

"""
Define la relacin que un personaje puede tener con un evento en el mundo ficticio.
Incluye participacin directa, testimonio, organizacin, influencia y otras interacciones posibles.
"""
enum CharacterEventRelation {
    # Roles activos en el evento

    """
    El personaje fue el principal responsable del evento. Puede ser el iniciador, el lder o el causante del suceso.
    """
    INITIATOR

    """
    El personaje particip activamente en el evento como protagonista o actor clave.
    """
    PARTICIPANT

    """
    El personaje organiz el evento, pero no particip directamente en su desarrollo.
    """
    ORGANIZER

    # Roles pasivos o circunstanciales

    """
    El personaje fue testigo del evento sin intervenir activamente.
    """
    WITNESS

    """
    El personaje fue afectado por el evento, ya sea de manera positiva o negativa, pero sin participacin directa.
    """
    AFFECTED

    """
    El personaje influy en el evento de alguna manera indirecta, sin estar presente.
    """
    INFLUENCER

    # Respuestas al evento

    """
    El personaje intent detener el evento o evitar que sucediera.
    """
    OPPOSER

    """
    El personaje investig o estudi el evento despus de que ocurriera, sin haber estado presente en el momento.
    """
    INVESTIGATOR

    """
    El personaje se enter del evento y lo difundi a otras personas.
    """
    REPORTER

    # Otras interacciones

    """
    El personaje utiliz el evento como una oportunidad para su propio beneficio (econmico, poltico, militar, etc.).
    """
    OPPORTUNIST

    """
    El personaje sufri una prdida o fue una vctima directa del evento.
    """
    VICTIM

    """
    El personaje fue rescatado durante el evento o dependi de la ayuda de otros para sobrevivir.
    """
    RESCUED

    """
    El personaje rescat a otras personas o ayud a mitigar los efectos del evento.
    """
    SAVIOR

    """
    El personaje cre una obra basada en el evento (arte, literatura, msica, etc.).
    """
    CHRONICLER
}

"""
Define la relacin entre un personaje y una faccin.
Incluye afiliaciones, liderazgos, enemistades e interacciones indirectas.
"""
enum CharacterFactionRelation {
    # Afiliaciones oficiales

    """
    El personaje es el lder absoluto de la faccin (rey, emperador, comandante supremo).
    """
    LEADER

    """
    El personaje es un miembro activo de la faccin.
    """
    MEMBER

    """
    El personaje es un ex-miembro que dej la faccin de manera voluntaria o fue expulsado.
    """
    FORMER_MEMBER

    # Relaciones externas

    """
    El personaje es un aliado de la faccin sin ser miembro oficial.
    """
    ALLY

    """
    El personaje es un enemigo de la faccin y se opone a sus intereses.
    """
    ENEMY

    """
    El personaje financia o apoya a la faccin sin ser miembro activo.
    """
    SPONSOR

    """
    El personaje trabaja para la faccin bajo contrato, sin lealtad directa.
    """
    MERCENARY

    # Interacciones estratgicas

    """
    El personaje ha sido capturado por la faccin y est prisionero.
    """
    PRISONER

    """
    El personaje es un informante o espa dentro de la faccin.
    """
    INFORMANT

    """
    El personaje est siendo manipulado por la faccin sin su conocimiento.
    """
    PUPPET
}

"""
Define la relacin entre un personaje y un tem.
Puede representar posesin, uso, creacin, destruccin o influencia del objeto en el personaje.
"""
enum CharacterItemRelation {
    # Relaciones de propiedad y uso
    """
    El personaje es el dueo actual del tem.
    """
    OWNER

    """
    El personaje fue dueo del tem, pero lo perdi o se deshizo de l.
    """
    FORMER_OWNER

    """
    El personaje usa activamente el tem, aunque no sea el dueo.
    """
    USER

    # Relaciones de creacin y destruccin
    """
    El personaje cre el tem (forja, magia, ingeniera, etc.).
    """
    CREATOR

    """
    El personaje destruy el tem o fue responsable de su prdida.
    """
    DESTROYER

    # Interacciones estratgicas
    """
    El personaje busca obtener el tem por algn motivo.
    """
    SEEKER

    """
    El personaje protege el tem y evita que caiga en malas manos.
    """
    GUARDIAN

    """
    El personaje est maldito o influenciado negativamente por el tem.
    """
    CURSED

    """
    El personaje vendi, intercambi o regal el tem.
    """
    MERCHANT

    """
    El personaje investig el tem para conocer su origen y propiedades.
    """
    SCHOLAR
}

"""
Define la relacin entre un personaje y una ubicacin.
Puede representar origen, residencia, gobierno, exploracin o conflicto con el lugar.
"""
enum CharacterLocationRelation {
    # Residencia y origen
    """
    El personaje naci en esta ubicacin.
    """
    BIRTHPLACE

    """
    El personaje vive en esta ubicacin de manera permanente.
    """
    RESIDENT

    # Control y gobierno
    """
    El personaje gobierna la ubicacin o tiene autoridad sobre ella.
    """
    RULER

    # Exploracin y viajes
    """
    El personaje pas por la ubicacin temporalmente.
    """
    VISITOR

    """
    El personaje explor la ubicacin en busca de conocimiento o recursos.
    """
    EXPLORER

    # Conflictos y castigos
    """
    El personaje fue exiliado de la ubicacin y no puede regresar.
    """
    EXILED

    """
    El personaje est en la ubicacin en contra de su voluntad (prisin, secuestro).
    """
    CAPTIVE

    """
    El personaje particip en una batalla que ocurri en la ubicacin.
    """
    BATTLEFIELD_PARTICIPANT

    """
    El personaje destruy parte o toda la ubicacin.
    """
    DESTROYER
}

"""
Define la relacin entre un personaje y un mundo.
Puede representar ciudadana, exploracin, influencia o enemistad con el mundo.
"""
enum CharacterWorldRelation {
    # Pertenencia y origen
    """
    El personaje naci en este mundo.
    """
    NATIVE

    """
    El personaje es un residente actual del mundo, pero no necesariamente nativo.
    """
    RESIDENT

    """
    El personaje es un extranjero que lleg desde otro mundo.
    """
    OUTSIDER

    # Influencia sobre el mundo
    """
    El personaje tiene una influencia significativa en la poltica, cultura o historia del mundo.
    """
    INFLUENCER

    """
    El personaje busca activamente proteger el mundo o mantener su equilibrio.
    """
    GUARDIAN

    """
    El personaje es un conquistador que busca dominar el mundo.
    """
    CONQUEROR

    """
    El personaje es un destructor que quiere traer caos o aniquilacin al mundo.
    """
    DESTROYER

    # Exploracin y descubrimiento
    """
    El personaje explora el mundo en busca de conocimiento o aventuras.
    """
    EXPLORER

    """
    El personaje fue exiliado del mundo y no puede regresar.
    """
    EXILED

    """
    El personaje fue convocado a este mundo por medios sobrenaturales (magia, rituales, etc.).
    """
    SUMMONED
}
`, BuiltIn: false},
	{Name: "../../../graphql/Character/input.graphqls", Input: `"""
Estructura para crear un nuevo personaje dentro de un mundo.
"""
input CreateCharacterInput {
    """
    ID del mundo al que pertenece el personaje.
    """
    worldId: ID!

    """
    Nombre del personaje.
    """
    name: String!

    """
    Descripcin del personaje, incluyendo trasfondo o detalles relevantes.
    """
    description: String!

    """
    Tipo de entidad, til para clasificar personajes en el sistema.
    """
    type: String!

    # Atributos fsicos y estado
    """
    Fecha de nacimiento del personaje en formato ISO 8601 (YYYY-MM-DD).
    """
    birthDate: String!

    """
    Altura del personaje en metros (m).
    """
    height: Float!

    """
    Peso del personaje en kilogramos (kg).
    """
    weight: Float!

    """
    Indica si el personaje est vivo (true) o muerto (false).
    """
    isAlive: Boolean!

    """
    Indica si el personaje es un protagonista o figura central en la historia.
    """
    isMain: Boolean!

    """
    Alineamiento moral o tico del personaje (segn el sistema usado).
    """
    alignment: Alignment
}

"""
Estructura para actualizar un personaje existente.
"""
input UpdateCharacterInput {
    """
    ID del personaje a modificar.
    """
    id: ID!

    """
    Nuevo nombre del personaje (opcional).
    """
    name: String

    """
    Nueva descripcin del personaje (opcional).
    """
    description: String

    """
    Modificar el tipo del personaje (opcional).
    """
    type: String

    # Atributos fsicos y estado
    """
    Modificar la fecha de nacimiento del personaje (opcional).
    """
    birthDate: String

    """
    Modificar la altura del personaje (opcional).
    """
    height: Float

    """
    Modificar el peso del personaje (opcional).
    """
    weight: Float

    """
    Modificar si el personaje est vivo o muerto (opcional).
    """
    isAlive: Boolean

    """
    Modificar si el personaje es un protagonista o no (opcional).
    """
    isMain: Boolean

    """
    Modificar el alineamiento del personaje (opcional).
    """
    alignment: Alignment
}
`, BuiltIn: false},
	{Name: "../../../graphql/Character/type.graphqls", Input: `"""
Representa un personaje en el mundo ficticio.
Incluye datos generales, atributos fsicos, estado de vida y relaciones con otras entidades.
"""
type Character implements Entity {
    # Identificacin y metadatos
    """
    Identificador nico del personaje.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creacin del personaje en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de ltima actualizacin del personaje en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Informacin general
    """
    Nombre del personaje.
    """
    name: String!

    """
    Descripcin del personaje, incluyendo trasfondo o detalles relevantes.
    """
    description: String!

    """
    Tipo de entidad, til para clasificar personajes en el sistema.
    """
    type: String!

    # Atributos fsicos y estado
    """
    Fecha de nacimiento del personaje en formato ISO 8601 (YYYY-MM-DD).
    """
    birthDate: String!

    """
    Altura del personaje en metros (m).
    """
    height: Float!

    """
    Peso del personaje en kilogramos (kg).
    """
    weight: Float!

    """
    Indica si el personaje est vivo (true) o muerto (false).
    """
    isAlive: Boolean!

    """
    Indica si el personaje es un protagonista o figura central en la historia.
    """
    isMain: Boolean!

    """
    Alineamiento moral o tico del personaje (segn el sistema usado).
    """
    alignment: Alignment

    # Relaciones con otras entidades
    """
    Lista de relaciones con otros personajes, incluyendo amistad, enemistad o parentesco.
    """
    characters: [CharacterCharacter!]!

    """
    Lista de relaciones del personaje con criaturas, incluyendo domesticacin o conflicto.
    """
    creatures: [CharacterCreature!]!

    """
    Lista de relaciones del personaje con facciones, como afiliaciones o enemistades.
    """
    factions: [CharacterFaction!]!

    """
    Lista de relaciones del personaje con eventos, como participacin o influencia.
    """
    events: [CharacterEvent!]!

    """
    Lista de relaciones del personaje con tems, como posesin, uso o creacin.
    """
    items: [CharacterItem!]!

    """
    Lista de relaciones del personaje con ubicaciones, como residencia o exploracin.
    """
    locations: [CharacterLocation!]!

    """
    Lista de relaciones del personaje con mundos, como origen, exilio o conquista.
    """
    worlds: [CharacterWorld!]!
}

"""
Define la relacin entre dos personajes.
Puede incluir amistad, enemistad, parentesco y otros vnculos narrativos.
"""
type CharacterCharacter {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje con el que se establece la relacin.
    """
    character: Character!

    """
    Nivel de relacin entre los personajes, desde amistad hasta enemistad extrema.
    """
    characterRelationLevel: CharacterRelationLevel!

    """
    Relacin familiar si existe un vnculo de parentesco (opcional).
    """
    familyRelation: FamilyRelation

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Representa la relacin entre un personaje y una criatura.
Puede incluir domesticacin, caza, invocacin y otros vnculos narrativos.
"""
type CharacterCreature {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relacin con la criatura.
    """
    character: Character!

    """
    La criatura con la que el personaje est relacionado.
    """
    creature: Creature!

    """
    Tipo de relacin entre el personaje y la criatura (dueo, enemigo, protector, etc.).
    """
    relation: CharacterCreatureRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre un personaje y una faccin.
Incluye afiliaciones, liderazgos, enemistades e interacciones indirectas.
"""
type CharacterFaction {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relacin con la faccin.
    """
    character: Character!

    """
    La faccin con la que el personaje tiene una relacin.
    """
    faction: Faction!

    """
    Tipo de relacin entre el personaje y la faccin (miembro, lder, enemigo, etc.).
    """
    relation: CharacterFactionRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre un personaje y un evento.
Puede representar participacin directa, testimonio, organizacin o influencia.
"""
type CharacterEvent {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relacin con el evento.
    """
    character: Character!

    """
    El evento con el que el personaje tiene una relacin.
    """
    event: Event!

    """
    Tipo de relacin entre el personaje y el evento (participante, organizador, testigo, etc.).
    """
    relation: CharacterEventRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre un personaje y un tem.
Puede representar posesin, uso, creacin, destruccin o influencia del objeto en el personaje.
"""
type CharacterItem {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relacin con el tem.
    """
    character: Character!

    """
    El tem con el que el personaje tiene una relacin.
    """
    item: Item!

    """
    Tipo de relacin entre el personaje y el tem (dueo, usuario, creador, etc.).
    """
    relation: CharacterItemRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre un personaje y una ubicacin.
Puede representar origen, residencia, gobierno, exploracin o conflicto con el lugar.
"""
type CharacterLocation {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relacin con la ubicacin.
    """
    character: Character!

    """
    La ubicacin con la que el personaje tiene una relacin.
    """
    location: Location!

    """
    Tipo de relacin entre el personaje y la ubicacin (residente, explorador, exiliado, etc.).
    """
    relation: CharacterLocationRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre un personaje y un mundo.
Puede representar ciudadana, exploracin, influencia o enemistad con el mundo.
"""
type CharacterWorld {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relacin con el mundo.
    """
    character: Character!

    """
    El mundo con el que el personaje tiene una relacin.
    """
    world: World!

    """
    Tipo de relacin entre el personaje y el mundo (nativo, explorador, conquistador, etc.).
    """
    relation: CharacterWorldRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/Creature/enum.graphqls", Input: `"""
Define la relacin entre dos criaturas.
Puede representar jerarqua, rivalidad, simbiosis y otras interacciones naturales o mgicas.
"""
enum CreatureCreatureRelation {
    # Relaciones de jerarqua y grupo
    """
    Una criatura es la lder de la otra dentro de una manada o sociedad.
    """
    LEADER

    """
    Las criaturas forman parte de la misma manada, colonia o sociedad.
    """
    PACK_MEMBER

    """
    Las criaturas tienen una relacin parental (madre/padre e hijo).
    """
    PARENT

    """
    Las criaturas son hermanos de la misma especie o camada.
    """
    SIBLING

    # Relaciones de cooperacin y simbiosis
    """
    Las criaturas tienen una relacin simbitica en la que ambas se benefician.
    """
    SYMBIOTIC

    """
    Las criaturas tienen una relacin de mutualismo, sin dependencia extrema.
    """
    MUTUALISTIC

    """
    Una criatura protege a la otra de forma voluntaria o instintiva.
    """
    PROTECTOR

    # Relaciones de rivalidad y conflicto
    """
    Las criaturas compiten por territorio, alimento o dominio.
    """
    RIVAL

    """
    Las criaturas se consideran enemigas y se atacan mutuamente.
    """
    ENEMY

    """
    Una criatura es depredadora y caza a la otra como parte de su dieta.
    """
    PREDATOR

    """
    Una criatura es presa natural de la otra.
    """
    PREY

    # Relaciones artificiales o mgicas
    """
    Una criatura fue creada artificialmente a partir de la otra (clonacin, magia, experimentos).
    """
    CREATED_FROM

    """
    Las criaturas estn conectadas por una maldicin, pacto o lazo sobrenatural.
    """
    CURSED
}

"""
Define la relacin entre una criatura y una faccin.
Puede representar uso militar, veneracin, domesticacin o conflicto.
"""
enum CreatureFactionRelation {
    # Relaciones de pertenencia y control
    """
    La criatura pertenece a la faccin como una mascota, montura o bestia domesticada.
    """
    ASSET

    """
    La criatura es utilizada como arma de guerra o para defensa militar.
    """
    WAR_BEAST

    """
    La criatura es venerada como un smbolo sagrado o deidad.
    """
    WORSHIPPED

    """
    La criatura fue capturada y est bajo el control de la faccin.
    """
    CAPTURED

    # Relaciones de conflicto
    """
    La criatura es considerada una amenaza y la faccin busca eliminarla.
    """
    HUNTED

    """
    La criatura ha sido una enemiga recurrente de la faccin.
    """
    ENEMY

    """
    La criatura es vista como un smbolo de mala fortuna o castigo divino.
    """
    OMEN

    # Relaciones de cooperacin
    """
    La criatura acta como aliada de la faccin sin estar controlada.
    """
    ALLY

    """
    La criatura es utilizada como un experimento dentro de la faccin.
    """
    EXPERIMENT
}

"""
Define la relacin entre una criatura y un evento.
Puede representar participacin en desastres, batallas, invocaciones y otros sucesos importantes.
"""
enum CreatureEventRelation {
    # Participacin activa
    """
    La criatura inici o caus el evento (ej. plaga, destruccin, guerra).
    """
    INITIATOR

    """
    La criatura particip en el evento, pero no fue la causa principal.
    """
    PARTICIPANT

    """
    La criatura fue invocada o trada al evento de forma mgica o tecnolgica.
    """
    SUMMONED

    # Relaciones pasivas o circunstanciales
    """
    La criatura fue testigo del evento sin intervenir directamente.
    """
    WITNESS

    """
    El evento afect a la criatura, alterando su estado o comportamiento.
    """
    AFFECTED

    # Relaciones de respuesta y resolucin
    """
    La criatura intent detener el evento o proteger a otros de sus efectos.
    """
    DEFENDER

    """
    La criatura fue rescatada durante el evento (ej. incendio, terremoto).
    """
    RESCUED

    """
    La criatura rescat a otros o ayud a mitigar los efectos del evento.
    """
    SAVIOR

    # Relaciones simblicas o narrativas
    """
    El evento fue interpretado como una profeca relacionada con la criatura.
    """
    OMEN

    """
    El evento se origin como una maldicin o consecuencia de la criatura.
    """
    CURSED
}

"""
Define la relacin entre una criatura y una ubicacin.
Puede representar su hbitat, migraciones, dominio territorial y ms.
"""
enum CreatureLocationRelation {
    # Hbitat y residencia
    """
    La criatura tiene su hbitat natural en esta ubicacin.
    """
    NATIVE

    """
    La criatura reside en esta ubicacin, pero no es su hbitat original.
    """
    RESIDENT

    """
    La criatura migr a esta ubicacin desde otro lugar.
    """
    MIGRATED

    # Control y territorio
    """
    La criatura reclama esta ubicacin como su dominio y la protege.
    """
    TERRITORIAL

    """
    La criatura est atrapada en esta ubicacin contra su voluntad.
    """
    TRAPPED

    """
    La criatura fue exiliada de esta ubicacin y no puede regresar.
    """
    EXILED

    # Relaciones con la ubicacin
    """
    La criatura es una amenaza para la ubicacin y causa destruccin.
    """
    THREAT

    """
    La criatura protege la ubicacin o mantiene su equilibrio ecolgico.
    """
    GUARDIAN

    """
    La criatura es un smbolo de la ubicacin, ya sea mitolgico o cultural.
    """
    SYMBOL
}

"""
Define la relacin entre una criatura y un mundo.
Puede representar origen, influencia interdimensional, exilio y ms.
"""
enum CreatureWorldRelation {
    # Origen y pertenencia
    """
    La criatura es nativa de este mundo.
    """
    NATIVE

    """
    La criatura no pertenece a este mundo y proviene de otro plano o dimensin.
    """
    OUTSIDER

    """
    La criatura es el resultado de una mutacin o adaptacin a este mundo.
    """
    ADAPTED

    # Relaciones de influencia
    """
    La criatura tiene un impacto significativo en la ecologa o historia del mundo.
    """
    INFLUENCER

    """
    La criatura fue convocada a este mundo a travs de medios sobrenaturales.
    """
    SUMMONED

    """
    La criatura protege el mundo o mantiene su equilibrio.
    """
    GUARDIAN

    # Relaciones de conflicto y destruccin
    """
    La criatura amenaza la existencia del mundo.
    """
    DESTROYER

    """
    La criatura fue exiliada del mundo y no puede regresar.
    """
    EXILED
}
`, BuiltIn: false},
	{Name: "../../../graphql/Creature/input.graphqls", Input: `"""
Estructura para crear una nueva criatura dentro de un mundo.
"""
input CreateCreatureInput {
    """
    ID del mundo al que pertenece la criatura.
    """
    worldId: ID!

    """
    Nombre de la criatura.
    """
    name: String!

    """
    Descripcin detallada de la criatura, incluyendo caractersticas nicas y comportamiento.
    """
    description: String!

    """
    Tipo de entidad, til para clasificar criaturas en el sistema.
    """
    type: String!

    """
    Especie o categora de la criatura (dragn, glem, quimera, etc.).
    """
    species: String!

    """
    Nivel de inteligencia de la criatura (bestia, sapiente, semisapiente, etc.).
    """
    intelligenceLevel: String!

    # Atributos fsicos y estado
    """
    Altura de la criatura en metros (m).
    """
    height: Float!

    """
    Peso de la criatura en kilogramos (kg).
    """
    weight: Float!

    """
    Fecha de nacimiento de la criatura en formato ISO 8601 (YYYY-MM-DD).
    """
    birthDate: String!

    """
    Indica si la criatura est viva (true) o muerta (false).
    """
    isAlive: Boolean!

    """
    Esperanza de vida aproximada de la criatura en aos.
    """
    lifespan: Int

    """
    Indica si la criatura es nica o pertenece a una especie con mltiples individuos.
    """
    isUnique: Boolean!

    # Hbitat y comportamiento
    """
    Ambiente donde la criatura vive (bosques, montaas, ocanos, etc.).
    """
    habitat: String!

    """
    Comportamiento de la criatura (pacfica, territorial, agresiva, etc.).
    """
    behavior: String!

    """
    Dieta de la criatura (carnvora, herbvora, omnvora, etc.).
    """
    diet: String!

    """
    Lista de habilidades especiales que posee la criatura (aliento de fuego, regeneracin, telepata, etc.).
    """
    abilities: [String!]!
}

"""
Estructura para actualizar una criatura existente.
"""
input UpdateCreatureInput {
    """
    ID de la criatura a modificar.
    """
    id: ID!

    """
    Nuevo nombre de la criatura (opcional).
    """
    name: String

    """
    Nueva descripcin de la criatura (opcional).
    """
    description: String

    """
    Modificar el tipo de la criatura (opcional).
    """
    type: String

    """
    Modificar la especie de la criatura (opcional).
    """
    species: String

    """
    Modificar el nivel de inteligencia de la criatura (opcional).
    """
    intelligenceLevel: String

    # Atributos fsicos y estado
    """
    Modificar la altura de la criatura (opcional).
    """
    height: Float

    """
    Modificar el peso de la criatura (opcional).
    """
    weight: Float

    """
    Modificar la fecha de nacimiento de la criatura (opcional).
    """
    birthDate: String

    """
    Modificar si la criatura est viva o muerta (opcional).
    """
    isAlive: Boolean

    """
    Modificar la esperanza de vida de la criatura (opcional).
    """
    lifespan: Int

    """
    Modificar si la criatura es nica o no (opcional).
    """
    isUnique: Boolean

    # Hbitat y comportamiento
    """
    Modificar el hbitat de la criatura (opcional).
    """
    habitat: String

    """
    Modificar el comportamiento de la criatura (opcional).
    """
    behavior: String

    """
    Modificar la dieta de la criatura (opcional).
    """
    diet: String

    """
    Modificar las habilidades de la criatura (opcional).
    """
    abilities: [String!]
}
`, BuiltIn: false},
	{Name: "../../../graphql/Creature/type.graphqls", Input: `"""
Representa una criatura dentro del mundo ficticio.
Incluye datos generales, atributos fsicos, hbitat y relaciones con otras entidades.
"""
type Creature implements Entity {
    # Identificacin y metadatos
    """
    Identificador nico de la criatura.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creacin de la criatura en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de ltima actualizacin de la criatura en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Informacin general
    """
    Nombre de la criatura.
    """
    name: String!

    """
    Descripcin de la criatura, incluyendo caractersticas nicas y comportamiento.
    """
    description: String!

    """
    Tipo de entidad, til para clasificar criaturas en el sistema.
    """
    type: String!

    """
    Especie o categora de la criatura (dragn, glem, quimera, etc.).
    """
    species: String!

    """
    Nivel de inteligencia de la criatura (bestia, sapiente, semisapiente, etc.).
    """
    intelligenceLevel: String!

    # Atributos fsicos y estado
    """
    Altura de la criatura en metros (m).
    """
    height: Float!

    """
    Peso de la criatura en kilogramos (kg).
    """
    weight: Float!

    # Atributos fsicos y estado
    """
    Fecha de nacimiento de la criatura en formato ISO 8601 (YYYY-MM-DD).
    """
    birthDate: String!

    """
    Indica si la criatura est viva (true) o muerta (false).
    """
    isAlive: Boolean!

    """
    Esperanza de vida aproximada de la criatura en aos.
    """
    lifespan: Int

    """
    Indica si la criatura es nica o pertenece a una especie con mltiples individuos.
    """
    isUnique: Boolean!

    # Hbitat y comportamiento
    """
    Ambiente donde la criatura vive (bosques, montaas, ocanos, etc.).
    """
    habitat: String!

    """
    Comportamiento de la criatura (pacfica, territorial, agresiva, etc.).
    """
    behavior: String!

    """
    Dieta de la criatura (carnvora, herbvora, omnvora, etc.).
    """
    diet: String!

    """
    Lista de habilidades especiales que posee la criatura (aliento de fuego, regeneracin, telepata, etc.).
    """
    abilities: [String!]!

    # Relaciones con otras entidades
    """
    Lista de relaciones de la criatura con personajes, incluyendo domesticacin o conflicto.
    """
    characters: [CharacterCreature!]!

    """
    Lista de relaciones de la criatura con otras criaturas, incluyendo jerarquas o rivalidades.
    """
    creatures: [CreatureCreature!]!

    """
    Lista de relaciones de la criatura con facciones, como uso militar o veneracin.
    """
    factions: [CreatureFaction!]!

    """
    Lista de relaciones de la criatura con eventos, como participacin en batallas o desastres naturales.
    """
    events: [CreatureEvent!]!

    """
    Lista de relaciones de la criatura con ubicaciones, como hbitat o migraciones.
    """
    locations: [CreatureLocation!]!

    """
    Lista de relaciones de la criatura con mundos, como su origen o influencia interdimensional.
    """
    worlds: [CreatureWorld!]!
}

"""
Define la relacin entre dos criaturas.
Puede representar jerarqua, rivalidad, simbiosis y otras interacciones naturales o mgicas.
"""
type CreatureCreature {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La criatura con la que se establece la relacin.
    """
    creature: Creature!

    """
    Tipo de relacin entre ambas criaturas (jerrquica, depredador-presa, simbitica, etc.).
    """
    relation: CreatureCreatureRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre una criatura y una faccin.
Puede representar uso militar, veneracin, domesticacin o conflicto.
"""
type CreatureFaction {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La criatura con la que la faccin tiene una relacin.
    """
    creature: Creature!

    """
    La faccin con la que la criatura tiene una relacin.
    """
    faction: Faction!

    """
    Tipo de relacin entre la criatura y la faccin (mascota, bestia de guerra, smbolo sagrado, etc.).
    """
    relation: CreatureFactionRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre una criatura y un evento.
Puede representar participacin en desastres, batallas, invocaciones y otros sucesos importantes.
"""
type CreatureEvent {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La criatura con la que el evento tiene una relacin.
    """
    creature: Creature!

    """
    El evento con el que la criatura tiene una relacin.
    """
    event: Event!

    """
    Tipo de relacin entre la criatura y el evento (iniciador, participante, testigo, etc.).
    """
    relation: CreatureEventRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre una criatura y una ubicacin.
Puede representar su hbitat, migraciones, dominio territorial y ms.
"""
type CreatureLocation {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La criatura con la que la ubicacin tiene una relacin.
    """
    creature: Creature!

    """
    La ubicacin con la que la criatura tiene una relacin.
    """
    location: Location!

    """
    Tipo de relacin entre la criatura y la ubicacin (hbitat, migracin, dominio territorial, etc.).
    """
    relation: CreatureLocationRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre una criatura y un mundo.
Puede representar origen, influencia interdimensional, exilio y ms.
"""
type CreatureWorld {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La criatura con la que el mundo tiene una relacin.
    """
    creature: Creature!

    """
    El mundo con el que la criatura tiene una relacin.
    """
    world: World!

    """
    Tipo de relacin entre la criatura y el mundo (nativa, invocada, exiliada, etc.).
    """
    relation: CreatureWorldRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/enum.graphqls", Input: `enum Alignment {
    LAWFUL_GOOD
    NEUTRAL_GOOD
    CHAOTIC_GOOD
    LAWFUL_NEUTRAL
    TRUE_NEUTRAL
    CHAOTIC_NEUTRAL
    LAWFUL_EVIL
    NEUTRAL_EVIL
    CHAOTIC_EVIL
}
`, BuiltIn: false},
	{Name: "../../../graphql/Event/enum.graphqls", Input: `"""
Clasifica los eventos segn su naturaleza.
Puede representar batallas, descubrimientos, rituales, catstrofes y otros sucesos.
"""
enum EventType {
    # Eventos histricos y polticos
    """
    Un evento donde se produce un conflicto armado entre facciones o naciones.
    """
    BATTLE

    """
    Un tratado, negociacin o evento diplomtico entre entidades.
    """
    DIPLOMATIC_EVENT

    """
    Un golpe de estado, revolucin o cambio radical de poder.
    """
    POLITICAL_UPHEAVAL

    # Eventos de exploracin y descubrimiento
    """
    Un evento donde se descubre un nuevo territorio o lugar significativo.
    """
    DISCOVERY

    """
    Un evento donde se revela informacin crucial para la historia.
    """
    REVELATION

    # Eventos religiosos y mgicos
    """
    Un ritual realizado con propsitos religiosos, mgicos o esotricos.
    """
    RITUAL

    """
    Una profeca que influye en la historia del mundo.
    """
    PROPHECY

    """
    Un evento donde una entidad divina interviene en el mundo.
    """
    DIVINE_INTERVENTION

    # Catstrofes y desastres
    """
    Un desastre natural (terremoto, erupcin volcnica, tsunami, etc.).
    """
    NATURAL_DISASTER

    """
    Una pandemia o plaga que afecta a una regin o poblacin.
    """
    PLAGUE

    """
    Un evento en el que se produce un incendio de gran magnitud.
    """
    FIRE

    """
    Un evento en el que se genera caos y destruccin por causas no naturales.
    """
    CALAMITY

    # Eventos culturales y sociales
    """
    Un evento festivo, celebracin o competencia deportiva.
    """
    FESTIVAL

    """
    Un evento acadmico, cientfico o reunin intelectual relevante.
    """
    SCHOLARLY_EVENT

    """
    Un juicio o evento de condena pblica.
    """
    TRIAL

    # Eventos sobrenaturales o inexplicables
    """
    Un evento paranormal o que desafa la lgica del mundo.
    """
    SUPERNATURAL_EVENT

    """
    Un evento donde se abre un portal a otra dimensin o plano.
    """
    INTERDIMENSIONAL_RIFT
}

"""
Indica la importancia de un evento dentro de la historia.
Puede determinar su impacto en la narrativa del mundo.
"""
enum EventSignificance {
    """
    Un evento menor con impacto limitado en la historia general.
    """
    LOW

    """
    Un evento de relevancia media que afecta a una regin o a un grupo importante de personajes.
    """
    MEDIUM

    """
    Un evento crucial que cambia la historia del mundo de forma permanente.
    """
    HIGH
}

"""
Define la relacin entre dos eventos.
Puede representar causalidad, continuidad, interdependencia o influencia entre eventos.
"""
enum EventEvent {
    # Relaciones de causalidad
    """
    El evento A caus directamente el evento B.
    """
    CAUSE

    """
    El evento B ocurri como consecuencia del evento A.
    """
    CONSEQUENCE

    """
    El evento B es una reaccin directa al evento A (ej. represalia, respuesta diplomtica).
    """
    RESPONSE

    # Relaciones de continuidad
    """
    El evento B es una continuacin lgica del evento A.
    """
    CONTINUATION

    """
    El evento B es una repeticin o iteracin del evento A.
    """
    REOCCURRENCE

    """
    El evento B se produce en paralelo con el evento A, sin que uno cause al otro.
    """
    PARALLEL

    # Relaciones de influencia
    """
    El evento A inspir o motiv el evento B sin ser su causa directa.
    """
    INSPIRATION

    """
    El evento A y el evento B estn profetizados como parte de un mismo ciclo.
    """
    PROPHECY_LINK

    """
    Ambos eventos estn mgicamente o sobrenaturalmente conectados.
    """
    SUPERNATURAL_LINK
}

"""
Indica la naturaleza del evento, diferenciando entre encuentros planificados, espontneos o accidentales.
"""
enum EventNature {
    # Eventos planificados
    """
    El evento fue planeado con anticipacin (ceremonias, batallas estratgicas, reuniones).
    """
    PLANNED

    """
    El evento ocurri debido a una cita o reunin acordada entre personajes o facciones.
    """
    APPOINTMENT

    """
    El evento fue provocado intencionalmente por una de las partes (ataques, conspiraciones, emboscadas).
    """
    INTENTIONAL

    # Eventos espontneos
    """
    El evento ocurri sin planificacin previa, como encuentros fortuitos o descubrimientos inesperados.
    """
    SPONTANEOUS

    """
    El evento fue un accidente sin intencin detrs (explosin accidental, tropiezo, equivocacin).
    """
    ACCIDENTAL

    """
    El evento ocurri por coincidencia, sin intervencin intencional de los involucrados.
    """
    COINCIDENCE

    # Eventos inevitables o forzados
    """
    El evento era inevitable por razones naturales, sobrenaturales o predestinadas (profeca cumplida, fin del mundo).
    """
    INEVITABLE

    """
    El evento ocurri debido a fuerzas externas sin que los personajes tuvieran control sobre l (terremoto, tormenta, invasin repentina).
    """
    FORCED
}
`, BuiltIn: false},
	{Name: "../../../graphql/Event/input.graphqls", Input: `"""
Estructura para crear un nuevo evento dentro de un mundo.
"""
input CreateEventInput {
    """
    ID del mundo en el que ocurre el evento.
    """
    worldId: ID!

    """
    Nombre del evento.
    """
    name: String!

    """
    Descripcin detallada del evento, incluyendo su impacto y contexto.
    """
    description: String!

    """
    Clasificacin del evento segn su naturaleza (batalla, descubrimiento, ritual, etc.).
    """
    type: EventType!

    """
    Indica la naturaleza del evento (planificado, accidental, fortuito, inevitable, etc.).
    """
    nature: EventNature!

    # Duracin y recurrencia
    """
    Fecha de inicio del evento en formato ISO 8601 (YYYY-MM-DD).
    """
    startDate: String!

    """
    Fecha de finalizacin del evento en formato ISO 8601 (YYYY-MM-DD).
    """
    endDate: String!

    """
    Indica si el evento es recurrente (true) o nico (false).
    """
    isRecurring: Boolean!

    """
    Importancia del evento dentro de la historia (baja, media, alta).
    """
    significance: EventSignificance!

    # Ubicacin y contexto
    """
    Lista de ubicaciones donde ocurri el evento.
    """
    locations: [ID!]!

    """
    Mundos en los que el evento tuvo un impacto.
    """
    worlds: [ID!]!
}

"""
Estructura para actualizar un evento existente.
"""
input UpdateEventInput {
    """
    ID del evento a modificar.
    """
    id: ID!

    """
    Nuevo nombre del evento (opcional).
    """
    name: String

    """
    Nueva descripcin del evento (opcional).
    """
    description: String

    """
    Modificar la clasificacin del evento (opcional).
    """
    type: EventType

    """
    Modificar la naturaleza del evento (opcional).
    """
    nature: EventNature

    # Duracin y recurrencia
    """
    Modificar la fecha de inicio del evento (opcional).
    """
    startDate: String

    """
    Modificar la fecha de finalizacin del evento (opcional).
    """
    endDate: String

    """
    Modificar si el evento es recurrente (opcional).
    """
    isRecurring: Boolean

    """
    Modificar la importancia del evento en la historia (opcional).
    """
    significance: EventSignificance

    # Ubicacin y contexto
    """
    Modificar la lista de ubicaciones del evento (opcional).
    """
    locations: [ID!]

    """
    Modificar la lista de mundos afectados por el evento (opcional).
    """
    worlds: [ID!]
}
`, BuiltIn: false},
	{Name: "../../../graphql/Event/type.graphqls", Input: `"""
Representa un evento dentro del mundo ficticio.
Incluye datos generales, ubicacin, impacto y relaciones con otras entidades.
"""
type Event implements Entity {
    # Identificacin y metadatos
    """
    Identificador nico del evento.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creacin del evento en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de ltima actualizacin del evento en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Informacin general
    """
    Nombre del evento.
    """
    name: String!

    """
    Descripcin detallada del evento, incluyendo su impacto y contexto.
    """
    description: String!

    """
    Clasificacin del evento segn su naturaleza (batalla, descubrimiento, ritual, etc.).
    """
    type: EventType!

    """
    Indica la naturaleza del evento (planificado, accidental, fortuito, inevitable, etc.).
    """
    nature: EventNature!

    # Duracin y recurrencia
    """
    Fecha de inicio del evento en formato ISO 8601 (YYYY-MM-DD).
    """
    startDate: String!

    """
    Fecha de finalizacin del evento en formato ISO 8601 (YYYY-MM-DD).
    """
    endDate: String!

    """
    Indica si el evento es recurrente (true) o nico (false).
    """
    isRecurring: Boolean!

    """
    Importancia del evento dentro de la historia (baja, media, alta).
    """
    significance: EventSignificance!

    # Ubicacin y contexto
    """
    Lista de ubicaciones donde ocurri el evento.
    """
    locations: [LocationEvent!]!

    """
    Mundos en los que el evento tuvo un impacto.
    """
    worlds: [WorldEvent!]!

    # Relaciones con otras entidades
    """
    Lista de personajes involucrados en el evento.
    """
    characters: [CharacterEvent!]!

    """
    Lista de criaturas que participaron en el evento.
    """
    creatures: [CreatureEvent!]!

    """
    Lista de facciones relacionadas con el evento.
    """
    factions: [FactionEvent!]!

    """
    Lista de tems asociados al evento (artefactos, armas, reliquias, etc.).
    """
    items: [ItemEvent!]!

    """
    Lista de eventos relacionados que ocurrieron antes, despus o en paralelo.
    """
    relatedEvents: [EventEvent!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Faction/enum.graphqls", Input: `"""
Clasifica las facciones segn su estructura y propsito.
Incluye gobiernos, cultos, gremios, clanes, ejrcitos y ms.
"""
enum FactionType {
    # Estructuras de gobierno y poder
    """
    Una nacin o reino gobernado por una autoridad central.
    """
    NATION

    """
    Un estado independiente o ciudad-estado con gobierno propio.
    """
    CITY_STATE

    """
    Un imperio con dominio sobre mltiples territorios.
    """
    EMPIRE

    """
    Un grupo de resistencia o revolucin contra el poder establecido.
    """
    REBELLION

    # Grupos ideolgicos y religiosos
    """
    Una organizacin religiosa con dogmas y seguidores.
    """
    RELIGIOUS_ORDER

    """
    Un culto dedicado a una deidad, entidad o creencia especfica.
    """
    CULT

    """
    Una hermandad secreta o sociedad con propsitos ocultos.
    """
    SECRET_SOCIETY

    # Organizaciones militares y mercenarias
    """
    Un ejrcito formal al servicio de un estado o gobernante.
    """
    MILITARY

    """
    Un grupo de mercenarios que ofrece servicios de combate o proteccin.
    """
    MERCENARY_COMPANY

    """
    Una banda de saqueadores, piratas o criminales organizados.
    """
    RAIDERS

    # Grupos econmicos y comerciales
    """
    Un gremio de artesanos, comerciantes o profesionales.
    """
    GUILD

    """
    Una megacorporacin o grupo empresarial con gran influencia econmica.
    """
    MEGACORPORATION

    # Clanes y grupos tribales
    """
    Una tribu con una cultura propia y gobierno descentralizado.
    """
    TRIBE

    """
    Un clan familiar con influencia en una regin o esfera de poder.
    """
    CLAN
}

"""
Indica el estado actual de la faccin en la historia.
Puede estar activa, disuelta, exiliada, entre otros.
"""
enum FactionStatus {
    """
    La faccin sigue operativa y tiene actividad en el mundo.
    """
    ACTIVE

    """
    La faccin se ha disuelto y ya no existe como organizacin.
    """
    DISBANDED

    """
    La faccin fue exiliada y ya no tiene territorio propio.
    """
    EXILED

    """
    La faccin opera en secreto y no es reconocida pblicamente.
    """
    UNDERGROUND

    """
    La faccin est en decadencia y perdiendo influencia.
    """
    DECLINING

    """
    La faccin est en auge y expandiendo su poder.
    """
    ASCENDING
}

"""
Indica el nivel de influencia de la faccin en el mundo o sociedad.
Determina su relevancia histrica y social.
"""
enum FactionInfluence {
    """
    Faccin menor con presencia local o influencia limitada.
    """
    MINOR

    """
    Faccin con una influencia considerable en una regin o sector de la sociedad.
    """
    REGIONAL

    """
    Faccin con impacto significativo en mltiples regiones o reas de poder.
    """
    MAJOR

    """
    Faccin de importancia global o interdimensional.
    """
    WORLDWIDE
}

"""
Define la relacin entre dos facciones.
Puede representar alianzas, enemistades, subordinacin y competencia.
"""
enum FactionFactionRelation {
    # Relaciones de cooperacin
    """
    Las facciones estn aliadas y colaboran activamente.
    """
    ALLIED

    """
    Una faccin est subordinada a otra.
    """
    VASSAL

    """
    Ambas facciones tienen un pacto de no agresin o comercio.
    """
    NEUTRAL_PACT

    # Relaciones de conflicto
    """
    Las facciones son enemigas y estn en guerra o conflicto activo.
    """
    ENEMY

    """
    Una faccin busca la destruccin o disolucin de la otra.
    """
    RIVALRY

    """
    Las facciones tienen desacuerdos polticos, econmicos o ideolgicos.
    """
    TENSION

    # Relaciones diplomticas
    """
    Una faccin ha sido absorbida por otra y ya no existe como entidad independiente.
    """
    ABSORBED

    """
    Las facciones estn en tregua temporal tras un conflicto.
    """
    TRUCE
}

"""
Define la relacin entre una faccin y un evento.
Puede representar participacin en batallas, diplomacia, rebeliones y ms.
"""
enum FactionEventRelation {
    # Participacin activa
    """
    La faccin inici o provoc el evento.
    """
    INITIATOR

    """
    La faccin particip activamente en el evento.
    """
    PARTICIPANT

    """
    La faccin organiz el evento, pero no particip directamente.
    """
    ORGANIZER

    # Relaciones de conflicto o respuesta
    """
    La faccin intent evitar o detener el evento.
    """
    OPPOSER

    """
    La faccin sufri las consecuencias del evento.
    """
    AFFECTED

    """
    La faccin us el evento como una oportunidad poltica o econmica.
    """
    OPPORTUNIST

    # Relaciones diplomticas
    """
    El evento llev a la faccin a hacer un tratado de paz o alianza.
    """
    DIPLOMATIC_SHIFT

    """
    El evento caus la disolucin de la faccin.
    """
    DISSOLUTION
}

"""
Define la relacin entre una faccin y un tem.
Puede representar reliquias, smbolos de poder, armamento y ms.
"""
enum FactionItemRelation {
    # Relaciones de posesin y uso
    """
    El tem es un smbolo de poder o autoridad de la faccin.
    """
    SYMBOL

    """
    El tem es una reliquia sagrada o de gran valor para la faccin.
    """
    RELIC

    """
    El tem es parte del armamento de la faccin.
    """
    WEAPON

    """
    El tem es un documento, tratado o cdigo legal de la faccin.
    """
    DOCUMENT

    # Relaciones histricas y mitolgicas
    """
    El tem est vinculado a la historia de la faccin.
    """
    HISTORICAL

    """
    El tem tiene un valor cultural o religioso para la faccin.
    """
    CULTURAL
}

"""
Define la relacin entre una faccin y una ubicacin.
Puede representar dominio, influencia, exilio y ms.
"""
enum FactionLocationRelation {
    # Relaciones de control y dominio
    """
    La faccin controla la ubicacin como su territorio principal.
    """
    CAPITAL

    """
    La faccin posee la ubicacin como parte de su territorio.
    """
    OWNED

    """
    La faccin ejerce influencia poltica, econmica o militar en la ubicacin.
    """
    INFLUENCE

    # Relaciones de conflicto y exilio
    """
    La faccin perdi la ubicacin tras un conflicto o cada de poder.
    """
    LOST_TERRITORY

    """
    La faccin fue exiliada de esta ubicacin y no puede regresar.
    """
    EXILED

    """
    La faccin intenta conquistar la ubicacin.
    """
    CONQUERING

    """
    La faccin ha ocupado temporalmente la ubicacin mediante fuerza militar o diplomacia.
    """
    OCCUPIED

    # Relaciones neutrales y estratgicas
    """
    La faccin tiene presencia en la ubicacin, pero no la controla.
    """
    OUTPOST

    """
    La faccin considera la ubicacin sagrada o importante por razones religiosas o culturales.
    """
    SACRED_SITE
}

"""
Define la relacin entre una faccin y un mundo.
Puede representar su origen, dominio, influencia interdimensional y ms.
"""
enum FactionWorldRelation {
    # Existencia y origen
    """
    La faccin fue fundada en este mundo y es nativa de l.
    """
    NATIVE

    """
    La faccin se expandi a este mundo desde otro plano de existencia.
    """
    EXPANDED

    """
    La faccin gobierna o tiene control absoluto sobre este mundo.
    """
    RULER

    """
    La faccin ha sido exiliada de este mundo y no puede regresar.
    """
    EXILED

    # Influencia y operaciones
    """
    La faccin tiene influencia poltica, econmica o militar en este mundo.
    """
    INFLUENCE

    """
    La faccin opera en este mundo, pero sin un territorio propio.
    """
    OPERATES_HERE

    """
    La faccin ha sido eliminada de este mundo y ya no existe en l.
    """
    ERADICATED

    # Conexiones interdimensionales
    """
    La faccin usa este mundo como punto de acceso para otros planos o dimensiones.
    """
    INTERPLANAR_BASE

    """
    La faccin es una anomala en este mundo y no pertenece a su realidad.
    """
    ANOMALY
}
`, BuiltIn: false},
	{Name: "../../../graphql/Faction/input.graphqls", Input: `"""
Estructura para crear una nueva faccin dentro de un mundo.
"""
input CreateFactionInput {
    """
    ID del mundo al que pertenece la faccin.
    """
    worldId: ID!

    """
    Nombre de la faccin.
    """
    name: String!

    """
    Descripcin de la faccin, incluyendo su historia, cultura y propsito.
    """
    description: String!

    """
    Clasificacin de la faccin segn su estructura y propsito.
    """
    type: FactionType!

    """
    Ideologa, valores o principios que rigen a la faccin.
    """
    ideology: String!

    """
    Estatus actual de la faccin (activa, disuelta, exiliada, etc.).
    """
    status: FactionStatus!

    """
    Fecha de fundacin de la faccin en formato ISO 8601 (YYYY-MM-DD).
    """
    foundedDate: String!

    """
    Fecha de disolucin de la faccin (opcional, en caso de que ya no exista).
    """
    disbandedDate: String

    """
    Nivel de influencia de la faccin en la historia o sociedad.
    """
    influence: FactionInfluence!

    """
    Lista de ubicaciones donde la faccin tiene presencia, dominio o influencia.
    """
    locations: [ID!]!

    """
    Lista de mundos donde la faccin tiene presencia, influencia o ha sido exiliada.
    """
    worlds: [ID!]!
}

"""
Estructura para actualizar una faccin existente.
"""
input UpdateFactionInput {
    """
    ID de la faccin a modificar.
    """
    id: ID!

    """
    Nuevo nombre de la faccin (opcional).
    """
    name: String

    """
    Nueva descripcin de la faccin (opcional).
    """
    description: String

    """
    Modificar la clasificacin de la faccin (opcional).
    """
    type: FactionType

    """
    Modificar la ideologa de la faccin (opcional).
    """
    ideology: String

    """
    Modificar el estatus actual de la faccin (opcional).
    """
    status: FactionStatus

    """
    Modificar la fecha de fundacin de la faccin (opcional).
    """
    foundedDate: String

    """
    Modificar la fecha de disolucin de la faccin (opcional).
    """
    disbandedDate: String

    """
    Modificar el nivel de influencia de la faccin (opcional).
    """
    influence: FactionInfluence

    """
    Modificar las ubicaciones donde la faccin tiene presencia (opcional).
    """
    locations: [ID!]

    """
    Modificar los mundos donde la faccin tiene influencia (opcional).
    """
    worlds: [ID!]
}
`, BuiltIn: false},
	{Name: "../../../graphql/Faction/type.graphqls", Input: `"""
Representa una faccin dentro del mundo ficticio.
Incluye datos generales, estructura organizativa, ideologa y relaciones con otras entidades.
"""
type Faction implements Entity {
    # Identificacin y metadatos
    """
    Identificador nico de la faccin.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creacin de la faccin en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de ltima actualizacin de la faccin en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Informacin general
    """
    Nombre de la faccin.
    """
    name: String!

    """
    Descripcin de la faccin, incluyendo su historia, cultura y propsito.
    """
    description: String!

    """
    Clasificacin de la faccin segn su estructura y propsito.
    """
    type: FactionType!

    """
    Ideologa, valores o principios que rigen a la faccin.
    """
    ideology: String!

    """
    Estatus actual de la faccin (activa, disuelta, exiliada, etc.).
    """
    status: FactionStatus!

    """
    Fecha de fundacin de la faccin en formato ISO 8601 (YYYY-MM-DD).
    """
    foundedDate: String!

    """
    Fecha de disolucin de la faccin (opcional, en caso de que ya no exista).
    """
    disbandedDate: String

    """
    Nivel de influencia de la faccin en la historia o sociedad.
    """
    influence: FactionInfluence!

    # Ubicacin y dominio
    """
    Lista de ubicaciones donde la faccin tiene presencia, dominio o influencia.
    """
    locations: [FactionLocation!]!

    """
    Lista de mundos donde la faccin tiene presencia, influencia o ha sido exiliada.
    """
    worlds: [FactionWorld!]!

    # Relaciones con otras entidades
    """
    Lista de personajes afiliados a la faccin.
    """
    characters: [CharacterFaction!]!

    """
    Lista de criaturas asociadas a la faccin (usadas en combate, veneradas, etc.).
    """
    creatures: [CreatureFaction!]!

    """
    Lista de facciones relacionadas (aliadas, enemigas, subordinadas, etc.).
    """
    factions: [FactionFaction!]!

    """
    Lista de eventos clave en los que la faccin estuvo involucrada.
    """
    events: [FactionEvent!]!

    """
    Lista de tems asociados a la faccin (armamento, reliquias, smbolos).
    """
    items: [FactionItem!]!
}

"""
Define la relacin entre dos facciones.
Puede incluir alianzas, enemistades, pactos y subordinacin.
"""
type FactionFaction {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La faccin con la que se establece la relacin.
    """
    faction: Faction!

    """
    Tipo de relacin entre ambas facciones (aliadas, enemigas, vasallaje, etc.).
    """
    relation: FactionFactionRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre una faccin y un evento.
Puede representar participacin en batallas, diplomacia o conflictos internos.
"""
type FactionEvent {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La faccin que tiene la relacin con el evento.
    """
    faction: Faction!

    """
    El evento con el que la faccin tiene una relacin.
    """
    event: Event!

    """
    Tipo de relacin entre la faccin y el evento (participacin, iniciador, oposicin, etc.).
    """
    relation: FactionEventRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre una faccin y un tem.
Puede representar reliquias, smbolos de poder, armamento y ms.
"""
type FactionItem {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La faccin que tiene la relacin con el tem.
    """
    faction: Faction!

    """
    El tem con el que la faccin tiene una relacin.
    """
    item: Item!

    """
    Tipo de relacin entre la faccin y el tem (smbolo, reliquia, armamento, etc.).
    """
    relation: FactionItemRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre una faccin y una ubicacin.
Puede representar control, influencia, exilio o presencia estratgica.
"""
type FactionLocation {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La faccin que tiene la relacin con la ubicacin.
    """
    faction: Faction!

    """
    La ubicacin con la que la faccin tiene una relacin.
    """
    location: Location!

    """
    Tipo de relacin entre la faccin y la ubicacin (control, influencia, exilio, etc.).
    """
    relation: FactionLocationRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre una faccin y un mundo.
Puede representar su origen, dominio, influencia interdimensional o exilio.
"""
type FactionWorld {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La faccin que tiene la relacin con el mundo.
    """
    faction: Faction!

    """
    El mundo con el que la faccin tiene una relacin.
    """
    world: World!

    """
    Tipo de relacin entre la faccin y el mundo (nativa, exiliada, gobernante, etc.).
    """
    relation: FactionWorldRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/Item/enum.graphqls", Input: `"""
Define en qu parte del cuerpo o en qu espacio del inventario se equipa un tem.
Incluye armaduras, armas, accesorios y objetos especiales.
"""
enum ItemSlot {
    # Equipamiento en la cabeza y rostro
    """
    Casco, corona o cualquier tipo de proteccin para la cabeza.
    """
    HEAD

    """
    Pendientes o accesorios equipados en las orejas.
    """
    EARS

    """
    Collares, amuletos u objetos usados en el cuello.
    """
    NECK

    # Equipamiento en la parte superior del cuerpo
    """
    Hombreras o protecciones colocadas en los hombros.
    """
    SHOULDERS

    """
    Capa, manto o cualquier accesorio usado en la espalda.
    """
    BACK

    """
    Protecciones o equipamiento en los brazos (manguitos, brazales, etc.).
    """
    ARMS

    """
    Muequeras, pulseras o protecciones en las muecas.
    """
    WRISTS

    """
    Guantes, garras o cualquier tem usado en las manos.
    """
    HANDS

    """
    Anillos y sortijas usados en los dedos.
    """
    FINGERS

    """
    Armadura o vestimenta que cubre el torso del personaje.
    """
    CHEST

    """
    Cinturones, fajines u otros objetos equipados en la cintura.
    """
    WAIST

    # Equipamiento en las piernas y pies
    """
    Armaduras o vestimenta que cubre las piernas completas.
    """
    LEGS

    """
    Equipamiento para la parte inferior de las piernas (grebas, espinilleras).
    """
    LOWER_LEGS

    """
    Equipamiento para la parte superior de las piernas (musleras, faldones).
    """
    UPPER_LEGS

    """
    Protecciones especficas para las rodillas (rodilleras).
    """
    KNEES

    """
    Botas, sandalias o cualquier calzado usado en los pies.
    """
    FEET

    # Equipamiento de armas y combate
    """
    Arma de combate cuerpo a cuerpo de una mano.
    """
    MELEE_ONE_HAND

    """
    Arma de combate cuerpo a cuerpo de dos manos.
    """
    MELEE_TWO_HAND

    """
    Arma a distancia de una mano (pistolas, dagas arrojadizas).
    """
    RANGED_ONE_HAND

    """
    Arma a distancia de dos manos (arcos, ballestas, rifles).
    """
    RANGED_TWO_HAND

    """
    Arma hbrida de una mano (arma que puede ser usada cuerpo a cuerpo y a distancia).
    """
    HYBRID_ONE_HAND

    """
    Arma hbrida de dos manos (arma de uso mixto con ambas manos).
    """
    HYBRID_TWO_HAND

    """
    Escudos y defensas que se pueden equipar en una mano.
    """
    SHIELD

    # Accesorios y objetos especiales
    """
    Tabardos o emblemas que representan facciones o grupos.
    """
    TABARD

    """
    Camisas y prendas interiores que no afectan la armadura.
    """
    SHIRT

    """
    Objetos especiales con habilidades activas o pasivas.
    """
    TRINKET

    """
    Reliquias o artefactos sagrados de gran poder.
    """
    RELIC
}

"""
Clasifica los tems segn su funcin o propsito dentro del mundo ficticio.
"""
enum ItemType {
    # Armas y equipo de combate
    """
    Un arma utilizada en combate (espada, lanza, arco, etc.).
    """
    WEAPON

    """
    Armadura o escudo diseado para la proteccin del usuario.
    """
    ARMOR

    """
    Accesorios de combate como anillos, amuletos, brazales.
    """
    COMBAT_ACCESSORY

    # Objetos mgicos y sobrenaturales
    """
    Un artefacto mgico con habilidades nicas.
    """
    ARTIFACT

    """
    Un pergamino o tomo con conocimientos ocultos o conjuros.
    """
    SPELLBOOK

    """
    Un tem maldito que tiene efectos negativos sobre su portador.
    """
    CURSED_ITEM

    # tems utilitarios
    """
    Herramientas de uso general como llaves, brjulas, o dagas multiusos.
    """
    TOOL

    """
    Pociones y consumibles que otorgan efectos temporales.
    """
    POTION

    """
    Un mapa que proporciona informacin sobre el mundo o una regin.
    """
    MAP

    # Objetos histricos y simblicos
    """
    Un tem con importancia histrica o cultural.
    """
    RELIC

    """
    Un documento escrito, como un tratado, un contrato o un diario.
    """
    DOCUMENT

    """
    Un objeto de alto valor simblico o representativo de una faccin.
    """
    SYMBOL
}

"""
Clasifica los tems segn su rareza dentro del mundo ficticio.
"""
enum ItemRarity {
    """
    tems comunes y de fcil acceso en el mundo.
    """
    COMMON

    """
    tems poco comunes, difciles de encontrar pero no nicos.
    """
    UNCOMMON

    """
    tems raros, con habilidades especiales o historias nicas.
    """
    RARE

    """
    tems extremadamente raros, con gran poder o significado.
    """
    LEGENDARY

    """
    tems nicos, con una sola existencia en el mundo.
    """
    UNIQUE
}

"""
Define el estado fsico de un tem, indicando su grado de desgaste o conservacin.
"""
enum ItemCondition {
    """
    El tem est en perfectas condiciones, sin daos ni desgaste.
    """
    PRISTINE

    """
    El tem muestra signos de uso, pero an est en buen estado.
    """
    USED

    """
    El tem est daado o desgastado, pero sigue siendo funcional.
    """
    WORN

    """
    El tem est roto o inutilizable en su estado actual.
    """
    BROKEN

    """
    El tem ha sido encantado o alterado mgicamente.
    """
    ENCHANTED

    """
    El tem est corrodo o en proceso de deterioro.
    """
    CORRODED
}

"""
Define la relacin entre dos tems.
Puede representar combinaciones, piezas de un set, transformacin y otras interacciones.
"""
enum ItemItemRelation {
    # Relaciones de combinacin y mejora
    """
    Los tems se pueden combinar para formar un nuevo objeto.
    """
    COMBINABLE

    """
    Uno de los tems es un componente necesario para otro.
    """
    COMPONENT

    """
    Los tems forman parte de un set o conjunto especial.
    """
    SET_ITEM

    """
    Un tem puede evolucionar en otro mediante uso o mejora.
    """
    EVOLUTION

    # Relaciones de influencia
    """
    Los tems son opuestos o tienen efectos que se anulan mutuamente.
    """
    OPPOSITE

    """
    Los tems tienen una conexin histrica o mitolgica.
    """
    LINKED_HISTORY

    """
    Uno de los tems fue creado a partir del otro.
    """
    DERIVED_FROM
}

"""
Define la relacin entre un tem y una ubicacin.
Puede representar su almacenamiento, hallazgo o prdida.
"""
enum ItemLocationRelation {
    # Relaciones de posesin y almacenamiento
    """
    El tem est guardado o almacenado en la ubicacin.
    """
    STORED

    """
    El tem fue encontrado en la ubicacin.
    """
    DISCOVERED

    """
    El tem est oculto o sellado en la ubicacin.
    """
    SEALED

    """
    El tem est perdido o abandonado en la ubicacin.
    """
    LOST

    # Relaciones de creacin y destruccin
    """
    El tem fue forjado, creado o ensamblado en la ubicacin.
    """
    CREATED

    """
    El tem fue destruido o desmantelado en la ubicacin.
    """
    DESTROYED
}

"""
Define la relacin entre un tem y un evento.
Puede representar su uso, descubrimiento, destruccin y ms.
"""
enum ItemEventRelation {
    # Relaciones de descubrimiento y posesin
    """
    El tem fue descubierto o adquirido durante el evento.
    """
    DISCOVERED

    """
    El tem fue entregado o transferido a otra entidad en el evento.
    """
    TRADED

    """
    El tem fue robado o perdido durante el evento.
    """
    STOLEN

    # Relaciones de influencia y uso
    """
    El tem fue utilizado activamente en el evento.
    """
    USED

    """
    El tem fue clave para el desarrollo o desenlace del evento.
    """
    KEY_ITEM

    """
    El tem fue destruido o inutilizado durante el evento.
    """
    DESTROYED
}
`, BuiltIn: false},
	{Name: "../../../graphql/Item/input.graphqls", Input: `"""
Estructura para crear un nuevo tem dentro de un mundo.
"""
input CreateItemInput {
    """
    ID del mundo al que pertenece el tem.
    """
    worldId: ID!

    """
    Nombre del tem.
    """
    name: String!

    """
    Descripcin del tem, incluyendo su historia y propiedades nicas.
    """
    description: String!

    """
    Clasificacin del tem segn su funcin o propsito.
    """
    type: ItemType!

    """
    Rareza del tem dentro del mundo (comn, poco comn, raro, legendario).
    """
    rarity: ItemRarity!

    """
    Espacio donde se equipa el tem en el cuerpo o inventario.
    """
    slot: ItemSlot!

    """
    Material principal del que est hecho el tem.
    """
    material: String!

    """
    Estado del tem (nuevo, desgastado, roto, encantado, etc.).
    """
    condition: ItemCondition!

    """
    Peso del tem en kilogramos (kg).
    """
    weight: Float!

    """
    Dimensiones del tem (alto, ancho, largo).
    """
    dimensions: String!

    """
    Fecha de creacin o forja del tem (opcional).
    """
    creationDate: String

    """
    Fecha de destruccin del tem (opcional, si ya no existe).
    """
    destructionDate: String

    # Propiedades especiales
    """
    Indica si el tem tiene propiedades mgicas o sobrenaturales.
    """
    isMagical: Boolean!

    """
    Lista de habilidades o efectos que posee el tem (si es mgico o especial).
    """
    abilities: [String!]!

    """
    Costo del tem en la moneda estndar del mundo.
    """
    value: Float!
}

"""
Estructura para actualizar un tem existente.
"""
input UpdateItemInput {
    """
    ID del tem a modificar.
    """
    id: ID!

    """
    Nuevo nombre del tem (opcional).
    """
    name: String

    """
    Nueva descripcin del tem (opcional).
    """
    description: String

    """
    Modificar la clasificacin del tem (opcional).
    """
    type: ItemType

    """
    Modificar la rareza del tem (opcional).
    """
    rarity: ItemRarity

    """
    Modificar el espacio donde se equipa el tem (opcional).
    """
    slot: ItemSlot

    """
    Modificar el material del tem (opcional).
    """
    material: String

    """
    Modificar el estado del tem (opcional).
    """
    condition: ItemCondition

    """
    Modificar el peso del tem (opcional).
    """
    weight: Float

    """
    Modificar las dimensiones del tem (opcional).
    """
    dimensions: String

    """
    Modificar la fecha de creacin del tem (opcional).
    """
    creationDate: String

    """
    Modificar la fecha de destruccin del tem (opcional).
    """
    destructionDate: String

    # Propiedades especiales
    """
    Modificar si el tem tiene propiedades mgicas (opcional).
    """
    isMagical: Boolean

    """
    Modificar las habilidades del tem (opcional).
    """
    abilities: [String!]

    """
    Modificar el costo del tem (opcional).
    """
    value: Float
}
`, BuiltIn: false},
	{Name: "../../../graphql/Item/type.graphqls", Input: `"""
Representa un tem dentro del mundo ficticio.
Incluye datos generales, caractersticas, propiedades y relaciones con otras entidades.
"""
type Item implements Entity {
    # Identificacin y metadatos
    """
    Identificador nico del tem.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creacin del tem en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de ltima actualizacin del tem en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Informacin general
    """
    Nombre del tem.
    """
    name: String!

    """
    Descripcin del tem, incluyendo su historia y propiedades nicas.
    """
    description: String!

    """
    Clasificacin del tem segn su funcin o propsito.
    """
    type: ItemType!

    """
    Rareza del tem dentro del mundo (comn, poco comn, raro, legendario).
    """
    rarity: ItemRarity!

    """
    Espacio donde se equipa el tem en el cuerpo o inventario.
    """
    slot: ItemSlot!

    """
    Material principal del que est hecho el tem.
    """
    material: String!

    """
    Estado del tem (nuevo, desgastado, roto, encantado, etc.).
    """
    condition: ItemCondition!

    """
    Peso del tem en kilogramos (kg).
    """
    weight: Float!

    """
    Dimensiones del tem (alto, ancho, largo).
    """
    dimensions: String!

    """
    Fecha de creacin o forja del tem (opcional).
    """
    creationDate: String

    """
    Fecha de destruccin del tem (opcional, si ya no existe).
    """
    destructionDate: String

    # Propiedades especiales
    """
    Indica si el tem tiene propiedades mgicas o sobrenaturales.
    """
    isMagical: Boolean!

    """
    Lista de habilidades o efectos que posee el tem (si es mgico o especial).
    """
    abilities: [String!]!

    """
    Costo del tem en la moneda estndar del mundo.
    """
    value: Float!

    # Relaciones con otras entidades
    """
    Lista de personajes que han tenido o usado el tem.
    """
    characters: [CharacterItem!]!

    """
    Lista de facciones que han posedo o utilizado el tem.
    """
    factions: [FactionItem!]!

    """
    Lista de eventos en los que el tem ha jugado un papel importante.
    """
    events: [ItemEvent!]!

    """
    Lista de ubicaciones donde el tem ha estado o puede encontrarse.
    """
    locations: [ItemLocation!]!

    """
    Lista de otros tems relacionados (artefactos combinables, piezas de un set, etc.).
    """
    relatedItems: [ItemItem!]!
}

"""
Define la relacin entre un tem y un evento.
Puede representar su uso, descubrimiento, destruccin y ms.
"""
type ItemEvent {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El item con el que el evento tiene una relacin.
    """
    item: Item!

    """
    El evento con el que el tem tiene una relacin.
    """
    event: Event!

    """
    Tipo de relacin entre el tem y el evento (descubrimiento, destruccin, uso, etc.).
    """
    relation: ItemEventRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre un tem y una ubicacin.
Puede representar su almacenamiento, hallazgo o prdida.
"""
type ItemLocation {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El tem con el que la ubicacin tiene una relacin.
    """
    item: Item!

    """
    La ubicacin con la que el tem tiene una relacin.
    """
    with: Location!

    """
    Tipo de relacin entre el tem y la ubicacin (almacenado, perdido, descubierto, etc.).
    """
    relation: ItemLocationRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre dos tems.
Puede representar combinaciones, piezas de un set o evolucin.
"""
type ItemItem {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El otro tem con el que se establece la relacin.
    """
    item: Item!

    """
    Tipo de relacin entre ambos tems (combinables, piezas de un set, evolucin, etc.).
    """
    relation: ItemItemRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/Location/enum.graphqls", Input: `"""
Clasifica las ubicaciones segn su naturaleza y propsito.
Incluye ciudades, mazmorras, asentamientos y entornos naturales.
"""
enum LocationType {
    # Asentamientos y ciudades
    """
    Una ciudad grande con estructuras avanzadas y una alta poblacin.
    """
    CITY

    """
    Una pequea aldea o comunidad rural.
    """
    VILLAGE

    """
    Un castillo o fortaleza con fines defensivos o administrativos.
    """
    FORTRESS

    """
    Un puesto comercial o enclave en una zona aislada.
    """
    OUTPOST

    # Entornos naturales
    """
    Un bosque denso con vegetacin abundante.
    """
    FOREST

    """
    Una regin desrtica con escasez de agua y temperaturas extremas.
    """
    DESERT

    """
    Una cueva natural o sistema de cavernas subterrneas.
    """
    CAVE

    """
    Un cuerpo de agua, como un lago, ro o mar.
    """
    WATER_BODY

    """
    Una cadena montaosa o rea rocosa con elevaciones pronunciadas.
    """
    MOUNTAINS

    """
    Una isla o archipilago rodeado de agua.
    """
    ISLAND

    """
    Una zona pantanosa con terrenos inestables y humedad alta.
    """
    SWAMP

    # Lugares artificiales y msticos
    """
    Una mazmorra o estructura subterrnea con secretos ocultos.
    """
    DUNGEON

    """
    Un templo o santuario con significado religioso o espiritual.
    """
    TEMPLE

    """
    Un portal interdimensional o conexin con otro plano de existencia.
    """
    PORTAL

    """
    Un laboratorio o taller donde se realizan experimentos cientficos o mgicos.
    """
    LABORATORY
}

"""
Define el nivel de accesibilidad de una ubicacin.
Indica si es pblica, restringida, oculta o de difcil acceso.
"""
enum LocationAccessibility {
    """
    Ubicacin de libre acceso para cualquier persona.
    """
    PUBLIC

    """
    Ubicacin restringida, accesible solo para ciertos grupos o con permisos especiales.
    """
    RESTRICTED

    """
    Ubicacin oculta o secreta, su existencia no es de conocimiento pblico.
    """
    HIDDEN

    """
    Ubicacin de acceso extremadamente difcil por razones naturales o mgicas.
    """
    INACCESSIBLE
}

"""
Define la relacin entre dos ubicaciones.
Puede representar conexiones geogrficas, polticas o mgicas.
"""
enum LocationLocationRelation {
    """
    Una ubicacin est dentro de otra (ej. ciudad dentro de un reino).
    """
    CONTAINED_WITHIN

    """
    Las ubicaciones estn conectadas por caminos, tneles o portales.
    """
    CONNECTED

    """
    Una ubicacin es la capital o centro administrativo de otra.
    """
    CAPITAL

    """
    Las ubicaciones son rivales o han tenido conflictos histricos.
    """
    RIVALRY
}

"""
Define la relacin entre una ubicacin y un evento.
Puede representar batallas, desastres, fundaciones y ms.
"""
enum LocationEventRelation {
    """
    El evento ocurri en esta ubicacin.
    """
    OCCURRED_HERE

    """
    La ubicacin fue destruida o gravemente afectada por el evento.
    """
    DESTROYED

    """
    El evento llev a la fundacin de la ubicacin.
    """
    FOUNDED

    """
    La ubicacin fue abandonada como resultado del evento.
    """
    ABANDONED
}

"""
Define la relacin entre una ubicacin y un mundo.
Puede representar su existencia, influencia interdimensional y ms.
"""
enum LocationWorldRelation {
    # Existencia y origen
    """
    La ubicacin es originaria de este mundo.
    """
    NATIVE

    """
    La ubicacin fue creada artificialmente en este mundo.
    """
    ARTIFICIAL

    """
    La ubicacin existe en mltiples mundos al mismo tiempo (multiversal, interdimensional).
    """
    MULTIVERSE_EXISTENCE

    # Conexiones y accesibilidad
    """
    La ubicacin tiene portales o conexiones con este mundo.
    """
    CONNECTED

    """
    La ubicacin es inaccesible desde este mundo sin medios especiales.
    """
    INACCESSIBLE

    """
    La ubicacin es una anomala dentro del mundo (cambio de realidad, error mgico).
    """
    ANOMALY
}
`, BuiltIn: false},
	{Name: "../../../graphql/Location/input.graphqls", Input: `"""
Estructura para crear una nueva ubicacin dentro de un mundo.
"""
input CreateLocationInput {
    """
    ID del mundo al que pertenece la ubicacin.
    """
    worldId: ID!

    """
    Nombre de la ubicacin.
    """
    name: String!

    """
    Descripcin detallada de la ubicacin, incluyendo su historia y caractersticas.
    """
    description: String!

    """
    Clasificacin de la ubicacin segn su tipo (ciudad, bosque, mazmorra, etc.).
    """
    type: LocationType!

    """
    Regin o territorio al que pertenece la ubicacin.
    """
    region: String!

    """
    Coordenadas geogrficas aproximadas (latitud, longitud).
    """
    coordinates: String!

    """
    Nivel de accesibilidad de la ubicacin (pblica, restringida, oculta, etc.).
    """
    accessibility: LocationAccessibility!

    """
    Indica si la ubicacin es natural o artificial.
    """
    isNatural: Boolean!

    """
    Clima predominante en la ubicacin.
    """
    climate: String!

    """
    Ecosistema de la ubicacin (bosque, desierto, pantano, etc.).
    """
    ecosystem: String!
}

"""
Estructura para actualizar una ubicacin existente.
"""
input UpdateLocationInput {
    """
    ID de la ubicacin a modificar.
    """
    id: ID!

    """
    Nuevo nombre de la ubicacin (opcional).
    """
    name: String

    """
    Nueva descripcin de la ubicacin (opcional).
    """
    description: String

    """
    Modificar la clasificacin de la ubicacin (opcional).
    """
    type: LocationType

    """
    Modificar la regin o territorio de la ubicacin (opcional).
    """
    region: String

    """
    Modificar las coordenadas de la ubicacin (opcional).
    """
    coordinates: String

    """
    Modificar el nivel de accesibilidad de la ubicacin (opcional).
    """
    accessibility: LocationAccessibility

    """
    Modificar si la ubicacin es natural o artificial (opcional).
    """
    isNatural: Boolean

    """
    Modificar el clima de la ubicacin (opcional).
    """
    climate: String

    """
    Modificar el ecosistema de la ubicacin (opcional).
    """
    ecosystem: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/Location/type.graphqls", Input: `"""
Representa una ubicacin dentro del mundo ficticio.
Incluye datos generales, caractersticas geogrficas y relaciones con otras entidades.
"""
type Location implements Entity {
    # Identificacin y metadatos
    """
    Identificador nico de la ubicacin.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creacin de la ubicacin en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de ltima actualizacin de la ubicacin en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Informacin general
    """
    Nombre de la ubicacin.
    """
    name: String!

    """
    Descripcin detallada de la ubicacin, incluyendo su historia y caractersticas.
    """
    description: String!

    """
    Clasificacin de la ubicacin segn su tipo (ciudad, bosque, mazmorra, etc.).
    """
    type: LocationType!

    """
    Regin o territorio al que pertenece la ubicacin.
    """
    region: String!

    """
    Coordenadas geogrficas aproximadas (latitud, longitud).
    """
    coordinates: String!

    """
    Nivel de accesibilidad de la ubicacin (pblica, restringida, oculta, etc.).
    """
    accessibility: LocationAccessibility!

    """
    Indica si la ubicacin es natural o artificial.
    """
    isNatural: Boolean!

    """
    Clima predominante en la ubicacin.
    """
    climate: String!

    """
    Ecosistema de la ubicacin (bosque, desierto, pantano, etc.).
    """
    ecosystem: String!

    # Relaciones con otras entidades
    """
    Lista de personajes que residen o han estado en la ubicacin.
    """
    characters: [CharacterLocation!]!

    """
    Lista de criaturas que habitan o han pasado por la ubicacin.
    """
    creatures: [CreatureLocation!]!

    """
    Lista de facciones que controlan o han operado en la ubicacin.
    """
    factions: [FactionLocation!]!

    """
    Lista de eventos histricos que han ocurrido en la ubicacin.
    """
    events: [LocationEvent!]!

    """
    Lista de tems que han sido encontrados o almacenados en la ubicacin.
    """
    items: [ItemLocation!]!

    """
    Lista de otras ubicaciones relacionadas (ciudades dentro de un pas, conexiones mgicas, etc.).
    """
    relatedLocations: [LocationLocation!]!

    """
    Lista de mundos en los que existe o influye esta ubicacin.
    """
    worlds: [LocationWorld!]!
}

"""
Define la relacin entre dos ubicaciones.
Puede representar conexiones geogrficas, polticas o mgicas.
"""
type LocationLocation {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La otra ubicacin con la que se establece la relacin.
    """
    location: Location!

    """
    Tipo de relacin entre ambas ubicaciones (contenida dentro, conectada, capital, etc.).
    """
    relation: LocationLocationRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre una ubicacin y un evento.
Puede representar batallas, desastres, fundaciones y ms.
"""
type LocationEvent {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La ubicacin con la que el evento tiene una relacin.
    """
    location: Location!

    """
    El evento con el que la ubicacin tiene una relacin.
    """
    event: Event!

    """
    Tipo de relacin entre la ubicacin y el evento (batalla, destruccin, fundacin, etc.).
    """
    relation: LocationEventRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre una ubicacin y un mundo.
Puede representar su existencia, conexiones interdimensionales o anomalas.
"""
type LocationWorld {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La ubicacin con la que el mundo tiene una relacin.
    """
    location: Location!

    """
    El mundo con el que la ubicacin tiene una relacin.
    """
    world: World!

    """
    Tipo de relacin entre la ubicacin y el mundo (nativa, artificial, conectada, etc.).
    """
    relation: LocationWorldRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/mutation.graphqls", Input: `"""
Mutaciones para crear, actualizar y eliminar universos.
"""
type Mutation {
    """
    Crea un nuevo personaje dentro de un mundo.
    """
    createCharacter(input: CreateCharacterInput!): Character!

    """
    Actualiza los datos de un personaje existente.
    """
    updateCharacter(input: UpdateCharacterInput!): Character!

    """
    Elimina un personaje por su ID.
    """
    deleteCharacter(id: ID!): Boolean!

    """
    Crea una nueva criatura dentro de un mundo.
    """
    createCreature(input: CreateCreatureInput!): Creature!

    """
    Actualiza los datos de una criatura existente.
    """
    updateCreature(input: UpdateCreatureInput!): Creature!

    """
    Elimina una criatura por su ID.
    """
    deleteCreature(id: ID!): Boolean!

    """
    Crea un nuevo tem dentro de un mundo.
    """
    createItem(input: CreateItemInput!): Item!

    """
    Actualiza los datos de un tem existente.
    """
    updateItem(input: UpdateItemInput!): Item!

    """
    Elimina un tem por su ID.
    """
    deleteItem(id: ID!): Boolean!

    """
    Crea una nueva ubicacin dentro de un mundo.
    """
    createLocation(input: CreateLocationInput!): Location!

    """
    Actualiza los datos de una ubicacin existente.
    """
    updateLocation(input: UpdateLocationInput!): Location!

    """
    Elimina una ubicacin por su ID.
    """
    deleteLocation(id: ID!): Boolean!

    """
    Crea una nueva faccin dentro de un mundo.
    """
    createFaction(input: CreateFactionInput!): Faction!

    """
    Actualiza los datos de una faccin existente.
    """
    updateFaction(input: UpdateFactionInput!): Faction!

    """
    Elimina una faccin por su ID.
    """
    deleteFaction(id: ID!): Boolean!

    """
    Crea un nuevo evento dentro de un mundo.
    """
    createEvent(input: CreateEventInput!): Event!

    """
    Actualiza los datos de un evento existente.
    """
    updateEvent(input: UpdateEventInput!): Event!

    """
    Elimina un evento por su ID.
    """
    deleteEvent(id: ID!): Boolean!

    """
    Crea un nuevo mundo dentro de un universo.
    """
    createWorld(input: CreateWorldInput!): World!

    """
    Actualiza los datos de un mundo existente.
    """
    updateWorld(input: UpdateWorldInput!): World!

    """
    Elimina un mundo por su ID.
    """
    deleteWorld(id: ID!): Boolean!

    """
    Crea un nuevo universo.
    """
    createUniverse(input: CreateUniverseInput!): Universe!

    """
    Actualiza los datos de un universo existente.
    """
    updateUniverse(input: UpdateUniverseInput!): Universe!

    """
    Elimina un universo por su ID.
    """
    deleteUniverse(id: ID!): Boolean!
}
`, BuiltIn: false},
	{Name: "../../../graphql/query.graphqls", Input: `"""
Consultas relacionadas con los universos dentro del sistema.
"""
type Query {
    # Obtencin de Personajes
    """
    Devuelve un personaje especfico por su ID.
    """
    character(id: ID!): Character

    """
    Devuelve una lista de personajes dentro de un mundo, con paginacin opcional.
    """
    characters(worldId: ID!, limit: Int = 10, offset: Int = 0): [Character!]!

    # Obtencin de Criaturas
    """
    Devuelve una criatura especfica por su ID.
    """
    creature(id: ID!): Creature

    """
    Devuelve una lista de criaturas dentro de un mundo, con paginacin opcional.
    """
    creatures(worldId: ID!, limit: Int = 10, offset: Int = 0): [Creature!]!

    # Obtencin de tems
    """
    Devuelve un tem especfico por su ID.
    """
    item(id: ID!): Item

    """
    Devuelve una lista de tems dentro de un mundo, con paginacin opcional.
    """
    items(worldId: ID!, limit: Int = 10, offset: Int = 0): [Item!]!

    # Obtencin de Ubicaciones
    """
    Devuelve una ubicacin especfica por su ID.
    """
    location(id: ID!): Location

    """
    Devuelve una lista de ubicaciones dentro de un mundo, con paginacin opcional.
    """
    locations(worldId: ID!, limit: Int = 10, offset: Int = 0): [Location!]!

    # Obtencin de Facciones
    """
    Devuelve una faccin especfica por su ID.
    """
    faction(id: ID!): Faction

    """
    Devuelve una lista de facciones dentro de un mundo, con paginacin opcional.
    """
    factions(worldId: ID!, limit: Int = 10, offset: Int = 0): [Faction!]!

    # Obtencin de Eventos
    """
    Devuelve un evento especfico por su ID.
    """
    event(id: ID!): Event

    """
    Devuelve una lista de eventos dentro de un mundo, con paginacin opcional.
    """
    events(worldId: ID!, limit: Int = 10, offset: Int = 0): [Event!]!

    # Obtencin de Mundos
    """
    Devuelve un mundo especfico por su ID.
    """
    world(id: ID!): World

    """
    Devuelve una lista de mundos, con paginacin opcional.
    """
    worlds(universeId: ID!, limit: Int = 10, offset: Int = 0): [World!]!

    # Obtencin de Universos
    """
    Devuelve un universo especfico por su ID.
    """
    universe(id: ID!): Universe

    """
    Devuelve una lista de universos, con paginacin opcional.
    """
    universes(limit: Int = 10, offset: Int = 0): [Universe!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/type.base.graphqls", Input: `directive @goTag(key: String!, value: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

type Response {
    status: Boolean!
    message: String
}

interface Entity {
    id: ID!
    createdAt: String!
    updatedAt: String!
    name: String!
    description: String!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Universe/input.graphqls", Input: `"""
Estructura para crear un nuevo universo.
"""
input CreateUniverseInput {
    """
    Nombre del universo.
    """
    name: String!

    """
    Descripcin del universo, incluyendo historia y detalles generales.
    """
    description: String!

    """
    Ao de creacin o punto de referencia inicial del universo.
    """
    startYear: Int
}

"""
Estructura para actualizar un universo existente.
"""
input UpdateUniverseInput {
    """
    ID del universo a modificar.
    """
    id: ID!

    """
    Nuevo nombre del universo (opcional).
    """
    name: String

    """
    Nueva descripcin del universo (opcional).
    """
    description: String

    """
    Modificar el ao de inicio del universo (opcional).
    """
    startYear: Int

    """
    Indicar si el universo sigue en expansin o ha finalizado (opcional).
    """
    isActive: Boolean
}
`, BuiltIn: false},
	{Name: "../../../graphql/Universe/type.graphqls", Input: `"""
Representa un universo dentro del sistema de worldbuilding.
Un universo agrupa mltiples mundos y sus respectivas entidades.
"""
type Universe implements Entity {
    # Identificacin y metadatos
    """
    Identificador nico del universo.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creacin del universo en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de ltima actualizacin del universo en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Informacin general
    """
    Nombre del universo.
    """
    name: String!

    """
    Descripcin del universo, incluyendo su historia general y concepto.
    """
    description: String!

    """
    Ao de creacin o punto de partida del universo en el sistema.
    """
    startYear: Int!

    """
    Indica si el universo est activo o archivado.
    """
    isActive: Boolean!

    # Contenido del universo
    """
    Lista de mundos dentro de este universo.
    """
    worlds: [World!]!

    """
    Lista de facciones que operan en este universo.
    """
    factions: [Faction!]!

    """
    Lista de personajes que pertenecen a este universo.
    """
    characters: [Character!]!

    """
    Lista de criaturas que existen en este universo.
    """
    creatures: [Creature!]!

    """
    Lista de eventos importantes ocurridos en este universo.
    """
    events: [Event!]!

    """
    Lista de ubicaciones dentro de este universo.
    """
    locations: [Location!]!

    """
    Lista de tems nicos o de importancia en el universo.
    """
    items: [Item!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/World/enum.graphqls", Input: `"""
Clasifica los mundos segn su naturaleza, origen y caractersticas principales.
"""
enum WorldType {
    # Mundos fsicos
    """
    Un mundo con caractersticas similares a la Tierra.
    """
    TERRESTRIAL

    """
    Un mundo desrtico, rido y con escasez de agua.
    """
    DESERT

    """
    Un mundo ocenico con vastas masas de agua y pocas tierras emergidas.
    """
    OCEANIC

    """
    Un mundo cubierto de hielo y nieve con temperaturas extremas.
    """
    ICE

    """
    Un mundo volcnico, con actividad geolgica intensa.
    """
    VOLCANIC

    """
    Un mundo gaseoso sin superficie slida (tipo Jpiter o Saturno).
    """
    GAS_GIANT

    # Mundos sobrenaturales o interdimensionales
    """
    Un mundo conectado a lo divino o gobernado por entidades celestiales.
    """
    DIVINE_REALM

    """
    Un mundo demonaco, catico o infernal.
    """
    HELLISH

    """
    Un mundo de sueos, ilusiones o materializacin del pensamiento.
    """
    DREAM_REALM

    """
    Un mundo que existe en mltiples dimensiones simultneamente.
    """
    MULTIDIMENSIONAL

    """
    Un mundo artificialmente construido, como una megaestructura o nave-mundo.
    """
    ARTIFICIAL

    """
    Un mundo apocalptico o en ruinas, con civilizaciones colapsadas.
    """
    POST_APOCALYPTIC

    """
    Un mundo que ha sido abandonado o en el que la vida ha desaparecido.
    """
    DEAD_WORLD
}

"""
Define la relacin entre un mundo y un evento.
Puede representar desastres, descubrimientos, guerras y ms.
"""
enum WorldEventRelation {
    """
    El evento ocurri en este mundo.
    """
    OCCURRED_HERE

    """
    El evento llev a la destruccin parcial o total del mundo.
    """
    DEVASTATED

    """
    El evento llev al descubrimiento del mundo por otras civilizaciones.
    """
    DISCOVERED

    """
    El evento alter la realidad o estructura del mundo de manera significativa.
    """
    ALTERED
}

"""
Define la relacin entre dos mundos.
Puede representar conexiones interdimensionales, origen compartido y ms.
"""
enum WorldWorldRelation {
    """
    Los mundos estn conectados por portales, magia o tecnologa avanzada.
    """
    CONNECTED

    """
    Un mundo es una versin alternativa o divergente del otro.
    """
    ALTERNATE_VERSION

    """
    Uno de los mundos fue creado artificialmente a partir del otro.
    """
    CREATED_FROM

    """
    Los mundos comparten un mismo origen csmico o mitolgico.
    """
    SHARED_ORIGIN
}
`, BuiltIn: false},
	{Name: "../../../graphql/World/input.graphqls", Input: `"""
Estructura para crear un nuevo mundo dentro de un universo.
"""
input CreateWorldInput {
    """
    ID del universo al que pertenece el mundo.
    """
    universeId: ID!

    """
    Nombre del mundo.
    """
    name: String!

    """
    Descripcin detallada del mundo, incluyendo historia y caractersticas nicas.
    """
    description: String!

    """
    Clasificacin del mundo segn su naturaleza y origen.
    """
    type: WorldType!

    """
    Nivel tecnolgico predominante en el mundo (medieval, avanzado, mgico, etc.).
    """
    technologyLevel: String!

    """
    Principales fuentes de energa utilizadas en el mundo.
    """
    energySources: [String!]!

    """
    Gravedad relativa del mundo en comparacin con la Tierra (1.0 = gravedad terrestre).
    """
    gravity: Float!

    """
    Tamao del mundo en relacin a la Tierra (1.0 = tamao terrestre).
    """
    size: Float!

    """
    Nmero de lunas o satlites naturales del mundo.
    """
    moons: Int!

    """
    Nmero de soles o estrellas alrededor de las cuales orbita el mundo.
    """
    stars: Int!

    """
    Clima predominante del mundo.
    """
    climate: String!

    """
    Ecosistema y bioma dominante del mundo.
    """
    ecosystem: String!

    """
    Indica si el mundo tiene atmsfera y si es respirable por humanos.
    """
    hasAtmosphere: Boolean!

    """
    Indica si el mundo est habitado por seres vivos.
    """
    isHabitable: Boolean!
}

"""
Estructura para actualizar un mundo existente.
"""
input UpdateWorldInput {
    """
    ID del mundo a modificar.
    """
    id: ID!

    """
    Nuevo nombre del mundo (opcional).
    """
    name: String

    """
    Nueva descripcin del mundo (opcional).
    """
    description: String

    """
    Modificar la clasificacin del mundo (opcional).
    """
    type: WorldType

    """
    Modificar el nivel tecnolgico del mundo (opcional).
    """
    technologyLevel: String

    """
    Modificar las fuentes de energa utilizadas en el mundo (opcional).
    """
    energySources: [String!]

    """
    Modificar la gravedad del mundo (opcional).
    """
    gravity: Float

    """
    Modificar el tamao del mundo en relacin a la Tierra (opcional).
    """
    size: Float

    """
    Modificar el nmero de lunas del mundo (opcional).
    """
    moons: Int

    """
    Modificar el nmero de estrellas alrededor del mundo (opcional).
    """
    stars: Int

    """
    Modificar el clima del mundo (opcional).
    """
    climate: String

    """
    Modificar el ecosistema y bioma del mundo (opcional).
    """
    ecosystem: String

    """
    Modificar si el mundo tiene atmsfera y si es respirable (opcional).
    """
    hasAtmosphere: Boolean

    """
    Modificar si el mundo es habitable (opcional).
    """
    isHabitable: Boolean
}
`, BuiltIn: false},
	{Name: "../../../graphql/World/type.graphqls", Input: `"""
Representa un mundo dentro de un universo ficticio.
Incluye datos generales, caractersticas fsicas y conexiones interdimensionales.
"""
type World implements Entity {
    # Identificacin y metadatos
    """
    Identificador nico del mundo.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creacin del mundo en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de ltima actualizacin del mundo en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Informacin general
    """
    Nombre del mundo.
    """
    name: String!

    """
    Descripcin detallada del mundo, incluyendo su historia y caractersticas nicas.
    """
    description: String!

    """
    Clasificacin del mundo segn su naturaleza y origen.
    """
    type: WorldType!

    """
    El universo al que pertenece este mundo.
    """
    universe: Universe!

    """
    Nivel tecnolgico predominante en el mundo (medieval, avanzado, mgico, etc.).
    """
    technologyLevel: String!

    """
    Principales fuentes de energa utilizadas en el mundo.
    """
    energySources: [String!]!

    """
    Gravedad relativa del mundo en comparacin con la Tierra (1.0 = gravedad terrestre).
    """
    gravity: Float!

    """
    Tamao del mundo en relacin a la Tierra (1.0 = tamao terrestre).
    """
    size: Float!

    """
    Nmero de lunas o satlites naturales del mundo.
    """
    moons: Int!

    """
    Nmero de soles o estrellas alrededor de las cuales orbita el mundo.
    """
    stars: Int!

    """
    Clima predominante del mundo.
    """
    climate: String!

    """
    Ecosistema y bioma dominante del mundo.
    """
    ecosystem: String!

    """
    Indica si el mundo tiene atmsfera y si es respirable por humanos.
    """
    hasAtmosphere: Boolean!

    """
    Indica si el mundo est habitado por seres vivos.
    """
    isHabitable: Boolean!

    # Relaciones con otras entidades
    """
    Lista de personajes asociados a este mundo.
    """
    characters: [CharacterWorld!]!

    """
    Lista de criaturas que existen o han existido en este mundo.
    """
    creatures: [CreatureWorld!]!

    """
    Lista de facciones con presencia o influencia en este mundo.
    """
    factions: [FactionWorld!]!

    """
    Lista de eventos importantes que han ocurrido en este mundo.
    """
    events: [WorldEvent!]!

    """
    Lista de ubicaciones dentro del mundo.
    """
    locations: [LocationWorld!]!

    """
    Lista de mundos conectados a este a travs de portales o interacciones interdimensionales.
    """
    connectedWorlds: [WorldWorld!]!
}

"""
Define la relacin entre un mundo y un evento.
Puede representar desastres, descubrimientos, guerras y ms.
"""
type WorldEvent {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El mundo en el que ocurri el evento.
    """
    world: World!
    """
    El evento con el que el mundo tiene una relacin.
    """
    event: Event!

    """
    Tipo de relacin entre el mundo y el evento (destruccin, descubrimiento, alteracin, etc.).
    """
    relation: WorldEventRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}

"""
Define la relacin entre dos mundos.
Puede representar conexiones interdimensionales, origen compartido y ms.
"""
type WorldWorld {
    """
    El id de la relacin entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El otro mundo con el que se establece la relacin.
    """
    world: World!

    """
    Tipo de relacin entre ambos mundos (conectados, creados uno a partir del otro, etc.).
    """
    relation: WorldWorldRelation!

    """
    Fecha en que comenz la relacin (opcional).
    """
    startDate: String

    """
    Fecha en que termin la relacin (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createCharacter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateCharacterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateCharacterInput2ordomapgraphmodelCreateCharacterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createCreature_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateCreatureInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateCreatureInput2ordomapgraphmodelCreateCreatureInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateEventInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateEventInput2ordomapgraphmodelCreateEventInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createFaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateFactionInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateFactionInput2ordomapgraphmodelCreateFactionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createItem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateItemInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateItemInput2ordomapgraphmodelCreateItemInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createLocation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateLocationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateLocationInput2ordomapgraphmodelCreateLocationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUniverse_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateUniverseInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateUniverseInput2ordomapgraphmodelCreateUniverseInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createWorld_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateWorldInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateWorldInput2ordomapgraphmodelCreateWorldInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteCharacter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteCreature_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteFaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteItem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteLocation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUniverse_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteWorld_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCharacter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateCharacterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateCharacterInput2ordomapgraphmodelUpdateCharacterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCreature_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateCreatureInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateCreatureInput2ordomapgraphmodelUpdateCreatureInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateEventInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateEventInput2ordomapgraphmodelUpdateEventInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateFaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateFactionInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateFactionInput2ordomapgraphmodelUpdateFactionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateItem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateItemInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateItemInput2ordomapgraphmodelUpdateItemInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateLocation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateLocationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateLocationInput2ordomapgraphmodelUpdateLocationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUniverse_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateUniverseInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateUniverseInput2ordomapgraphmodelUpdateUniverseInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateWorld_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateWorldInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateWorldInput2ordomapgraphmodelUpdateWorldInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_character_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_characters_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_creature_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_creatures_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_event_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_events_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_faction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_factions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_item_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_items_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_location_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_locations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_universe_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_universes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_world_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_worlds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["universeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("universeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["universeId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Character_id(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_name(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_description(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_type(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_birthDate(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_birthDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BirthDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_birthDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_height(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_weight(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_weight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_weight(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_isAlive(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_isAlive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_isAlive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_isMain(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_isMain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsMain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_isMain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_alignment(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_alignment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alignment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Alignment)
	fc.Result = res
	return ec.marshalOAlignment2ordomapgraphmodelAlignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_alignment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Alignment does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_characters(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterCharacter)
	fc.Result = res
	return ec.marshalNCharacterCharacter2ordomapgraphmodelCharacterCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterCharacter_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterCharacter_character(ctx, field)
			case "characterRelationLevel":
				return ec.fieldContext_CharacterCharacter_characterRelationLevel(ctx, field)
			case "familyRelation":
				return ec.fieldContext_CharacterCharacter_familyRelation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterCharacter_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterCharacter_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterCharacter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterCreature)
	fc.Result = res
	return ec.marshalNCharacterCreature2ordomapgraphmodelCharacterCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterCreature_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterCreature_character(ctx, field)
			case "creature":
				return ec.fieldContext_CharacterCreature_creature(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterCreature_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterCreature_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterCreature_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterCreature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_factions(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterFaction)
	fc.Result = res
	return ec.marshalNCharacterFaction2ordomapgraphmodelCharacterFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterFaction_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterFaction_character(ctx, field)
			case "faction":
				return ec.fieldContext_CharacterFaction_faction(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterFaction_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterFaction_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterFaction_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterFaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_events(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterEvent)
	fc.Result = res
	return ec.marshalNCharacterEvent2ordomapgraphmodelCharacterEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterEvent_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterEvent_character(ctx, field)
			case "event":
				return ec.fieldContext_CharacterEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_items(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterItem)
	fc.Result = res
	return ec.marshalNCharacterItem2ordomapgraphmodelCharacterItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterItem_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterItem_character(ctx, field)
			case "item":
				return ec.fieldContext_CharacterItem_item(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterItem_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterItem_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterItem_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_locations(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterLocation)
	fc.Result = res
	return ec.marshalNCharacterLocation2ordomapgraphmodelCharacterLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterLocation_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterLocation_character(ctx, field)
			case "location":
				return ec.fieldContext_CharacterLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterWorld)
	fc.Result = res
	return ec.marshalNCharacterWorld2ordomapgraphmodelCharacterWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterWorld_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterWorld_character(ctx, field)
			case "world":
				return ec.fieldContext_CharacterWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_characterRelationLevel(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_characterRelationLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CharacterRelationLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterRelationLevel)
	fc.Result = res
	return ec.marshalNCharacterRelationLevel2ordomapgraphmodelCharacterRelationLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_characterRelationLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterRelationLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_familyRelation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_familyRelation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FamilyRelation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FamilyRelation)
	fc.Result = res
	return ec.marshalOFamilyRelation2ordomapgraphmodelFamilyRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_familyRelation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FamilyRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_creature(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ordomapgraphmodelCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterCreatureRelation)
	fc.Result = res
	return ec.marshalNCharacterCreatureRelation2ordomapgraphmodelCharacterCreatureRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterCreatureRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ordomapgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterEventRelation)
	fc.Result = res
	return ec.marshalNCharacterEventRelation2ordomapgraphmodelCharacterEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_faction(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterFactionRelation)
	fc.Result = res
	return ec.marshalNCharacterFactionRelation2ordomapgraphmodelCharacterFactionRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterFactionRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_item(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ordomapgraphmodelItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterItemRelation)
	fc.Result = res
	return ec.marshalNCharacterItemRelation2ordomapgraphmodelCharacterItemRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterItemRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_location(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterLocationRelation)
	fc.Result = res
	return ec.marshalNCharacterLocationRelation2ordomapgraphmodelCharacterLocationRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterLocationRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_world(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ordomapgraphmodelWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterWorldRelation)
	fc.Result = res
	return ec.marshalNCharacterWorldRelation2ordomapgraphmodelCharacterWorldRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterWorldRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_id(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_name(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_description(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_type(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_species(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_species(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Species, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_species(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_intelligenceLevel(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_intelligenceLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntelligenceLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_intelligenceLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_height(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_weight(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_weight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_weight(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_birthDate(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_birthDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BirthDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_birthDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_isAlive(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_isAlive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_isAlive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_lifespan(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_lifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lifespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_lifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_isUnique(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_isUnique(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsUnique, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_isUnique(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_habitat(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_habitat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Habitat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_habitat(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_behavior(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_behavior(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Behavior, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_behavior(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_diet(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_diet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Diet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_diet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_abilities(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_abilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Abilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_abilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_characters(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterCreature)
	fc.Result = res
	return ec.marshalNCharacterCreature2ordomapgraphmodelCharacterCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterCreature_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterCreature_character(ctx, field)
			case "creature":
				return ec.fieldContext_CharacterCreature_creature(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterCreature_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterCreature_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterCreature_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterCreature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureCreature)
	fc.Result = res
	return ec.marshalNCreatureCreature2ordomapgraphmodelCreatureCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureCreature_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureCreature_creature(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureCreature_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureCreature_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureCreature_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureCreature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_factions(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureFaction)
	fc.Result = res
	return ec.marshalNCreatureFaction2ordomapgraphmodelCreatureFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureFaction_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureFaction_creature(ctx, field)
			case "faction":
				return ec.fieldContext_CreatureFaction_faction(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureFaction_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureFaction_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureFaction_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureFaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_events(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureEvent)
	fc.Result = res
	return ec.marshalNCreatureEvent2ordomapgraphmodelCreatureEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureEvent_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureEvent_creature(ctx, field)
			case "event":
				return ec.fieldContext_CreatureEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_locations(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureLocation)
	fc.Result = res
	return ec.marshalNCreatureLocation2ordomapgraphmodelCreatureLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureLocation_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureLocation_creature(ctx, field)
			case "location":
				return ec.fieldContext_CreatureLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureWorld)
	fc.Result = res
	return ec.marshalNCreatureWorld2ordomapgraphmodelCreatureWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureWorld_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureWorld_creature(ctx, field)
			case "world":
				return ec.fieldContext_CreatureWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureCreature_id(ctx context.Context, field graphql.CollectedField, obj *model.CreatureCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureCreature_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureCreature_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureCreature_creature(ctx context.Context, field graphql.CollectedField, obj *model.CreatureCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureCreature_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ordomapgraphmodelCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureCreature_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureCreature_relation(ctx context.Context, field graphql.CollectedField, obj *model.CreatureCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureCreature_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreatureCreatureRelation)
	fc.Result = res
	return ec.marshalNCreatureCreatureRelation2ordomapgraphmodelCreatureCreatureRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureCreature_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreatureCreatureRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureCreature_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureCreature_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureCreature_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureCreature_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureCreature_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureCreature_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_creature(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ordomapgraphmodelCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ordomapgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreatureEventRelation)
	fc.Result = res
	return ec.marshalNCreatureEventRelation2ordomapgraphmodelCreatureEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreatureEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_id(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_creature(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ordomapgraphmodelCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_faction(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_relation(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreatureFactionRelation)
	fc.Result = res
	return ec.marshalNCreatureFactionRelation2ordomapgraphmodelCreatureFactionRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreatureFactionRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_id(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_creature(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ordomapgraphmodelCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_location(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_relation(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreatureLocationRelation)
	fc.Result = res
	return ec.marshalNCreatureLocationRelation2ordomapgraphmodelCreatureLocationRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreatureLocationRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_id(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_creature(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ordomapgraphmodelCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_world(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ordomapgraphmodelWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_relation(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreatureWorldRelation)
	fc.Result = res
	return ec.marshalNCreatureWorldRelation2ordomapgraphmodelCreatureWorldRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreatureWorldRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_name(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_description(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_type(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventType)
	fc.Result = res
	return ec.marshalNEventType2ordomapgraphmodelEventType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_nature(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_nature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventNature)
	fc.Result = res
	return ec.marshalNEventNature2ordomapgraphmodelEventNature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_nature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventNature does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_startDate(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_endDate(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_isRecurring(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_isRecurring(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRecurring, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_isRecurring(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_significance(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_significance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Significance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventSignificance)
	fc.Result = res
	return ec.marshalNEventSignificance2ordomapgraphmodelEventSignificance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_significance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventSignificance does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_locations(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationEvent)
	fc.Result = res
	return ec.marshalNLocationEvent2ordomapgraphmodelLocationEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationEvent_id(ctx, field)
			case "location":
				return ec.fieldContext_LocationEvent_location(ctx, field)
			case "event":
				return ec.fieldContext_LocationEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_LocationEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_LocationEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_LocationEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorldEvent)
	fc.Result = res
	return ec.marshalNWorldEvent2ordomapgraphmodelWorldEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WorldEvent_id(ctx, field)
			case "world":
				return ec.fieldContext_WorldEvent_world(ctx, field)
			case "event":
				return ec.fieldContext_WorldEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_WorldEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_WorldEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_WorldEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorldEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_characters(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterEvent)
	fc.Result = res
	return ec.marshalNCharacterEvent2ordomapgraphmodelCharacterEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterEvent_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterEvent_character(ctx, field)
			case "event":
				return ec.fieldContext_CharacterEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureEvent)
	fc.Result = res
	return ec.marshalNCreatureEvent2ordomapgraphmodelCreatureEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureEvent_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureEvent_creature(ctx, field)
			case "event":
				return ec.fieldContext_CreatureEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_factions(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionEvent)
	fc.Result = res
	return ec.marshalNFactionEvent2ordomapgraphmodelFactionEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionEvent_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionEvent_faction(ctx, field)
			case "event":
				return ec.fieldContext_FactionEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_FactionEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_items(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ItemEvent)
	fc.Result = res
	return ec.marshalNItemEvent2ordomapgraphmodelItemEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ItemEvent_id(ctx, field)
			case "item":
				return ec.fieldContext_ItemEvent_item(ctx, field)
			case "event":
				return ec.fieldContext_ItemEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_ItemEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_ItemEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_ItemEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_relatedEvents(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_relatedEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedEvents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.EventEvent)
	fc.Result = res
	return ec.marshalNEventEvent2ordomapgraphmodelEventEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_relatedEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventEvent does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_id(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_name(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_description(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_type(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionType)
	fc.Result = res
	return ec.marshalNFactionType2ordomapgraphmodelFactionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_ideology(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_ideology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ideology, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_ideology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_status(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionStatus)
	fc.Result = res
	return ec.marshalNFactionStatus2ordomapgraphmodelFactionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_foundedDate(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_foundedDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FoundedDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_foundedDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_disbandedDate(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_disbandedDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisbandedDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_disbandedDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_influence(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_influence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Influence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionInfluence)
	fc.Result = res
	return ec.marshalNFactionInfluence2ordomapgraphmodelFactionInfluence(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_influence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionInfluence does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_locations(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionLocation)
	fc.Result = res
	return ec.marshalNFactionLocation2ordomapgraphmodelFactionLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionLocation_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionLocation_faction(ctx, field)
			case "location":
				return ec.fieldContext_FactionLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_FactionLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionWorld)
	fc.Result = res
	return ec.marshalNFactionWorld2ordomapgraphmodelFactionWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionWorld_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionWorld_faction(ctx, field)
			case "world":
				return ec.fieldContext_FactionWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_FactionWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_characters(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterFaction)
	fc.Result = res
	return ec.marshalNCharacterFaction2ordomapgraphmodelCharacterFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterFaction_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterFaction_character(ctx, field)
			case "faction":
				return ec.fieldContext_CharacterFaction_faction(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterFaction_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterFaction_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterFaction_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterFaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureFaction)
	fc.Result = res
	return ec.marshalNCreatureFaction2ordomapgraphmodelCreatureFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureFaction_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureFaction_creature(ctx, field)
			case "faction":
				return ec.fieldContext_CreatureFaction_faction(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureFaction_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureFaction_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureFaction_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureFaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_factions(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionFaction)
	fc.Result = res
	return ec.marshalNFactionFaction2ordomapgraphmodelFactionFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionFaction_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionFaction_faction(ctx, field)
			case "relation":
				return ec.fieldContext_FactionFaction_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionFaction_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionFaction_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionFaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_events(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionEvent)
	fc.Result = res
	return ec.marshalNFactionEvent2ordomapgraphmodelFactionEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionEvent_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionEvent_faction(ctx, field)
			case "event":
				return ec.fieldContext_FactionEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_FactionEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_items(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionItem)
	fc.Result = res
	return ec.marshalNFactionItem2ordomapgraphmodelFactionItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionItem_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionItem_faction(ctx, field)
			case "item":
				return ec.fieldContext_FactionItem_item(ctx, field)
			case "relation":
				return ec.fieldContext_FactionItem_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionItem_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionItem_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_faction(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ordomapgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionEventRelation)
	fc.Result = res
	return ec.marshalNFactionEventRelation2ordomapgraphmodelFactionEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionFaction_id(ctx context.Context, field graphql.CollectedField, obj *model.FactionFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionFaction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionFaction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionFaction_faction(ctx context.Context, field graphql.CollectedField, obj *model.FactionFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionFaction_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionFaction_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionFaction_relation(ctx context.Context, field graphql.CollectedField, obj *model.FactionFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionFaction_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionFactionRelation)
	fc.Result = res
	return ec.marshalNFactionFactionRelation2ordomapgraphmodelFactionFactionRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionFaction_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionFactionRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionFaction_startDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionFaction_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionFaction_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionFaction_endDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionFaction_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionFaction_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_id(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_faction(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_item(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ordomapgraphmodelItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_relation(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionItemRelation)
	fc.Result = res
	return ec.marshalNFactionItemRelation2ordomapgraphmodelFactionItemRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionItemRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_startDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_endDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_id(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_faction(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_location(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_relation(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionLocationRelation)
	fc.Result = res
	return ec.marshalNFactionLocationRelation2ordomapgraphmodelFactionLocationRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionLocationRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_startDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_endDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_id(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_faction(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_world(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ordomapgraphmodelWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_relation(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionWorldRelation)
	fc.Result = res
	return ec.marshalNFactionWorldRelation2ordomapgraphmodelFactionWorldRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionWorldRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_startDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_endDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_id(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_name(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_description(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_type(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemType)
	fc.Result = res
	return ec.marshalNItemType2ordomapgraphmodelItemType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_rarity(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_rarity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rarity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemRarity)
	fc.Result = res
	return ec.marshalNItemRarity2ordomapgraphmodelItemRarity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_rarity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemRarity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_slot(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_slot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemSlot)
	fc.Result = res
	return ec.marshalNItemSlot2ordomapgraphmodelItemSlot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_slot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemSlot does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_material(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_material(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Material, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_material(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_condition(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemCondition)
	fc.Result = res
	return ec.marshalNItemCondition2ordomapgraphmodelItemCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_weight(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_weight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_weight(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_creationDate(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_creationDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_creationDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_destructionDate(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_destructionDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DestructionDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_destructionDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_isMagical(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_isMagical(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsMagical, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_isMagical(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_abilities(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_abilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Abilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_abilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_value(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_characters(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterItem)
	fc.Result = res
	return ec.marshalNCharacterItem2ordomapgraphmodelCharacterItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterItem_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterItem_character(ctx, field)
			case "item":
				return ec.fieldContext_CharacterItem_item(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterItem_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterItem_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterItem_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_factions(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionItem)
	fc.Result = res
	return ec.marshalNFactionItem2ordomapgraphmodelFactionItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionItem_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionItem_faction(ctx, field)
			case "item":
				return ec.fieldContext_FactionItem_item(ctx, field)
			case "relation":
				return ec.fieldContext_FactionItem_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionItem_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionItem_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_events(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ItemEvent)
	fc.Result = res
	return ec.marshalNItemEvent2ordomapgraphmodelItemEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ItemEvent_id(ctx, field)
			case "item":
				return ec.fieldContext_ItemEvent_item(ctx, field)
			case "event":
				return ec.fieldContext_ItemEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_ItemEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_ItemEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_ItemEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_locations(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ItemLocation)
	fc.Result = res
	return ec.marshalNItemLocation2ordomapgraphmodelItemLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ItemLocation_id(ctx, field)
			case "item":
				return ec.fieldContext_ItemLocation_item(ctx, field)
			case "with":
				return ec.fieldContext_ItemLocation_with(ctx, field)
			case "relation":
				return ec.fieldContext_ItemLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_ItemLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_ItemLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_relatedItems(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_relatedItems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedItems, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ItemItem)
	fc.Result = res
	return ec.marshalNItemItem2ordomapgraphmodelItemItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_relatedItems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ItemItem_id(ctx, field)
			case "item":
				return ec.fieldContext_ItemItem_item(ctx, field)
			case "relation":
				return ec.fieldContext_ItemItem_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_ItemItem_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_ItemItem_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_item(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ordomapgraphmodelItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ordomapgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemEventRelation)
	fc.Result = res
	return ec.marshalNItemEventRelation2ordomapgraphmodelItemEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemItem_id(ctx context.Context, field graphql.CollectedField, obj *model.ItemItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemItem_item(ctx context.Context, field graphql.CollectedField, obj *model.ItemItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemItem_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ordomapgraphmodelItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemItem_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemItem_relation(ctx context.Context, field graphql.CollectedField, obj *model.ItemItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemItem_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemItemRelation)
	fc.Result = res
	return ec.marshalNItemItemRelation2ordomapgraphmodelItemItemRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemItem_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemItemRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemItem_startDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemItem_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemItem_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemItem_endDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemItem_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemItem_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_id(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_item(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ordomapgraphmodelItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_with(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_with(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.With, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_with(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_relation(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemLocationRelation)
	fc.Result = res
	return ec.marshalNItemLocationRelation2ordomapgraphmodelItemLocationRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemLocationRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_startDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_endDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_id(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_name(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_description(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_type(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LocationType)
	fc.Result = res
	return ec.marshalNLocationType2ordomapgraphmodelLocationType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LocationType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_region(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_region(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Region, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_region(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_coordinates(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_coordinates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Coordinates, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_coordinates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_accessibility(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_accessibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accessibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LocationAccessibility)
	fc.Result = res
	return ec.marshalNLocationAccessibility2ordomapgraphmodelLocationAccessibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_accessibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LocationAccessibility does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_isNatural(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_isNatural(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsNatural, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_isNatural(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_climate(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_climate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Climate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_climate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_ecosystem(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_ecosystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ecosystem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_ecosystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_characters(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterLocation)
	fc.Result = res
	return ec.marshalNCharacterLocation2ordomapgraphmodelCharacterLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterLocation_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterLocation_character(ctx, field)
			case "location":
				return ec.fieldContext_CharacterLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureLocation)
	fc.Result = res
	return ec.marshalNCreatureLocation2ordomapgraphmodelCreatureLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureLocation_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureLocation_creature(ctx, field)
			case "location":
				return ec.fieldContext_CreatureLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_factions(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionLocation)
	fc.Result = res
	return ec.marshalNFactionLocation2ordomapgraphmodelFactionLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionLocation_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionLocation_faction(ctx, field)
			case "location":
				return ec.fieldContext_FactionLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_FactionLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_events(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationEvent)
	fc.Result = res
	return ec.marshalNLocationEvent2ordomapgraphmodelLocationEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationEvent_id(ctx, field)
			case "location":
				return ec.fieldContext_LocationEvent_location(ctx, field)
			case "event":
				return ec.fieldContext_LocationEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_LocationEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_LocationEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_LocationEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_items(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ItemLocation)
	fc.Result = res
	return ec.marshalNItemLocation2ordomapgraphmodelItemLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ItemLocation_id(ctx, field)
			case "item":
				return ec.fieldContext_ItemLocation_item(ctx, field)
			case "with":
				return ec.fieldContext_ItemLocation_with(ctx, field)
			case "relation":
				return ec.fieldContext_ItemLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_ItemLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_ItemLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_relatedLocations(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_relatedLocations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedLocations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationLocation)
	fc.Result = res
	return ec.marshalNLocationLocation2ordomapgraphmodelLocationLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_relatedLocations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationLocation_id(ctx, field)
			case "location":
				return ec.fieldContext_LocationLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_LocationLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_LocationLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_LocationLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationWorld)
	fc.Result = res
	return ec.marshalNLocationWorld2ordomapgraphmodelLocationWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationWorld_id(ctx, field)
			case "location":
				return ec.fieldContext_LocationWorld_location(ctx, field)
			case "world":
				return ec.fieldContext_LocationWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_LocationWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_LocationWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_LocationWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_location(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ordomapgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LocationEventRelation)
	fc.Result = res
	return ec.marshalNLocationEventRelation2ordomapgraphmodelLocationEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LocationEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationLocation_id(ctx context.Context, field graphql.CollectedField, obj *model.LocationLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationLocation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationLocation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationLocation_location(ctx context.Context, field graphql.CollectedField, obj *model.LocationLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationLocation_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationLocation_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationLocation_relation(ctx context.Context, field graphql.CollectedField, obj *model.LocationLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationLocation_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LocationLocationRelation)
	fc.Result = res
	return ec.marshalNLocationLocationRelation2ordomapgraphmodelLocationLocationRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationLocation_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LocationLocationRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationLocation_startDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationLocation_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationLocation_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationLocation_endDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationLocation_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationLocation_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_id(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_location(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_world(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ordomapgraphmodelWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_relation(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LocationWorldRelation)
	fc.Result = res
	return ec.marshalNLocationWorldRelation2ordomapgraphmodelLocationWorldRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LocationWorldRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_startDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_endDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCharacter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCharacter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCharacter(rctx, fc.Args["input"].(model.CreateCharacterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCharacter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCharacter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCharacter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCharacter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateCharacter(rctx, fc.Args["input"].(model.UpdateCharacterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCharacter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCharacter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteCharacter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteCharacter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteCharacter(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteCharacter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteCharacter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCreature(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCreature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCreature(rctx, fc.Args["input"].(model.CreateCreatureInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ordomapgraphmodelCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCreature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCreature_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCreature(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCreature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateCreature(rctx, fc.Args["input"].(model.UpdateCreatureInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ordomapgraphmodelCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCreature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCreature_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteCreature(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteCreature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteCreature(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteCreature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteCreature_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateItem(rctx, fc.Args["input"].(model.CreateItemInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ordomapgraphmodelItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateItem(rctx, fc.Args["input"].(model.UpdateItemInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ordomapgraphmodelItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteItem(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createLocation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createLocation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateLocation(rctx, fc.Args["input"].(model.CreateLocationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createLocation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createLocation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateLocation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateLocation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateLocation(rctx, fc.Args["input"].(model.UpdateLocationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateLocation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateLocation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteLocation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteLocation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteLocation(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteLocation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteLocation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createFaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createFaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateFaction(rctx, fc.Args["input"].(model.CreateFactionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createFaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createFaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateFaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateFaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateFaction(rctx, fc.Args["input"].(model.UpdateFactionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateFaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateFaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteFaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteFaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteFaction(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteFaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteFaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateEvent(rctx, fc.Args["input"].(model.CreateEventInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ordomapgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateEvent(rctx, fc.Args["input"].(model.UpdateEventInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ordomapgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteEvent(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createWorld(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createWorld(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateWorld(rctx, fc.Args["input"].(model.CreateWorldInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ordomapgraphmodelWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createWorld(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createWorld_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateWorld(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateWorld(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateWorld(rctx, fc.Args["input"].(model.UpdateWorldInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ordomapgraphmodelWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateWorld(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateWorld_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteWorld(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteWorld(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteWorld(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteWorld(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteWorld_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUniverse(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUniverse(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUniverse(rctx, fc.Args["input"].(model.CreateUniverseInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Universe)
	fc.Result = res
	return ec.marshalNUniverse2ordomapgraphmodelUniverse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUniverse(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Universe_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Universe_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Universe_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Universe_name(ctx, field)
			case "description":
				return ec.fieldContext_Universe_description(ctx, field)
			case "startYear":
				return ec.fieldContext_Universe_startYear(ctx, field)
			case "isActive":
				return ec.fieldContext_Universe_isActive(ctx, field)
			case "worlds":
				return ec.fieldContext_Universe_worlds(ctx, field)
			case "factions":
				return ec.fieldContext_Universe_factions(ctx, field)
			case "characters":
				return ec.fieldContext_Universe_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Universe_creatures(ctx, field)
			case "events":
				return ec.fieldContext_Universe_events(ctx, field)
			case "locations":
				return ec.fieldContext_Universe_locations(ctx, field)
			case "items":
				return ec.fieldContext_Universe_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Universe", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUniverse_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUniverse(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUniverse(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUniverse(rctx, fc.Args["input"].(model.UpdateUniverseInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Universe)
	fc.Result = res
	return ec.marshalNUniverse2ordomapgraphmodelUniverse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUniverse(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Universe_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Universe_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Universe_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Universe_name(ctx, field)
			case "description":
				return ec.fieldContext_Universe_description(ctx, field)
			case "startYear":
				return ec.fieldContext_Universe_startYear(ctx, field)
			case "isActive":
				return ec.fieldContext_Universe_isActive(ctx, field)
			case "worlds":
				return ec.fieldContext_Universe_worlds(ctx, field)
			case "factions":
				return ec.fieldContext_Universe_factions(ctx, field)
			case "characters":
				return ec.fieldContext_Universe_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Universe_creatures(ctx, field)
			case "events":
				return ec.fieldContext_Universe_events(ctx, field)
			case "locations":
				return ec.fieldContext_Universe_locations(ctx, field)
			case "items":
				return ec.fieldContext_Universe_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Universe", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUniverse_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteUniverse(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteUniverse(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteUniverse(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUniverse(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUniverse_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_character(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Character(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalOCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_character_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_characters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Characters(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_characters_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_creature(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Creature(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalOCreature2ordomapgraphmodelCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_creature_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_creatures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Creatures(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ordomapgraphmodelCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_creatures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_item(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Item(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalOItem2ordomapgraphmodelItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_item_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_items(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Items(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Item)
	fc.Result = res
	return ec.marshalNItem2ordomapgraphmodelItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_items_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_location(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Location(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalOLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_location_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_locations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Locations(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_locations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_faction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Faction(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalOFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_faction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_factions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Factions(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_factions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_event(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Event(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalOEvent2ordomapgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_event_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_events(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Events(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ordomapgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_world(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().World(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalOWorld2ordomapgraphmodelWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_world_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_worlds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Worlds(rctx, fc.Args["universeId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.World)
	fc.Result = res
	return ec.marshalNWorld2ordomapgraphmodelWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_worlds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_universe(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_universe(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Universe(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Universe)
	fc.Result = res
	return ec.marshalOUniverse2ordomapgraphmodelUniverse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_universe(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Universe_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Universe_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Universe_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Universe_name(ctx, field)
			case "description":
				return ec.fieldContext_Universe_description(ctx, field)
			case "startYear":
				return ec.fieldContext_Universe_startYear(ctx, field)
			case "isActive":
				return ec.fieldContext_Universe_isActive(ctx, field)
			case "worlds":
				return ec.fieldContext_Universe_worlds(ctx, field)
			case "factions":
				return ec.fieldContext_Universe_factions(ctx, field)
			case "characters":
				return ec.fieldContext_Universe_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Universe_creatures(ctx, field)
			case "events":
				return ec.fieldContext_Universe_events(ctx, field)
			case "locations":
				return ec.fieldContext_Universe_locations(ctx, field)
			case "items":
				return ec.fieldContext_Universe_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Universe", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_universe_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_universes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_universes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Universes(rctx, fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Universe)
	fc.Result = res
	return ec.marshalNUniverse2ordomapgraphmodelUniverse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_universes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Universe_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Universe_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Universe_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Universe_name(ctx, field)
			case "description":
				return ec.fieldContext_Universe_description(ctx, field)
			case "startYear":
				return ec.fieldContext_Universe_startYear(ctx, field)
			case "isActive":
				return ec.fieldContext_Universe_isActive(ctx, field)
			case "worlds":
				return ec.fieldContext_Universe_worlds(ctx, field)
			case "factions":
				return ec.fieldContext_Universe_factions(ctx, field)
			case "characters":
				return ec.fieldContext_Universe_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Universe_creatures(ctx, field)
			case "events":
				return ec.fieldContext_Universe_events(ctx, field)
			case "locations":
				return ec.fieldContext_Universe_locations(ctx, field)
			case "items":
				return ec.fieldContext_Universe_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Universe", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_universes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_status(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_message(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_id(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_name(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_description(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_startYear(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_startYear(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartYear, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_startYear(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_isActive(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_isActive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_isActive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.World)
	fc.Result = res
	return ec.marshalNWorld2ordomapgraphmodelWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_factions(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ordomapgraphmodelFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_characters(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ordomapgraphmodelCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_events(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ordomapgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_locations(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ordomapgraphmodelLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_items(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Item)
	fc.Result = res
	return ec.marshalNItem2ordomapgraphmodelItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_id(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_name(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_description(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_type(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.WorldType)
	fc.Result = res
	return ec.marshalNWorldType2ordomapgraphmodelWorldType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorldType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_universe(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_universe(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Universe, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Universe)
	fc.Result = res
	return ec.marshalNUniverse2ordomapgraphmodelUniverse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_universe(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Universe_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Universe_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Universe_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Universe_name(ctx, field)
			case "description":
				return ec.fieldContext_Universe_description(ctx, field)
			case "startYear":
				return ec.fieldContext_Universe_startYear(ctx, field)
			case "isActive":
				return ec.fieldContext_Universe_isActive(ctx, field)
			case "worlds":
				return ec.fieldContext_Universe_worlds(ctx, field)
			case "factions":
				return ec.fieldContext_Universe_factions(ctx, field)
			case "characters":
				return ec.fieldContext_Universe_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Universe_creatures(ctx, field)
			case "events":
				return ec.fieldContext_Universe_events(ctx, field)
			case "locations":
				return ec.fieldContext_Universe_locations(ctx, field)
			case "items":
				return ec.fieldContext_Universe_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Universe", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_technologyLevel(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_technologyLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TechnologyLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_technologyLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_energySources(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_energySources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnergySources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_energySources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_gravity(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_gravity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gravity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_gravity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_size(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_moons(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_moons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Moons, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_moons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_stars(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_stars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_stars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_climate(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_climate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Climate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_climate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_ecosystem(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_ecosystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ecosystem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_ecosystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_hasAtmosphere(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_hasAtmosphere(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasAtmosphere, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_hasAtmosphere(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_isHabitable(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_isHabitable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsHabitable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_isHabitable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_characters(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterWorld)
	fc.Result = res
	return ec.marshalNCharacterWorld2ordomapgraphmodelCharacterWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterWorld_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterWorld_character(ctx, field)
			case "world":
				return ec.fieldContext_CharacterWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_creatures(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureWorld)
	fc.Result = res
	return ec.marshalNCreatureWorld2ordomapgraphmodelCreatureWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureWorld_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureWorld_creature(ctx, field)
			case "world":
				return ec.fieldContext_CreatureWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_factions(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionWorld)
	fc.Result = res
	return ec.marshalNFactionWorld2ordomapgraphmodelFactionWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionWorld_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionWorld_faction(ctx, field)
			case "world":
				return ec.fieldContext_FactionWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_FactionWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_events(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorldEvent)
	fc.Result = res
	return ec.marshalNWorldEvent2ordomapgraphmodelWorldEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WorldEvent_id(ctx, field)
			case "world":
				return ec.fieldContext_WorldEvent_world(ctx, field)
			case "event":
				return ec.fieldContext_WorldEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_WorldEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_WorldEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_WorldEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorldEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_locations(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationWorld)
	fc.Result = res
	return ec.marshalNLocationWorld2ordomapgraphmodelLocationWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationWorld_id(ctx, field)
			case "location":
				return ec.fieldContext_LocationWorld_location(ctx, field)
			case "world":
				return ec.fieldContext_LocationWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_LocationWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_LocationWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_LocationWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_connectedWorlds(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_connectedWorlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectedWorlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorldWorld)
	fc.Result = res
	return ec.marshalNWorldWorld2ordomapgraphmodelWorldWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_connectedWorlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WorldWorld_id(ctx, field)
			case "world":
				return ec.fieldContext_WorldWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_WorldWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_WorldWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_WorldWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorldWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_world(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ordomapgraphmodelWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ordomapgraphmodelEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.WorldEventRelation)
	fc.Result = res
	return ec.marshalNWorldEventRelation2ordomapgraphmodelWorldEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorldEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldWorld_id(ctx context.Context, field graphql.CollectedField, obj *model.WorldWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldWorld_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldWorld_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldWorld_world(ctx context.Context, field graphql.CollectedField, obj *model.WorldWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldWorld_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ordomapgraphmodelWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldWorld_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldWorld_relation(ctx context.Context, field graphql.CollectedField, obj *model.WorldWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldWorld_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.WorldWorldRelation)
	fc.Result = res
	return ec.marshalNWorldWorldRelation2ordomapgraphmodelWorldWorldRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldWorld_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorldWorldRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldWorld_startDate(ctx context.Context, field graphql.CollectedField, obj *model.WorldWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldWorld_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldWorld_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldWorld_endDate(ctx context.Context, field graphql.CollectedField, obj *model.WorldWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldWorld_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldWorld_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateCharacterInput(ctx context.Context, obj interface{}) (model.CreateCharacterInput, error) {
	var it model.CreateCharacterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "birthDate", "height", "weight", "isAlive", "isMain", "alignment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "birthDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthDate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BirthDate = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "isAlive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAlive"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsAlive = data
		case "isMain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isMain"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsMain = data
		case "alignment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignment"))
			data, err := ec.unmarshalOAlignment2ordomapgraphmodelAlignment(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alignment = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCreatureInput(ctx context.Context, obj interface{}) (model.CreateCreatureInput, error) {
	var it model.CreateCreatureInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "species", "intelligenceLevel", "height", "weight", "birthDate", "isAlive", "lifespan", "isUnique", "habitat", "behavior", "diet", "abilities"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "species":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("species"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Species = data
		case "intelligenceLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("intelligenceLevel"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntelligenceLevel = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "birthDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthDate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BirthDate = data
		case "isAlive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAlive"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsAlive = data
		case "lifespan":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lifespan"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lifespan = data
		case "isUnique":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isUnique"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsUnique = data
		case "habitat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("habitat"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Habitat = data
		case "behavior":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("behavior"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Behavior = data
		case "diet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diet"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Diet = data
		case "abilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilities"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Abilities = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEventInput(ctx context.Context, obj interface{}) (model.CreateEventInput, error) {
	var it model.CreateEventInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "nature", "startDate", "endDate", "isRecurring", "significance", "locations", "worlds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNEventType2ordomapgraphmodelEventType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "nature":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nature"))
			data, err := ec.unmarshalNEventNature2ordomapgraphmodelEventNature(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nature = data
		case "startDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "endDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndDate = data
		case "isRecurring":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isRecurring"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsRecurring = data
		case "significance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("significance"))
			data, err := ec.unmarshalNEventSignificance2ordomapgraphmodelEventSignificance(ctx, v)
			if err != nil {
				return it, err
			}
			it.Significance = data
		case "locations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locations"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locations = data
		case "worlds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worlds"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Worlds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateFactionInput(ctx context.Context, obj interface{}) (model.CreateFactionInput, error) {
	var it model.CreateFactionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "ideology", "status", "foundedDate", "disbandedDate", "influence", "locations", "worlds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNFactionType2ordomapgraphmodelFactionType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "ideology":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ideology"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ideology = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalNFactionStatus2ordomapgraphmodelFactionStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "foundedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("foundedDate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FoundedDate = data
		case "disbandedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disbandedDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisbandedDate = data
		case "influence":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("influence"))
			data, err := ec.unmarshalNFactionInfluence2ordomapgraphmodelFactionInfluence(ctx, v)
			if err != nil {
				return it, err
			}
			it.Influence = data
		case "locations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locations"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locations = data
		case "worlds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worlds"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Worlds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateItemInput(ctx context.Context, obj interface{}) (model.CreateItemInput, error) {
	var it model.CreateItemInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "rarity", "slot", "material", "condition", "weight", "dimensions", "creationDate", "destructionDate", "isMagical", "abilities", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNItemType2ordomapgraphmodelItemType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalNItemRarity2ordomapgraphmodelItemRarity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "slot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slot"))
			data, err := ec.unmarshalNItemSlot2ordomapgraphmodelItemSlot(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slot = data
		case "material":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("material"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Material = data
		case "condition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("condition"))
			data, err := ec.unmarshalNItemCondition2ordomapgraphmodelItemCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.Condition = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "dimensions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dimensions"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dimensions = data
		case "creationDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creationDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreationDate = data
		case "destructionDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("destructionDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DestructionDate = data
		case "isMagical":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isMagical"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsMagical = data
		case "abilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilities"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Abilities = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLocationInput(ctx context.Context, obj interface{}) (model.CreateLocationInput, error) {
	var it model.CreateLocationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "region", "coordinates", "accessibility", "isNatural", "climate", "ecosystem"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNLocationType2ordomapgraphmodelLocationType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "coordinates":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coordinates"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Coordinates = data
		case "accessibility":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessibility"))
			data, err := ec.unmarshalNLocationAccessibility2ordomapgraphmodelLocationAccessibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.Accessibility = data
		case "isNatural":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNatural"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNatural = data
		case "climate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("climate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Climate = data
		case "ecosystem":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ecosystem"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ecosystem = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUniverseInput(ctx context.Context, obj interface{}) (model.CreateUniverseInput, error) {
	var it model.CreateUniverseInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "startYear"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "startYear":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startYear"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartYear = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateWorldInput(ctx context.Context, obj interface{}) (model.CreateWorldInput, error) {
	var it model.CreateWorldInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"universeId", "name", "description", "type", "technologyLevel", "energySources", "gravity", "size", "moons", "stars", "climate", "ecosystem", "hasAtmosphere", "isHabitable"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "universeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("universeId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UniverseID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNWorldType2ordomapgraphmodelWorldType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "technologyLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("technologyLevel"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TechnologyLevel = data
		case "energySources":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("energySources"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnergySources = data
		case "gravity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gravity"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gravity = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "moons":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("moons"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Moons = data
		case "stars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stars"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stars = data
		case "climate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("climate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Climate = data
		case "ecosystem":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ecosystem"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ecosystem = data
		case "hasAtmosphere":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAtmosphere"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAtmosphere = data
		case "isHabitable":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isHabitable"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsHabitable = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCharacterInput(ctx context.Context, obj interface{}) (model.UpdateCharacterInput, error) {
	var it model.UpdateCharacterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "birthDate", "height", "weight", "isAlive", "isMain", "alignment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "birthDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BirthDate = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "isAlive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAlive"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsAlive = data
		case "isMain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isMain"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsMain = data
		case "alignment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignment"))
			data, err := ec.unmarshalOAlignment2ordomapgraphmodelAlignment(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alignment = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCreatureInput(ctx context.Context, obj interface{}) (model.UpdateCreatureInput, error) {
	var it model.UpdateCreatureInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "species", "intelligenceLevel", "height", "weight", "birthDate", "isAlive", "lifespan", "isUnique", "habitat", "behavior", "diet", "abilities"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "species":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("species"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Species = data
		case "intelligenceLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("intelligenceLevel"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntelligenceLevel = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "birthDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BirthDate = data
		case "isAlive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAlive"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsAlive = data
		case "lifespan":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lifespan"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lifespan = data
		case "isUnique":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isUnique"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsUnique = data
		case "habitat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("habitat"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Habitat = data
		case "behavior":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("behavior"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Behavior = data
		case "diet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diet"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Diet = data
		case "abilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilities"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Abilities = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventInput(ctx context.Context, obj interface{}) (model.UpdateEventInput, error) {
	var it model.UpdateEventInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "nature", "startDate", "endDate", "isRecurring", "significance", "locations", "worlds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOEventType2ordomapgraphmodelEventType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "nature":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nature"))
			data, err := ec.unmarshalOEventNature2ordomapgraphmodelEventNature(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nature = data
		case "startDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "endDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndDate = data
		case "isRecurring":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isRecurring"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsRecurring = data
		case "significance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("significance"))
			data, err := ec.unmarshalOEventSignificance2ordomapgraphmodelEventSignificance(ctx, v)
			if err != nil {
				return it, err
			}
			it.Significance = data
		case "locations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locations"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locations = data
		case "worlds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worlds"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Worlds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateFactionInput(ctx context.Context, obj interface{}) (model.UpdateFactionInput, error) {
	var it model.UpdateFactionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "ideology", "status", "foundedDate", "disbandedDate", "influence", "locations", "worlds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOFactionType2ordomapgraphmodelFactionType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "ideology":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ideology"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ideology = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOFactionStatus2ordomapgraphmodelFactionStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "foundedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("foundedDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FoundedDate = data
		case "disbandedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disbandedDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisbandedDate = data
		case "influence":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("influence"))
			data, err := ec.unmarshalOFactionInfluence2ordomapgraphmodelFactionInfluence(ctx, v)
			if err != nil {
				return it, err
			}
			it.Influence = data
		case "locations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locations"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locations = data
		case "worlds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worlds"))
			data, err := ec.unmarshalOID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Worlds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateItemInput(ctx context.Context, obj interface{}) (model.UpdateItemInput, error) {
	var it model.UpdateItemInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "rarity", "slot", "material", "condition", "weight", "dimensions", "creationDate", "destructionDate", "isMagical", "abilities", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOItemType2ordomapgraphmodelItemType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalOItemRarity2ordomapgraphmodelItemRarity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "slot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slot"))
			data, err := ec.unmarshalOItemSlot2ordomapgraphmodelItemSlot(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slot = data
		case "material":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("material"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Material = data
		case "condition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("condition"))
			data, err := ec.unmarshalOItemCondition2ordomapgraphmodelItemCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.Condition = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "dimensions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dimensions"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dimensions = data
		case "creationDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creationDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreationDate = data
		case "destructionDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("destructionDate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DestructionDate = data
		case "isMagical":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isMagical"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsMagical = data
		case "abilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilities"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Abilities = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLocationInput(ctx context.Context, obj interface{}) (model.UpdateLocationInput, error) {
	var it model.UpdateLocationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "region", "coordinates", "accessibility", "isNatural", "climate", "ecosystem"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOLocationType2ordomapgraphmodelLocationType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "coordinates":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coordinates"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Coordinates = data
		case "accessibility":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessibility"))
			data, err := ec.unmarshalOLocationAccessibility2ordomapgraphmodelLocationAccessibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.Accessibility = data
		case "isNatural":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNatural"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNatural = data
		case "climate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("climate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Climate = data
		case "ecosystem":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ecosystem"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ecosystem = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUniverseInput(ctx context.Context, obj interface{}) (model.UpdateUniverseInput, error) {
	var it model.UpdateUniverseInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "startYear", "isActive"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "startYear":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startYear"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartYear = data
		case "isActive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isActive"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsActive = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateWorldInput(ctx context.Context, obj interface{}) (model.UpdateWorldInput, error) {
	var it model.UpdateWorldInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "technologyLevel", "energySources", "gravity", "size", "moons", "stars", "climate", "ecosystem", "hasAtmosphere", "isHabitable"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOWorldType2ordomapgraphmodelWorldType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "technologyLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("technologyLevel"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TechnologyLevel = data
		case "energySources":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("energySources"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnergySources = data
		case "gravity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gravity"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gravity = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "moons":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("moons"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Moons = data
		case "stars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stars"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stars = data
		case "climate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("climate"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Climate = data
		case "ecosystem":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ecosystem"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ecosystem = data
		case "hasAtmosphere":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAtmosphere"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAtmosphere = data
		case "isHabitable":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isHabitable"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsHabitable = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Entity(ctx context.Context, sel ast.SelectionSet, obj model.Entity) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Character:
		return ec._Character(ctx, sel, &obj)
	case *model.Character:
		if obj == nil {
			return graphql.Null
		}
		return ec._Character(ctx, sel, obj)
	case model.Creature:
		return ec._Creature(ctx, sel, &obj)
	case *model.Creature:
		if obj == nil {
			return graphql.Null
		}
		return ec._Creature(ctx, sel, obj)
	case model.Event:
		return ec._Event(ctx, sel, &obj)
	case *model.Event:
		if obj == nil {
			return graphql.Null
		}
		return ec._Event(ctx, sel, obj)
	case model.Faction:
		return ec._Faction(ctx, sel, &obj)
	case *model.Faction:
		if obj == nil {
			return graphql.Null
		}
		return ec._Faction(ctx, sel, obj)
	case model.Item:
		return ec._Item(ctx, sel, &obj)
	case *model.Item:
		if obj == nil {
			return graphql.Null
		}
		return ec._Item(ctx, sel, obj)
	case model.Location:
		return ec._Location(ctx, sel, &obj)
	case *model.Location:
		if obj == nil {
			return graphql.Null
		}
		return ec._Location(ctx, sel, obj)
	case model.Universe:
		return ec._Universe(ctx, sel, &obj)
	case *model.Universe:
		if obj == nil {
			return graphql.Null
		}
		return ec._Universe(ctx, sel, obj)
	case model.World:
		return ec._World(ctx, sel, &obj)
	case *model.World:
		if obj == nil {
			return graphql.Null
		}
		return ec._World(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var characterImplementors = []string{"Character", "Entity"}

func (ec *executionContext) _Character(ctx context.Context, sel ast.SelectionSet, obj *model.Character) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Character")
		case "id":
			out.Values[i] = ec._Character_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Character_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Character_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Character_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Character_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Character_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "birthDate":
			out.Values[i] = ec._Character_birthDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "height":
			out.Values[i] = ec._Character_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "weight":
			out.Values[i] = ec._Character_weight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlive":
			out.Values[i] = ec._Character_isAlive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isMain":
			out.Values[i] = ec._Character_isMain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alignment":
			out.Values[i] = ec._Character_alignment(ctx, field, obj)
		case "characters":
			out.Values[i] = ec._Character_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Character_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Character_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Character_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._Character_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Character_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Character_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterCharacterImplementors = []string{"CharacterCharacter"}

func (ec *executionContext) _CharacterCharacter(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterCharacter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterCharacterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterCharacter")
		case "id":
			out.Values[i] = ec._CharacterCharacter_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterCharacter_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characterRelationLevel":
			out.Values[i] = ec._CharacterCharacter_characterRelationLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "familyRelation":
			out.Values[i] = ec._CharacterCharacter_familyRelation(ctx, field, obj)
		case "startDate":
			out.Values[i] = ec._CharacterCharacter_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterCharacter_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterCreatureImplementors = []string{"CharacterCreature"}

func (ec *executionContext) _CharacterCreature(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterCreature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterCreatureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterCreature")
		case "id":
			out.Values[i] = ec._CharacterCreature_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterCreature_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CharacterCreature_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterCreature_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterCreature_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterCreature_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterEventImplementors = []string{"CharacterEvent"}

func (ec *executionContext) _CharacterEvent(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterEvent")
		case "id":
			out.Values[i] = ec._CharacterEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterEvent_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._CharacterEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterFactionImplementors = []string{"CharacterFaction"}

func (ec *executionContext) _CharacterFaction(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterFaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterFactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterFaction")
		case "id":
			out.Values[i] = ec._CharacterFaction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterFaction_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._CharacterFaction_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterFaction_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterFaction_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterFaction_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterItemImplementors = []string{"CharacterItem"}

func (ec *executionContext) _CharacterItem(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterItem")
		case "id":
			out.Values[i] = ec._CharacterItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterItem_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "item":
			out.Values[i] = ec._CharacterItem_item(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterItem_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterItem_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterItem_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterLocationImplementors = []string{"CharacterLocation"}

func (ec *executionContext) _CharacterLocation(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterLocation")
		case "id":
			out.Values[i] = ec._CharacterLocation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterLocation_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._CharacterLocation_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterLocation_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterLocation_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterLocation_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterWorldImplementors = []string{"CharacterWorld"}

func (ec *executionContext) _CharacterWorld(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterWorld) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterWorldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterWorld")
		case "id":
			out.Values[i] = ec._CharacterWorld_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterWorld_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._CharacterWorld_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterWorld_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterWorld_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterWorld_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureImplementors = []string{"Creature", "Entity"}

func (ec *executionContext) _Creature(ctx context.Context, sel ast.SelectionSet, obj *model.Creature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Creature")
		case "id":
			out.Values[i] = ec._Creature_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Creature_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Creature_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Creature_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Creature_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Creature_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "species":
			out.Values[i] = ec._Creature_species(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "intelligenceLevel":
			out.Values[i] = ec._Creature_intelligenceLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "height":
			out.Values[i] = ec._Creature_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "weight":
			out.Values[i] = ec._Creature_weight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "birthDate":
			out.Values[i] = ec._Creature_birthDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlive":
			out.Values[i] = ec._Creature_isAlive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lifespan":
			out.Values[i] = ec._Creature_lifespan(ctx, field, obj)
		case "isUnique":
			out.Values[i] = ec._Creature_isUnique(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "habitat":
			out.Values[i] = ec._Creature_habitat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "behavior":
			out.Values[i] = ec._Creature_behavior(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "diet":
			out.Values[i] = ec._Creature_diet(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "abilities":
			out.Values[i] = ec._Creature_abilities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Creature_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Creature_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Creature_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Creature_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Creature_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Creature_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureCreatureImplementors = []string{"CreatureCreature"}

func (ec *executionContext) _CreatureCreature(ctx context.Context, sel ast.SelectionSet, obj *model.CreatureCreature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureCreatureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreatureCreature")
		case "id":
			out.Values[i] = ec._CreatureCreature_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CreatureCreature_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CreatureCreature_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CreatureCreature_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CreatureCreature_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureEventImplementors = []string{"CreatureEvent"}

func (ec *executionContext) _CreatureEvent(ctx context.Context, sel ast.SelectionSet, obj *model.CreatureEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreatureEvent")
		case "id":
			out.Values[i] = ec._CreatureEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CreatureEvent_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._CreatureEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CreatureEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CreatureEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CreatureEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureFactionImplementors = []string{"CreatureFaction"}

func (ec *executionContext) _CreatureFaction(ctx context.Context, sel ast.SelectionSet, obj *model.CreatureFaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureFactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreatureFaction")
		case "id":
			out.Values[i] = ec._CreatureFaction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CreatureFaction_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._CreatureFaction_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CreatureFaction_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CreatureFaction_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CreatureFaction_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureLocationImplementors = []string{"CreatureLocation"}

func (ec *executionContext) _CreatureLocation(ctx context.Context, sel ast.SelectionSet, obj *model.CreatureLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreatureLocation")
		case "id":
			out.Values[i] = ec._CreatureLocation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CreatureLocation_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._CreatureLocation_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CreatureLocation_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CreatureLocation_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CreatureLocation_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureWorldImplementors = []string{"CreatureWorld"}

func (ec *executionContext) _CreatureWorld(ctx context.Context, sel ast.SelectionSet, obj *model.CreatureWorld) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureWorldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreatureWorld")
		case "id":
			out.Values[i] = ec._CreatureWorld_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CreatureWorld_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._CreatureWorld_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CreatureWorld_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CreatureWorld_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CreatureWorld_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventImplementors = []string{"Event", "Entity"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *model.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":
			out.Values[i] = ec._Event_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Event_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Event_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Event_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Event_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Event_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nature":
			out.Values[i] = ec._Event_nature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._Event_startDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endDate":
			out.Values[i] = ec._Event_endDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRecurring":
			out.Values[i] = ec._Event_isRecurring(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "significance":
			out.Values[i] = ec._Event_significance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Event_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Event_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Event_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Event_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Event_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._Event_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relatedEvents":
			out.Values[i] = ec._Event_relatedEvents(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionImplementors = []string{"Faction", "Entity"}

func (ec *executionContext) _Faction(ctx context.Context, sel ast.SelectionSet, obj *model.Faction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Faction")
		case "id":
			out.Values[i] = ec._Faction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Faction_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Faction_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Faction_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Faction_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Faction_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ideology":
			out.Values[i] = ec._Faction_ideology(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Faction_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "foundedDate":
			out.Values[i] = ec._Faction_foundedDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disbandedDate":
			out.Values[i] = ec._Faction_disbandedDate(ctx, field, obj)
		case "influence":
			out.Values[i] = ec._Faction_influence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Faction_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Faction_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Faction_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Faction_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Faction_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Faction_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._Faction_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionEventImplementors = []string{"FactionEvent"}

func (ec *executionContext) _FactionEvent(ctx context.Context, sel ast.SelectionSet, obj *model.FactionEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FactionEvent")
		case "id":
			out.Values[i] = ec._FactionEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._FactionEvent_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._FactionEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._FactionEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._FactionEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._FactionEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionFactionImplementors = []string{"FactionFaction"}

func (ec *executionContext) _FactionFaction(ctx context.Context, sel ast.SelectionSet, obj *model.FactionFaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionFactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FactionFaction")
		case "id":
			out.Values[i] = ec._FactionFaction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._FactionFaction_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._FactionFaction_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._FactionFaction_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._FactionFaction_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionItemImplementors = []string{"FactionItem"}

func (ec *executionContext) _FactionItem(ctx context.Context, sel ast.SelectionSet, obj *model.FactionItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FactionItem")
		case "id":
			out.Values[i] = ec._FactionItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._FactionItem_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "item":
			out.Values[i] = ec._FactionItem_item(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._FactionItem_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._FactionItem_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._FactionItem_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionLocationImplementors = []string{"FactionLocation"}

func (ec *executionContext) _FactionLocation(ctx context.Context, sel ast.SelectionSet, obj *model.FactionLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FactionLocation")
		case "id":
			out.Values[i] = ec._FactionLocation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._FactionLocation_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._FactionLocation_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._FactionLocation_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._FactionLocation_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._FactionLocation_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionWorldImplementors = []string{"FactionWorld"}

func (ec *executionContext) _FactionWorld(ctx context.Context, sel ast.SelectionSet, obj *model.FactionWorld) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionWorldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FactionWorld")
		case "id":
			out.Values[i] = ec._FactionWorld_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._FactionWorld_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._FactionWorld_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._FactionWorld_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._FactionWorld_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._FactionWorld_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemImplementors = []string{"Item", "Entity"}

func (ec *executionContext) _Item(ctx context.Context, sel ast.SelectionSet, obj *model.Item) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Item")
		case "id":
			out.Values[i] = ec._Item_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Item_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Item_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Item_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Item_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Item_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rarity":
			out.Values[i] = ec._Item_rarity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "slot":
			out.Values[i] = ec._Item_slot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "material":
			out.Values[i] = ec._Item_material(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "condition":
			out.Values[i] = ec._Item_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "weight":
			out.Values[i] = ec._Item_weight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dimensions":
			out.Values[i] = ec._Item_dimensions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creationDate":
			out.Values[i] = ec._Item_creationDate(ctx, field, obj)
		case "destructionDate":
			out.Values[i] = ec._Item_destructionDate(ctx, field, obj)
		case "isMagical":
			out.Values[i] = ec._Item_isMagical(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "abilities":
			out.Values[i] = ec._Item_abilities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._Item_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Item_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Item_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Item_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Item_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relatedItems":
			out.Values[i] = ec._Item_relatedItems(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemEventImplementors = []string{"ItemEvent"}

func (ec *executionContext) _ItemEvent(ctx context.Context, sel ast.SelectionSet, obj *model.ItemEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemEvent")
		case "id":
			out.Values[i] = ec._ItemEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "item":
			out.Values[i] = ec._ItemEvent_item(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._ItemEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._ItemEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._ItemEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._ItemEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemItemImplementors = []string{"ItemItem"}

func (ec *executionContext) _ItemItem(ctx context.Context, sel ast.SelectionSet, obj *model.ItemItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemItem")
		case "id":
			out.Values[i] = ec._ItemItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "item":
			out.Values[i] = ec._ItemItem_item(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._ItemItem_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._ItemItem_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._ItemItem_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemLocationImplementors = []string{"ItemLocation"}

func (ec *executionContext) _ItemLocation(ctx context.Context, sel ast.SelectionSet, obj *model.ItemLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemLocation")
		case "id":
			out.Values[i] = ec._ItemLocation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "item":
			out.Values[i] = ec._ItemLocation_item(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "with":
			out.Values[i] = ec._ItemLocation_with(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._ItemLocation_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._ItemLocation_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._ItemLocation_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationImplementors = []string{"Location", "Entity"}

func (ec *executionContext) _Location(ctx context.Context, sel ast.SelectionSet, obj *model.Location) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Location")
		case "id":
			out.Values[i] = ec._Location_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Location_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Location_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Location_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Location_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Location_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "region":
			out.Values[i] = ec._Location_region(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "coordinates":
			out.Values[i] = ec._Location_coordinates(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "accessibility":
			out.Values[i] = ec._Location_accessibility(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isNatural":
			out.Values[i] = ec._Location_isNatural(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "climate":
			out.Values[i] = ec._Location_climate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ecosystem":
			out.Values[i] = ec._Location_ecosystem(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Location_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Location_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Location_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Location_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._Location_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relatedLocations":
			out.Values[i] = ec._Location_relatedLocations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Location_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationEventImplementors = []string{"LocationEvent"}

func (ec *executionContext) _LocationEvent(ctx context.Context, sel ast.SelectionSet, obj *model.LocationEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocationEvent")
		case "id":
			out.Values[i] = ec._LocationEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._LocationEvent_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._LocationEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._LocationEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._LocationEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._LocationEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationLocationImplementors = []string{"LocationLocation"}

func (ec *executionContext) _LocationLocation(ctx context.Context, sel ast.SelectionSet, obj *model.LocationLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocationLocation")
		case "id":
			out.Values[i] = ec._LocationLocation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._LocationLocation_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._LocationLocation_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._LocationLocation_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._LocationLocation_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationWorldImplementors = []string{"LocationWorld"}

func (ec *executionContext) _LocationWorld(ctx context.Context, sel ast.SelectionSet, obj *model.LocationWorld) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationWorldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocationWorld")
		case "id":
			out.Values[i] = ec._LocationWorld_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._LocationWorld_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._LocationWorld_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._LocationWorld_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._LocationWorld_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._LocationWorld_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createCharacter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCharacter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateCharacter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCharacter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteCharacter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteCharacter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createCreature":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCreature(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateCreature":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCreature(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteCreature":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteCreature(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createLocation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createLocation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateLocation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateLocation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteLocation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteLocation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createFaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createFaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateFaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateFaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteFaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteFaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createWorld":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createWorld(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateWorld":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateWorld(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteWorld":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteWorld(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createUniverse":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUniverse(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUniverse":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUniverse(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteUniverse":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteUniverse(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "character":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_character(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "characters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_characters(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "creature":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_creature(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "creatures":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_creatures(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "item":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_item(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "items":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_items(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "location":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_location(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "locations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_locations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "faction":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_faction(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "factions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_factions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "event":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_event(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_events(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "world":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_world(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "worlds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_worlds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "universe":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_universe(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "universes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_universes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var responseImplementors = []string{"Response"}

func (ec *executionContext) _Response(ctx context.Context, sel ast.SelectionSet, obj *model.Response) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, responseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Response")
		case "status":
			out.Values[i] = ec._Response_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Response_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var universeImplementors = []string{"Universe", "Entity"}

func (ec *executionContext) _Universe(ctx context.Context, sel ast.SelectionSet, obj *model.Universe) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, universeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Universe")
		case "id":
			out.Values[i] = ec._Universe_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Universe_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Universe_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Universe_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Universe_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startYear":
			out.Values[i] = ec._Universe_startYear(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isActive":
			out.Values[i] = ec._Universe_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Universe_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Universe_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Universe_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Universe_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Universe_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Universe_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._Universe_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var worldImplementors = []string{"World", "Entity"}

func (ec *executionContext) _World(ctx context.Context, sel ast.SelectionSet, obj *model.World) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, worldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("World")
		case "id":
			out.Values[i] = ec._World_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._World_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._World_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._World_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._World_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._World_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "universe":
			out.Values[i] = ec._World_universe(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "technologyLevel":
			out.Values[i] = ec._World_technologyLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "energySources":
			out.Values[i] = ec._World_energySources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gravity":
			out.Values[i] = ec._World_gravity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "size":
			out.Values[i] = ec._World_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "moons":
			out.Values[i] = ec._World_moons(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stars":
			out.Values[i] = ec._World_stars(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "climate":
			out.Values[i] = ec._World_climate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ecosystem":
			out.Values[i] = ec._World_ecosystem(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasAtmosphere":
			out.Values[i] = ec._World_hasAtmosphere(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isHabitable":
			out.Values[i] = ec._World_isHabitable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._World_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._World_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._World_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._World_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._World_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connectedWorlds":
			out.Values[i] = ec._World_connectedWorlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var worldEventImplementors = []string{"WorldEvent"}

func (ec *executionContext) _WorldEvent(ctx context.Context, sel ast.SelectionSet, obj *model.WorldEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, worldEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorldEvent")
		case "id":
			out.Values[i] = ec._WorldEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._WorldEvent_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._WorldEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._WorldEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._WorldEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._WorldEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var worldWorldImplementors = []string{"WorldWorld"}

func (ec *executionContext) _WorldWorld(ctx context.Context, sel ast.SelectionSet, obj *model.WorldWorld) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, worldWorldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorldWorld")
		case "id":
			out.Values[i] = ec._WorldWorld_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._WorldWorld_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._WorldWorld_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._WorldWorld_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._WorldWorld_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCharacter2ordomapgraphmodelCharacter(ctx context.Context, sel ast.SelectionSet, v model.Character) graphql.Marshaler {
	return ec._Character(ctx, sel, &v)
}

func (ec *executionContext) marshalNCharacter2ordomapgraphmodelCharacter(ctx context.Context, sel ast.SelectionSet, v []*model.Character) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacter2ordomapgraphmodelCharacter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacter2ordomapgraphmodelCharacter(ctx context.Context, sel ast.SelectionSet, v *model.Character) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Character(ctx, sel, v)
}

func (ec *executionContext) marshalNCharacterCharacter2ordomapgraphmodelCharacterCharacter(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterCharacter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterCharacter2ordomapgraphmodelCharacterCharacter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterCharacter2ordomapgraphmodelCharacterCharacter(ctx context.Context, sel ast.SelectionSet, v *model.CharacterCharacter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterCharacter(ctx, sel, v)
}

func (ec *executionContext) marshalNCharacterCreature2ordomapgraphmodelCharacterCreature(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterCreature) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterCreature2ordomapgraphmodelCharacterCreature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterCreature2ordomapgraphmodelCharacterCreature(ctx context.Context, sel ast.SelectionSet, v *model.CharacterCreature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterCreature(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterCreatureRelation2ordomapgraphmodelCharacterCreatureRelation(ctx context.Context, v interface{}) (model.CharacterCreatureRelation, error) {
	var res model.CharacterCreatureRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterCreatureRelation2ordomapgraphmodelCharacterCreatureRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterCreatureRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCharacterEvent2ordomapgraphmodelCharacterEvent(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterEvent2ordomapgraphmodelCharacterEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterEvent2ordomapgraphmodelCharacterEvent(ctx context.Context, sel ast.SelectionSet, v *model.CharacterEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterEventRelation2ordomapgraphmodelCharacterEventRelation(ctx context.Context, v interface{}) (model.CharacterEventRelation, error) {
	var res model.CharacterEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterEventRelation2ordomapgraphmodelCharacterEventRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCharacterFaction2ordomapgraphmodelCharacterFaction(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterFaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterFaction2ordomapgraphmodelCharacterFaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterFaction2ordomapgraphmodelCharacterFaction(ctx context.Context, sel ast.SelectionSet, v *model.CharacterFaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterFaction(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterFactionRelation2ordomapgraphmodelCharacterFactionRelation(ctx context.Context, v interface{}) (model.CharacterFactionRelation, error) {
	var res model.CharacterFactionRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterFactionRelation2ordomapgraphmodelCharacterFactionRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterFactionRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCharacterItem2ordomapgraphmodelCharacterItem(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterItem2ordomapgraphmodelCharacterItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterItem2ordomapgraphmodelCharacterItem(ctx context.Context, sel ast.SelectionSet, v *model.CharacterItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterItemRelation2ordomapgraphmodelCharacterItemRelation(ctx context.Context, v interface{}) (model.CharacterItemRelation, error) {
	var res model.CharacterItemRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterItemRelation2ordomapgraphmodelCharacterItemRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterItemRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCharacterLocation2ordomapgraphmodelCharacterLocation(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterLocation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterLocation2ordomapgraphmodelCharacterLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterLocation2ordomapgraphmodelCharacterLocation(ctx context.Context, sel ast.SelectionSet, v *model.CharacterLocation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterLocation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterLocationRelation2ordomapgraphmodelCharacterLocationRelation(ctx context.Context, v interface{}) (model.CharacterLocationRelation, error) {
	var res model.CharacterLocationRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterLocationRelation2ordomapgraphmodelCharacterLocationRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterLocationRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNCharacterRelationLevel2ordomapgraphmodelCharacterRelationLevel(ctx context.Context, v interface{}) (model.CharacterRelationLevel, error) {
	var res model.CharacterRelationLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterRelationLevel2ordomapgraphmodelCharacterRelationLevel(ctx context.Context, sel ast.SelectionSet, v model.CharacterRelationLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCharacterWorld2ordomapgraphmodelCharacterWorld(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterWorld) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterWorld2ordomapgraphmodelCharacterWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterWorld2ordomapgraphmodelCharacterWorld(ctx context.Context, sel ast.SelectionSet, v *model.CharacterWorld) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterWorld(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterWorldRelation2ordomapgraphmodelCharacterWorldRelation(ctx context.Context, v interface{}) (model.CharacterWorldRelation, error) {
	var res model.CharacterWorldRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterWorldRelation2ordomapgraphmodelCharacterWorldRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterWorldRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNCreateCharacterInput2ordomapgraphmodelCreateCharacterInput(ctx context.Context, v interface{}) (model.CreateCharacterInput, error) {
	res, err := ec.unmarshalInputCreateCharacterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateCreatureInput2ordomapgraphmodelCreateCreatureInput(ctx context.Context, v interface{}) (model.CreateCreatureInput, error) {
	res, err := ec.unmarshalInputCreateCreatureInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateEventInput2ordomapgraphmodelCreateEventInput(ctx context.Context, v interface{}) (model.CreateEventInput, error) {
	res, err := ec.unmarshalInputCreateEventInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateFactionInput2ordomapgraphmodelCreateFactionInput(ctx context.Context, v interface{}) (model.CreateFactionInput, error) {
	res, err := ec.unmarshalInputCreateFactionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateItemInput2ordomapgraphmodelCreateItemInput(ctx context.Context, v interface{}) (model.CreateItemInput, error) {
	res, err := ec.unmarshalInputCreateItemInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateLocationInput2ordomapgraphmodelCreateLocationInput(ctx context.Context, v interface{}) (model.CreateLocationInput, error) {
	res, err := ec.unmarshalInputCreateLocationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateUniverseInput2ordomapgraphmodelCreateUniverseInput(ctx context.Context, v interface{}) (model.CreateUniverseInput, error) {
	res, err := ec.unmarshalInputCreateUniverseInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateWorldInput2ordomapgraphmodelCreateWorldInput(ctx context.Context, v interface{}) (model.CreateWorldInput, error) {
	res, err := ec.unmarshalInputCreateWorldInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreature2ordomapgraphmodelCreature(ctx context.Context, sel ast.SelectionSet, v model.Creature) graphql.Marshaler {
	return ec._Creature(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreature2ordomapgraphmodelCreature(ctx context.Context, sel ast.SelectionSet, v []*model.Creature) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreature2ordomapgraphmodelCreature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreature2ordomapgraphmodelCreature(ctx context.Context, sel ast.SelectionSet, v *model.Creature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Creature(ctx, sel, v)
}

func (ec *executionContext) marshalNCreatureCreature2ordomapgraphmodelCreatureCreature(ctx context.Context, sel ast.SelectionSet, v []*model.CreatureCreature) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreatureCreature2ordomapgraphmodelCreatureCreature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreatureCreature2ordomapgraphmodelCreatureCreature(ctx context.Context, sel ast.SelectionSet, v *model.CreatureCreature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreatureCreature(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreatureCreatureRelation2ordomapgraphmodelCreatureCreatureRelation(ctx context.Context, v interface{}) (model.CreatureCreatureRelation, error) {
	var res model.CreatureCreatureRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreatureCreatureRelation2ordomapgraphmodelCreatureCreatureRelation(ctx context.Context, sel ast.SelectionSet, v model.CreatureCreatureRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreatureEvent2ordomapgraphmodelCreatureEvent(ctx context.Context, sel ast.SelectionSet, v []*model.CreatureEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreatureEvent2ordomapgraphmodelCreatureEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreatureEvent2ordomapgraphmodelCreatureEvent(ctx context.Context, sel ast.SelectionSet, v *model.CreatureEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreatureEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreatureEventRelation2ordomapgraphmodelCreatureEventRelation(ctx context.Context, v interface{}) (model.CreatureEventRelation, error) {
	var res model.CreatureEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreatureEventRelation2ordomapgraphmodelCreatureEventRelation(ctx context.Context, sel ast.SelectionSet, v model.CreatureEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreatureFaction2ordomapgraphmodelCreatureFaction(ctx context.Context, sel ast.SelectionSet, v []*model.CreatureFaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreatureFaction2ordomapgraphmodelCreatureFaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreatureFaction2ordomapgraphmodelCreatureFaction(ctx context.Context, sel ast.SelectionSet, v *model.CreatureFaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreatureFaction(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreatureFactionRelation2ordomapgraphmodelCreatureFactionRelation(ctx context.Context, v interface{}) (model.CreatureFactionRelation, error) {
	var res model.CreatureFactionRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreatureFactionRelation2ordomapgraphmodelCreatureFactionRelation(ctx context.Context, sel ast.SelectionSet, v model.CreatureFactionRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreatureLocation2ordomapgraphmodelCreatureLocation(ctx context.Context, sel ast.SelectionSet, v []*model.CreatureLocation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreatureLocation2ordomapgraphmodelCreatureLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreatureLocation2ordomapgraphmodelCreatureLocation(ctx context.Context, sel ast.SelectionSet, v *model.CreatureLocation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreatureLocation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreatureLocationRelation2ordomapgraphmodelCreatureLocationRelation(ctx context.Context, v interface{}) (model.CreatureLocationRelation, error) {
	var res model.CreatureLocationRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreatureLocationRelation2ordomapgraphmodelCreatureLocationRelation(ctx context.Context, sel ast.SelectionSet, v model.CreatureLocationRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreatureWorld2ordomapgraphmodelCreatureWorld(ctx context.Context, sel ast.SelectionSet, v []*model.CreatureWorld) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreatureWorld2ordomapgraphmodelCreatureWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreatureWorld2ordomapgraphmodelCreatureWorld(ctx context.Context, sel ast.SelectionSet, v *model.CreatureWorld) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreatureWorld(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreatureWorldRelation2ordomapgraphmodelCreatureWorldRelation(ctx context.Context, v interface{}) (model.CreatureWorldRelation, error) {
	var res model.CreatureWorldRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreatureWorldRelation2ordomapgraphmodelCreatureWorldRelation(ctx context.Context, sel ast.SelectionSet, v model.CreatureWorldRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEvent2ordomapgraphmodelEvent(ctx context.Context, sel ast.SelectionSet, v model.Event) graphql.Marshaler {
	return ec._Event(ctx, sel, &v)
}

func (ec *executionContext) marshalNEvent2ordomapgraphmodelEvent(ctx context.Context, sel ast.SelectionSet, v []*model.Event) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2ordomapgraphmodelEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEvent2ordomapgraphmodelEvent(ctx context.Context, sel ast.SelectionSet, v *model.Event) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventEvent2ordomapgraphmodelEventEvent(ctx context.Context, v interface{}) (model.EventEvent, error) {
	var res model.EventEvent
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventEvent2ordomapgraphmodelEventEvent(ctx context.Context, sel ast.SelectionSet, v model.EventEvent) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventEvent2ordomapgraphmodelEventEvent(ctx context.Context, v interface{}) ([]model.EventEvent, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.EventEvent, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEventEvent2ordomapgraphmodelEventEvent(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNEventEvent2ordomapgraphmodelEventEvent(ctx context.Context, sel ast.SelectionSet, v []model.EventEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEventEvent2ordomapgraphmodelEventEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNEventNature2ordomapgraphmodelEventNature(ctx context.Context, v interface{}) (model.EventNature, error) {
	var res model.EventNature
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventNature2ordomapgraphmodelEventNature(ctx context.Context, sel ast.SelectionSet, v model.EventNature) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventSignificance2ordomapgraphmodelEventSignificance(ctx context.Context, v interface{}) (model.EventSignificance, error) {
	var res model.EventSignificance
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventSignificance2ordomapgraphmodelEventSignificance(ctx context.Context, sel ast.SelectionSet, v model.EventSignificance) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventType2ordomapgraphmodelEventType(ctx context.Context, v interface{}) (model.EventType, error) {
	var res model.EventType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventType2ordomapgraphmodelEventType(ctx context.Context, sel ast.SelectionSet, v model.EventType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFaction2ordomapgraphmodelFaction(ctx context.Context, sel ast.SelectionSet, v model.Faction) graphql.Marshaler {
	return ec._Faction(ctx, sel, &v)
}

func (ec *executionContext) marshalNFaction2ordomapgraphmodelFaction(ctx context.Context, sel ast.SelectionSet, v []*model.Faction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFaction2ordomapgraphmodelFaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFaction2ordomapgraphmodelFaction(ctx context.Context, sel ast.SelectionSet, v *model.Faction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Faction(ctx, sel, v)
}

func (ec *executionContext) marshalNFactionEvent2ordomapgraphmodelFactionEvent(ctx context.Context, sel ast.SelectionSet, v []*model.FactionEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFactionEvent2ordomapgraphmodelFactionEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFactionEvent2ordomapgraphmodelFactionEvent(ctx context.Context, sel ast.SelectionSet, v *model.FactionEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FactionEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFactionEventRelation2ordomapgraphmodelFactionEventRelation(ctx context.Context, v interface{}) (model.FactionEventRelation, error) {
	var res model.FactionEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionEventRelation2ordomapgraphmodelFactionEventRelation(ctx context.Context, sel ast.SelectionSet, v model.FactionEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFactionFaction2ordomapgraphmodelFactionFaction(ctx context.Context, sel ast.SelectionSet, v []*model.FactionFaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFactionFaction2ordomapgraphmodelFactionFaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFactionFaction2ordomapgraphmodelFactionFaction(ctx context.Context, sel ast.SelectionSet, v *model.FactionFaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FactionFaction(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFactionFactionRelation2ordomapgraphmodelFactionFactionRelation(ctx context.Context, v interface{}) (model.FactionFactionRelation, error) {
	var res model.FactionFactionRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionFactionRelation2ordomapgraphmodelFactionFactionRelation(ctx context.Context, sel ast.SelectionSet, v model.FactionFactionRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFactionInfluence2ordomapgraphmodelFactionInfluence(ctx context.Context, v interface{}) (model.FactionInfluence, error) {
	var res model.FactionInfluence
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionInfluence2ordomapgraphmodelFactionInfluence(ctx context.Context, sel ast.SelectionSet, v model.FactionInfluence) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFactionItem2ordomapgraphmodelFactionItem(ctx context.Context, sel ast.SelectionSet, v []*model.FactionItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFactionItem2ordomapgraphmodelFactionItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFactionItem2ordomapgraphmodelFactionItem(ctx context.Context, sel ast.SelectionSet, v *model.FactionItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FactionItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFactionItemRelation2ordomapgraphmodelFactionItemRelation(ctx context.Context, v interface{}) (model.FactionItemRelation, error) {
	var res model.FactionItemRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionItemRelation2ordomapgraphmodelFactionItemRelation(ctx context.Context, sel ast.SelectionSet, v model.FactionItemRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFactionLocation2ordomapgraphmodelFactionLocation(ctx context.Context, sel ast.SelectionSet, v []*model.FactionLocation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFactionLocation2ordomapgraphmodelFactionLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFactionLocation2ordomapgraphmodelFactionLocation(ctx context.Context, sel ast.SelectionSet, v *model.FactionLocation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FactionLocation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFactionLocationRelation2ordomapgraphmodelFactionLocationRelation(ctx context.Context, v interface{}) (model.FactionLocationRelation, error) {
	var res model.FactionLocationRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionLocationRelation2ordomapgraphmodelFactionLocationRelation(ctx context.Context, sel ast.SelectionSet, v model.FactionLocationRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFactionStatus2ordomapgraphmodelFactionStatus(ctx context.Context, v interface{}) (model.FactionStatus, error) {
	var res model.FactionStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionStatus2ordomapgraphmodelFactionStatus(ctx context.Context, sel ast.SelectionSet, v model.FactionStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFactionType2ordomapgraphmodelFactionType(ctx context.Context, v interface{}) (model.FactionType, error) {
	var res model.FactionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionType2ordomapgraphmodelFactionType(ctx context.Context, sel ast.SelectionSet, v model.FactionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFactionWorld2ordomapgraphmodelFactionWorld(ctx context.Context, sel ast.SelectionSet, v []*model.FactionWorld) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFactionWorld2ordomapgraphmodelFactionWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFactionWorld2ordomapgraphmodelFactionWorld(ctx context.Context, sel ast.SelectionSet, v *model.FactionWorld) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FactionWorld(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFactionWorldRelation2ordomapgraphmodelFactionWorldRelation(ctx context.Context, v interface{}) (model.FactionWorldRelation, error) {
	var res model.FactionWorldRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionWorldRelation2ordomapgraphmodelFactionWorldRelation(ctx context.Context, sel ast.SelectionSet, v model.FactionWorldRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNItem2ordomapgraphmodelItem(ctx context.Context, sel ast.SelectionSet, v model.Item) graphql.Marshaler {
	return ec._Item(ctx, sel, &v)
}

func (ec *executionContext) marshalNItem2ordomapgraphmodelItem(ctx context.Context, sel ast.SelectionSet, v []*model.Item) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItem2ordomapgraphmodelItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNItem2ordomapgraphmodelItem(ctx context.Context, sel ast.SelectionSet, v *model.Item) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Item(ctx, sel, v)
}

func (ec *executionContext) unmarshalNItemCondition2ordomapgraphmodelItemCondition(ctx context.Context, v interface{}) (model.ItemCondition, error) {
	var res model.ItemCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemCondition2ordomapgraphmodelItemCondition(ctx context.Context, sel ast.SelectionSet, v model.ItemCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNItemEvent2ordomapgraphmodelItemEvent(ctx context.Context, sel ast.SelectionSet, v []*model.ItemEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItemEvent2ordomapgraphmodelItemEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNItemEvent2ordomapgraphmodelItemEvent(ctx context.Context, sel ast.SelectionSet, v *model.ItemEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ItemEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNItemEventRelation2ordomapgraphmodelItemEventRelation(ctx context.Context, v interface{}) (model.ItemEventRelation, error) {
	var res model.ItemEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemEventRelation2ordomapgraphmodelItemEventRelation(ctx context.Context, sel ast.SelectionSet, v model.ItemEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNItemItem2ordomapgraphmodelItemItem(ctx context.Context, sel ast.SelectionSet, v []*model.ItemItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItemItem2ordomapgraphmodelItemItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNItemItem2ordomapgraphmodelItemItem(ctx context.Context, sel ast.SelectionSet, v *model.ItemItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ItemItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNItemItemRelation2ordomapgraphmodelItemItemRelation(ctx context.Context, v interface{}) (model.ItemItemRelation, error) {
	var res model.ItemItemRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemItemRelation2ordomapgraphmodelItemItemRelation(ctx context.Context, sel ast.SelectionSet, v model.ItemItemRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNItemLocation2ordomapgraphmodelItemLocation(ctx context.Context, sel ast.SelectionSet, v []*model.ItemLocation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItemLocation2ordomapgraphmodelItemLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNItemLocation2ordomapgraphmodelItemLocation(ctx context.Context, sel ast.SelectionSet, v *model.ItemLocation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ItemLocation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNItemLocationRelation2ordomapgraphmodelItemLocationRelation(ctx context.Context, v interface{}) (model.ItemLocationRelation, error) {
	var res model.ItemLocationRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemLocationRelation2ordomapgraphmodelItemLocationRelation(ctx context.Context, sel ast.SelectionSet, v model.ItemLocationRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemRarity2ordomapgraphmodelItemRarity(ctx context.Context, v interface{}) (model.ItemRarity, error) {
	var res model.ItemRarity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemRarity2ordomapgraphmodelItemRarity(ctx context.Context, sel ast.SelectionSet, v model.ItemRarity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemSlot2ordomapgraphmodelItemSlot(ctx context.Context, v interface{}) (model.ItemSlot, error) {
	var res model.ItemSlot
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemSlot2ordomapgraphmodelItemSlot(ctx context.Context, sel ast.SelectionSet, v model.ItemSlot) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemType2ordomapgraphmodelItemType(ctx context.Context, v interface{}) (model.ItemType, error) {
	var res model.ItemType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemType2ordomapgraphmodelItemType(ctx context.Context, sel ast.SelectionSet, v model.ItemType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLocation2ordomapgraphmodelLocation(ctx context.Context, sel ast.SelectionSet, v model.Location) graphql.Marshaler {
	return ec._Location(ctx, sel, &v)
}

func (ec *executionContext) marshalNLocation2ordomapgraphmodelLocation(ctx context.Context, sel ast.SelectionSet, v []*model.Location) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLocation2ordomapgraphmodelLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLocation2ordomapgraphmodelLocation(ctx context.Context, sel ast.SelectionSet, v *model.Location) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Location(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLocationAccessibility2ordomapgraphmodelLocationAccessibility(ctx context.Context, v interface{}) (model.LocationAccessibility, error) {
	var res model.LocationAccessibility
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLocationAccessibility2ordomapgraphmodelLocationAccessibility(ctx context.Context, sel ast.SelectionSet, v model.LocationAccessibility) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLocationEvent2ordomapgraphmodelLocationEvent(ctx context.Context, sel ast.SelectionSet, v []*model.LocationEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLocationEvent2ordomapgraphmodelLocationEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLocationEvent2ordomapgraphmodelLocationEvent(ctx context.Context, sel ast.SelectionSet, v *model.LocationEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LocationEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLocationEventRelation2ordomapgraphmodelLocationEventRelation(ctx context.Context, v interface{}) (model.LocationEventRelation, error) {
	var res model.LocationEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLocationEventRelation2ordomapgraphmodelLocationEventRelation(ctx context.Context, sel ast.SelectionSet, v model.LocationEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLocationLocation2ordomapgraphmodelLocationLocation(ctx context.Context, sel ast.SelectionSet, v []*model.LocationLocation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLocationLocation2ordomapgraphmodelLocationLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLocationLocation2ordomapgraphmodelLocationLocation(ctx context.Context, sel ast.SelectionSet, v *model.LocationLocation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LocationLocation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLocationLocationRelation2ordomapgraphmodelLocationLocationRelation(ctx context.Context, v interface{}) (model.LocationLocationRelation, error) {
	var res model.LocationLocationRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLocationLocationRelation2ordomapgraphmodelLocationLocationRelation(ctx context.Context, sel ast.SelectionSet, v model.LocationLocationRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNLocationType2ordomapgraphmodelLocationType(ctx context.Context, v interface{}) (model.LocationType, error) {
	var res model.LocationType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLocationType2ordomapgraphmodelLocationType(ctx context.Context, sel ast.SelectionSet, v model.LocationType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLocationWorld2ordomapgraphmodelLocationWorld(ctx context.Context, sel ast.SelectionSet, v []*model.LocationWorld) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLocationWorld2ordomapgraphmodelLocationWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLocationWorld2ordomapgraphmodelLocationWorld(ctx context.Context, sel ast.SelectionSet, v *model.LocationWorld) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LocationWorld(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLocationWorldRelation2ordomapgraphmodelLocationWorldRelation(ctx context.Context, v interface{}) (model.LocationWorldRelation, error) {
	var res model.LocationWorldRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLocationWorldRelation2ordomapgraphmodelLocationWorldRelation(ctx context.Context, sel ast.SelectionSet, v model.LocationWorldRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUniverse2ordomapgraphmodelUniverse(ctx context.Context, sel ast.SelectionSet, v model.Universe) graphql.Marshaler {
	return ec._Universe(ctx, sel, &v)
}

func (ec *executionContext) marshalNUniverse2ordomapgraphmodelUniverse(ctx context.Context, sel ast.SelectionSet, v []*model.Universe) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUniverse2ordomapgraphmodelUniverse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUniverse2ordomapgraphmodelUniverse(ctx context.Context, sel ast.SelectionSet, v *model.Universe) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Universe(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateCharacterInput2ordomapgraphmodelUpdateCharacterInput(ctx context.Context, v interface{}) (model.UpdateCharacterInput, error) {
	res, err := ec.unmarshalInputUpdateCharacterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateCreatureInput2ordomapgraphmodelUpdateCreatureInput(ctx context.Context, v interface{}) (model.UpdateCreatureInput, error) {
	res, err := ec.unmarshalInputUpdateCreatureInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateEventInput2ordomapgraphmodelUpdateEventInput(ctx context.Context, v interface{}) (model.UpdateEventInput, error) {
	res, err := ec.unmarshalInputUpdateEventInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateFactionInput2ordomapgraphmodelUpdateFactionInput(ctx context.Context, v interface{}) (model.UpdateFactionInput, error) {
	res, err := ec.unmarshalInputUpdateFactionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateItemInput2ordomapgraphmodelUpdateItemInput(ctx context.Context, v interface{}) (model.UpdateItemInput, error) {
	res, err := ec.unmarshalInputUpdateItemInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateLocationInput2ordomapgraphmodelUpdateLocationInput(ctx context.Context, v interface{}) (model.UpdateLocationInput, error) {
	res, err := ec.unmarshalInputUpdateLocationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUniverseInput2ordomapgraphmodelUpdateUniverseInput(ctx context.Context, v interface{}) (model.UpdateUniverseInput, error) {
	res, err := ec.unmarshalInputUpdateUniverseInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateWorldInput2ordomapgraphmodelUpdateWorldInput(ctx context.Context, v interface{}) (model.UpdateWorldInput, error) {
	res, err := ec.unmarshalInputUpdateWorldInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorld2ordomapgraphmodelWorld(ctx context.Context, sel ast.SelectionSet, v model.World) graphql.Marshaler {
	return ec._World(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorld2ordomapgraphmodelWorld(ctx context.Context, sel ast.SelectionSet, v []*model.World) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorld2ordomapgraphmodelWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorld2ordomapgraphmodelWorld(ctx context.Context, sel ast.SelectionSet, v *model.World) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._World(ctx, sel, v)
}

func (ec *executionContext) marshalNWorldEvent2ordomapgraphmodelWorldEvent(ctx context.Context, sel ast.SelectionSet, v []*model.WorldEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorldEvent2ordomapgraphmodelWorldEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorldEvent2ordomapgraphmodelWorldEvent(ctx context.Context, sel ast.SelectionSet, v *model.WorldEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorldEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWorldEventRelation2ordomapgraphmodelWorldEventRelation(ctx context.Context, v interface{}) (model.WorldEventRelation, error) {
	var res model.WorldEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorldEventRelation2ordomapgraphmodelWorldEventRelation(ctx context.Context, sel ast.SelectionSet, v model.WorldEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNWorldType2ordomapgraphmodelWorldType(ctx context.Context, v interface{}) (model.WorldType, error) {
	var res model.WorldType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorldType2ordomapgraphmodelWorldType(ctx context.Context, sel ast.SelectionSet, v model.WorldType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWorldWorld2ordomapgraphmodelWorldWorld(ctx context.Context, sel ast.SelectionSet, v []*model.WorldWorld) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorldWorld2ordomapgraphmodelWorldWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorldWorld2ordomapgraphmodelWorldWorld(ctx context.Context, sel ast.SelectionSet, v *model.WorldWorld) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorldWorld(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWorldWorldRelation2ordomapgraphmodelWorldWorldRelation(ctx context.Context, v interface{}) (model.WorldWorldRelation, error) {
	var res model.WorldWorldRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorldWorldRelation2ordomapgraphmodelWorldWorldRelation(ctx context.Context, sel ast.SelectionSet, v model.WorldWorldRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAlignment2ordomapgraphmodelAlignment(ctx context.Context, v interface{}) (*model.Alignment, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Alignment)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAlignment2ordomapgraphmodelAlignment(ctx context.Context, sel ast.SelectionSet, v *model.Alignment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCharacter2ordomapgraphmodelCharacter(ctx context.Context, sel ast.SelectionSet, v *model.Character) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Character(ctx, sel, v)
}

func (ec *executionContext) marshalOCreature2ordomapgraphmodelCreature(ctx context.Context, sel ast.SelectionSet, v *model.Creature) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Creature(ctx, sel, v)
}

func (ec *executionContext) marshalOEvent2ordomapgraphmodelEvent(ctx context.Context, sel ast.SelectionSet, v *model.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventNature2ordomapgraphmodelEventNature(ctx context.Context, v interface{}) (*model.EventNature, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.EventNature)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventNature2ordomapgraphmodelEventNature(ctx context.Context, sel ast.SelectionSet, v *model.EventNature) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEventSignificance2ordomapgraphmodelEventSignificance(ctx context.Context, v interface{}) (*model.EventSignificance, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.EventSignificance)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventSignificance2ordomapgraphmodelEventSignificance(ctx context.Context, sel ast.SelectionSet, v *model.EventSignificance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEventType2ordomapgraphmodelEventType(ctx context.Context, v interface{}) (*model.EventType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.EventType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventType2ordomapgraphmodelEventType(ctx context.Context, sel ast.SelectionSet, v *model.EventType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFaction2ordomapgraphmodelFaction(ctx context.Context, sel ast.SelectionSet, v *model.Faction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Faction(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFactionInfluence2ordomapgraphmodelFactionInfluence(ctx context.Context, v interface{}) (*model.FactionInfluence, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FactionInfluence)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFactionInfluence2ordomapgraphmodelFactionInfluence(ctx context.Context, sel ast.SelectionSet, v *model.FactionInfluence) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFactionStatus2ordomapgraphmodelFactionStatus(ctx context.Context, v interface{}) (*model.FactionStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FactionStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFactionStatus2ordomapgraphmodelFactionStatus(ctx context.Context, sel ast.SelectionSet, v *model.FactionStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFactionType2ordomapgraphmodelFactionType(ctx context.Context, v interface{}) (*model.FactionType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FactionType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFactionType2ordomapgraphmodelFactionType(ctx context.Context, sel ast.SelectionSet, v *model.FactionType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFamilyRelation2ordomapgraphmodelFamilyRelation(ctx context.Context, v interface{}) (*model.FamilyRelation, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FamilyRelation)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFamilyRelation2ordomapgraphmodelFamilyRelation(ctx context.Context, sel ast.SelectionSet, v *model.FamilyRelation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOItem2ordomapgraphmodelItem(ctx context.Context, sel ast.SelectionSet, v *model.Item) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Item(ctx, sel, v)
}

func (ec *executionContext) unmarshalOItemCondition2ordomapgraphmodelItemCondition(ctx context.Context, v interface{}) (*model.ItemCondition, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ItemCondition)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemCondition2ordomapgraphmodelItemCondition(ctx context.Context, sel ast.SelectionSet, v *model.ItemCondition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOItemRarity2ordomapgraphmodelItemRarity(ctx context.Context, v interface{}) (*model.ItemRarity, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ItemRarity)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemRarity2ordomapgraphmodelItemRarity(ctx context.Context, sel ast.SelectionSet, v *model.ItemRarity) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOItemSlot2ordomapgraphmodelItemSlot(ctx context.Context, v interface{}) (*model.ItemSlot, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ItemSlot)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemSlot2ordomapgraphmodelItemSlot(ctx context.Context, sel ast.SelectionSet, v *model.ItemSlot) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOItemType2ordomapgraphmodelItemType(ctx context.Context, v interface{}) (*model.ItemType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ItemType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemType2ordomapgraphmodelItemType(ctx context.Context, sel ast.SelectionSet, v *model.ItemType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOLocation2ordomapgraphmodelLocation(ctx context.Context, sel ast.SelectionSet, v *model.Location) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Location(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLocationAccessibility2ordomapgraphmodelLocationAccessibility(ctx context.Context, v interface{}) (*model.LocationAccessibility, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.LocationAccessibility)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLocationAccessibility2ordomapgraphmodelLocationAccessibility(ctx context.Context, sel ast.SelectionSet, v *model.LocationAccessibility) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLocationType2ordomapgraphmodelLocationType(ctx context.Context, v interface{}) (*model.LocationType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.LocationType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLocationType2ordomapgraphmodelLocationType(ctx context.Context, sel ast.SelectionSet, v *model.LocationType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOUniverse2ordomapgraphmodelUniverse(ctx context.Context, sel ast.SelectionSet, v *model.Universe) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Universe(ctx, sel, v)
}

func (ec *executionContext) marshalOWorld2ordomapgraphmodelWorld(ctx context.Context, sel ast.SelectionSet, v *model.World) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._World(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorldType2ordomapgraphmodelWorldType(ctx context.Context, v interface{}) (*model.WorldType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.WorldType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWorldType2ordomapgraphmodelWorldType(ctx context.Context, sel ast.SelectionSet, v *model.WorldType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
