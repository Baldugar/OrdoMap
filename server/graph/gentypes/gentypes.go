// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gentypes

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"ordo-map/graph/model"
	"strconv"
	"sync"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Character struct {
		Alignment   func(childComplexity int) int
		BirthDate   func(childComplexity int) int
		Characters  func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Creatures   func(childComplexity int) int
		Description func(childComplexity int) int
		Events      func(childComplexity int) int
		Factions    func(childComplexity int) int
		Height      func(childComplexity int) int
		ID          func(childComplexity int) int
		IsAlive     func(childComplexity int) int
		IsMain      func(childComplexity int) int
		Items       func(childComplexity int) int
		Locations   func(childComplexity int) int
		Name        func(childComplexity int) int
		Type        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Weight      func(childComplexity int) int
		Worlds      func(childComplexity int) int
	}

	CharacterCharacter struct {
		Character              func(childComplexity int) int
		CharacterRelationLevel func(childComplexity int) int
		EndDate                func(childComplexity int) int
		FamilyRelation         func(childComplexity int) int
		ID                     func(childComplexity int) int
		StartDate              func(childComplexity int) int
	}

	CharacterCreature struct {
		Character func(childComplexity int) int
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CharacterEvent struct {
		Character func(childComplexity int) int
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CharacterFaction struct {
		Character func(childComplexity int) int
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CharacterItem struct {
		Character func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CharacterLocation struct {
		Character func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CharacterWorld struct {
		Character func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}

	Creature struct {
		Abilities         func(childComplexity int) int
		Behavior          func(childComplexity int) int
		BirthDate         func(childComplexity int) int
		Characters        func(childComplexity int) int
		CreatedAt         func(childComplexity int) int
		Creatures         func(childComplexity int) int
		Description       func(childComplexity int) int
		Diet              func(childComplexity int) int
		Events            func(childComplexity int) int
		Factions          func(childComplexity int) int
		Habitat           func(childComplexity int) int
		Height            func(childComplexity int) int
		ID                func(childComplexity int) int
		IntelligenceLevel func(childComplexity int) int
		IsAlive           func(childComplexity int) int
		IsUnique          func(childComplexity int) int
		Lifespan          func(childComplexity int) int
		Locations         func(childComplexity int) int
		Name              func(childComplexity int) int
		Species           func(childComplexity int) int
		Type              func(childComplexity int) int
		UpdatedAt         func(childComplexity int) int
		Weight            func(childComplexity int) int
		Worlds            func(childComplexity int) int
	}

	CreatureCreature struct {
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CreatureEvent struct {
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CreatureFaction struct {
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CreatureLocation struct {
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	CreatureWorld struct {
		Creature  func(childComplexity int) int
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}

	Event struct {
		Characters    func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		Creatures     func(childComplexity int) int
		Description   func(childComplexity int) int
		EndDate       func(childComplexity int) int
		Factions      func(childComplexity int) int
		ID            func(childComplexity int) int
		IsRecurring   func(childComplexity int) int
		Items         func(childComplexity int) int
		Locations     func(childComplexity int) int
		Name          func(childComplexity int) int
		Nature        func(childComplexity int) int
		RelatedEvents func(childComplexity int) int
		Significance  func(childComplexity int) int
		StartDate     func(childComplexity int) int
		Type          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Worlds        func(childComplexity int) int
	}

	Faction struct {
		Characters    func(childComplexity int) int
		CreatedAt     func(childComplexity int) int
		Creatures     func(childComplexity int) int
		Description   func(childComplexity int) int
		DisbandedDate func(childComplexity int) int
		Events        func(childComplexity int) int
		Factions      func(childComplexity int) int
		FoundedDate   func(childComplexity int) int
		ID            func(childComplexity int) int
		Ideology      func(childComplexity int) int
		Influence     func(childComplexity int) int
		Items         func(childComplexity int) int
		Locations     func(childComplexity int) int
		Name          func(childComplexity int) int
		Status        func(childComplexity int) int
		Type          func(childComplexity int) int
		UpdatedAt     func(childComplexity int) int
		Worlds        func(childComplexity int) int
	}

	FactionEvent struct {
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	FactionFaction struct {
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	FactionItem struct {
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	FactionLocation struct {
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	FactionWorld struct {
		EndDate   func(childComplexity int) int
		Faction   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}

	Item struct {
		Abilities       func(childComplexity int) int
		Characters      func(childComplexity int) int
		Condition       func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		CreationDate    func(childComplexity int) int
		Description     func(childComplexity int) int
		DestructionDate func(childComplexity int) int
		Dimensions      func(childComplexity int) int
		Events          func(childComplexity int) int
		Factions        func(childComplexity int) int
		ID              func(childComplexity int) int
		IsMagical       func(childComplexity int) int
		Locations       func(childComplexity int) int
		Material        func(childComplexity int) int
		Name            func(childComplexity int) int
		Rarity          func(childComplexity int) int
		RelatedItems    func(childComplexity int) int
		Slot            func(childComplexity int) int
		Type            func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
		Value           func(childComplexity int) int
		Weight          func(childComplexity int) int
	}

	ItemEvent struct {
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	ItemItem struct {
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	ItemLocation struct {
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		With      func(childComplexity int) int
	}

	Location struct {
		Accessibility    func(childComplexity int) int
		Characters       func(childComplexity int) int
		Climate          func(childComplexity int) int
		Coordinates      func(childComplexity int) int
		CreatedAt        func(childComplexity int) int
		Creatures        func(childComplexity int) int
		Description      func(childComplexity int) int
		Ecosystem        func(childComplexity int) int
		Events           func(childComplexity int) int
		Factions         func(childComplexity int) int
		ID               func(childComplexity int) int
		IsNatural        func(childComplexity int) int
		Items            func(childComplexity int) int
		Name             func(childComplexity int) int
		Region           func(childComplexity int) int
		RelatedLocations func(childComplexity int) int
		Type             func(childComplexity int) int
		UpdatedAt        func(childComplexity int) int
		Worlds           func(childComplexity int) int
	}

	LocationEvent struct {
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	LocationLocation struct {
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
	}

	LocationWorld struct {
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Location  func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}

	Mutation struct {
		CreateCharacter func(childComplexity int, input model.CreateCharacterInput) int
		CreateCreature  func(childComplexity int, input model.CreateCreatureInput) int
		CreateEvent     func(childComplexity int, input model.CreateEventInput) int
		CreateFaction   func(childComplexity int, input model.CreateFactionInput) int
		CreateItem      func(childComplexity int, input model.CreateItemInput) int
		CreateLocation  func(childComplexity int, input model.CreateLocationInput) int
		CreateUniverse  func(childComplexity int, input model.CreateUniverseInput) int
		CreateWorld     func(childComplexity int, input model.CreateWorldInput) int
		DeleteCharacter func(childComplexity int, id string) int
		DeleteCreature  func(childComplexity int, id string) int
		DeleteEvent     func(childComplexity int, id string) int
		DeleteFaction   func(childComplexity int, id string) int
		DeleteItem      func(childComplexity int, id string) int
		DeleteLocation  func(childComplexity int, id string) int
		DeleteUniverse  func(childComplexity int, id string) int
		DeleteWorld     func(childComplexity int, id string) int
		UpdateCharacter func(childComplexity int, input model.UpdateCharacterInput) int
		UpdateCreature  func(childComplexity int, input model.UpdateCreatureInput) int
		UpdateEvent     func(childComplexity int, input model.UpdateEventInput) int
		UpdateFaction   func(childComplexity int, input model.UpdateFactionInput) int
		UpdateItem      func(childComplexity int, input model.UpdateItemInput) int
		UpdateLocation  func(childComplexity int, input model.UpdateLocationInput) int
		UpdateUniverse  func(childComplexity int, input model.UpdateUniverseInput) int
		UpdateWorld     func(childComplexity int, input model.UpdateWorldInput) int
	}

	Query struct {
		Character  func(childComplexity int, id string) int
		Characters func(childComplexity int, worldID string, limit *int, offset *int) int
		Creature   func(childComplexity int, id string) int
		Creatures  func(childComplexity int, worldID string, limit *int, offset *int) int
		Event      func(childComplexity int, id string) int
		Events     func(childComplexity int, worldID string, limit *int, offset *int) int
		Faction    func(childComplexity int, id string) int
		Factions   func(childComplexity int, worldID string, limit *int, offset *int) int
		Item       func(childComplexity int, id string) int
		Items      func(childComplexity int, worldID string, limit *int, offset *int) int
		Location   func(childComplexity int, id string) int
		Locations  func(childComplexity int, worldID string, limit *int, offset *int) int
		Universe   func(childComplexity int, id string) int
		Universes  func(childComplexity int, limit *int, offset *int) int
		World      func(childComplexity int, id string) int
		Worlds     func(childComplexity int, universeID string, limit *int, offset *int) int
	}

	Response struct {
		Message func(childComplexity int) int
		Status  func(childComplexity int) int
	}

	Universe struct {
		Characters  func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Creatures   func(childComplexity int) int
		Description func(childComplexity int) int
		Events      func(childComplexity int) int
		Factions    func(childComplexity int) int
		ID          func(childComplexity int) int
		IsActive    func(childComplexity int) int
		Items       func(childComplexity int) int
		Locations   func(childComplexity int) int
		Name        func(childComplexity int) int
		StartYear   func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		Worlds      func(childComplexity int) int
	}

	World struct {
		Characters      func(childComplexity int) int
		Climate         func(childComplexity int) int
		ConnectedWorlds func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Creatures       func(childComplexity int) int
		Description     func(childComplexity int) int
		Ecosystem       func(childComplexity int) int
		EnergySources   func(childComplexity int) int
		Events          func(childComplexity int) int
		Factions        func(childComplexity int) int
		Gravity         func(childComplexity int) int
		HasAtmosphere   func(childComplexity int) int
		ID              func(childComplexity int) int
		IsHabitable     func(childComplexity int) int
		Locations       func(childComplexity int) int
		Moons           func(childComplexity int) int
		Name            func(childComplexity int) int
		Size            func(childComplexity int) int
		Stars           func(childComplexity int) int
		TechnologyLevel func(childComplexity int) int
		Type            func(childComplexity int) int
		Universe        func(childComplexity int) int
		UpdatedAt       func(childComplexity int) int
	}

	WorldEvent struct {
		EndDate   func(childComplexity int) int
		Event     func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}

	WorldWorld struct {
		EndDate   func(childComplexity int) int
		ID        func(childComplexity int) int
		Relation  func(childComplexity int) int
		StartDate func(childComplexity int) int
		World     func(childComplexity int) int
	}
}

type MutationResolver interface {
	CreateCharacter(ctx context.Context, input model.CreateCharacterInput) (*model.Character, error)
	UpdateCharacter(ctx context.Context, input model.UpdateCharacterInput) (*model.Character, error)
	DeleteCharacter(ctx context.Context, id string) (bool, error)
	CreateCreature(ctx context.Context, input model.CreateCreatureInput) (*model.Creature, error)
	UpdateCreature(ctx context.Context, input model.UpdateCreatureInput) (*model.Creature, error)
	DeleteCreature(ctx context.Context, id string) (bool, error)
	CreateItem(ctx context.Context, input model.CreateItemInput) (*model.Item, error)
	UpdateItem(ctx context.Context, input model.UpdateItemInput) (*model.Item, error)
	DeleteItem(ctx context.Context, id string) (bool, error)
	CreateLocation(ctx context.Context, input model.CreateLocationInput) (*model.Location, error)
	UpdateLocation(ctx context.Context, input model.UpdateLocationInput) (*model.Location, error)
	DeleteLocation(ctx context.Context, id string) (bool, error)
	CreateFaction(ctx context.Context, input model.CreateFactionInput) (*model.Faction, error)
	UpdateFaction(ctx context.Context, input model.UpdateFactionInput) (*model.Faction, error)
	DeleteFaction(ctx context.Context, id string) (bool, error)
	CreateEvent(ctx context.Context, input model.CreateEventInput) (*model.Event, error)
	UpdateEvent(ctx context.Context, input model.UpdateEventInput) (*model.Event, error)
	DeleteEvent(ctx context.Context, id string) (bool, error)
	CreateWorld(ctx context.Context, input model.CreateWorldInput) (*model.World, error)
	UpdateWorld(ctx context.Context, input model.UpdateWorldInput) (*model.World, error)
	DeleteWorld(ctx context.Context, id string) (bool, error)
	CreateUniverse(ctx context.Context, input model.CreateUniverseInput) (*model.Universe, error)
	UpdateUniverse(ctx context.Context, input model.UpdateUniverseInput) (*model.Universe, error)
	DeleteUniverse(ctx context.Context, id string) (bool, error)
}
type QueryResolver interface {
	Character(ctx context.Context, id string) (*model.Character, error)
	Characters(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Character, error)
	Creature(ctx context.Context, id string) (*model.Creature, error)
	Creatures(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Creature, error)
	Item(ctx context.Context, id string) (*model.Item, error)
	Items(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Item, error)
	Location(ctx context.Context, id string) (*model.Location, error)
	Locations(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Location, error)
	Faction(ctx context.Context, id string) (*model.Faction, error)
	Factions(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Faction, error)
	Event(ctx context.Context, id string) (*model.Event, error)
	Events(ctx context.Context, worldID string, limit *int, offset *int) ([]*model.Event, error)
	World(ctx context.Context, id string) (*model.World, error)
	Worlds(ctx context.Context, universeID string, limit *int, offset *int) ([]*model.World, error)
	Universe(ctx context.Context, id string) (*model.Universe, error)
	Universes(ctx context.Context, limit *int, offset *int) ([]*model.Universe, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Character.alignment":
		if e.complexity.Character.Alignment == nil {
			break
		}

		return e.complexity.Character.Alignment(childComplexity), true

	case "Character.birthDate":
		if e.complexity.Character.BirthDate == nil {
			break
		}

		return e.complexity.Character.BirthDate(childComplexity), true

	case "Character.characters":
		if e.complexity.Character.Characters == nil {
			break
		}

		return e.complexity.Character.Characters(childComplexity), true

	case "Character.createdAt":
		if e.complexity.Character.CreatedAt == nil {
			break
		}

		return e.complexity.Character.CreatedAt(childComplexity), true

	case "Character.creatures":
		if e.complexity.Character.Creatures == nil {
			break
		}

		return e.complexity.Character.Creatures(childComplexity), true

	case "Character.description":
		if e.complexity.Character.Description == nil {
			break
		}

		return e.complexity.Character.Description(childComplexity), true

	case "Character.events":
		if e.complexity.Character.Events == nil {
			break
		}

		return e.complexity.Character.Events(childComplexity), true

	case "Character.factions":
		if e.complexity.Character.Factions == nil {
			break
		}

		return e.complexity.Character.Factions(childComplexity), true

	case "Character.height":
		if e.complexity.Character.Height == nil {
			break
		}

		return e.complexity.Character.Height(childComplexity), true

	case "Character.id":
		if e.complexity.Character.ID == nil {
			break
		}

		return e.complexity.Character.ID(childComplexity), true

	case "Character.isAlive":
		if e.complexity.Character.IsAlive == nil {
			break
		}

		return e.complexity.Character.IsAlive(childComplexity), true

	case "Character.isMain":
		if e.complexity.Character.IsMain == nil {
			break
		}

		return e.complexity.Character.IsMain(childComplexity), true

	case "Character.items":
		if e.complexity.Character.Items == nil {
			break
		}

		return e.complexity.Character.Items(childComplexity), true

	case "Character.locations":
		if e.complexity.Character.Locations == nil {
			break
		}

		return e.complexity.Character.Locations(childComplexity), true

	case "Character.name":
		if e.complexity.Character.Name == nil {
			break
		}

		return e.complexity.Character.Name(childComplexity), true

	case "Character.type":
		if e.complexity.Character.Type == nil {
			break
		}

		return e.complexity.Character.Type(childComplexity), true

	case "Character.updatedAt":
		if e.complexity.Character.UpdatedAt == nil {
			break
		}

		return e.complexity.Character.UpdatedAt(childComplexity), true

	case "Character.weight":
		if e.complexity.Character.Weight == nil {
			break
		}

		return e.complexity.Character.Weight(childComplexity), true

	case "Character.worlds":
		if e.complexity.Character.Worlds == nil {
			break
		}

		return e.complexity.Character.Worlds(childComplexity), true

	case "CharacterCharacter.character":
		if e.complexity.CharacterCharacter.Character == nil {
			break
		}

		return e.complexity.CharacterCharacter.Character(childComplexity), true

	case "CharacterCharacter.characterRelationLevel":
		if e.complexity.CharacterCharacter.CharacterRelationLevel == nil {
			break
		}

		return e.complexity.CharacterCharacter.CharacterRelationLevel(childComplexity), true

	case "CharacterCharacter.endDate":
		if e.complexity.CharacterCharacter.EndDate == nil {
			break
		}

		return e.complexity.CharacterCharacter.EndDate(childComplexity), true

	case "CharacterCharacter.familyRelation":
		if e.complexity.CharacterCharacter.FamilyRelation == nil {
			break
		}

		return e.complexity.CharacterCharacter.FamilyRelation(childComplexity), true

	case "CharacterCharacter.id":
		if e.complexity.CharacterCharacter.ID == nil {
			break
		}

		return e.complexity.CharacterCharacter.ID(childComplexity), true

	case "CharacterCharacter.startDate":
		if e.complexity.CharacterCharacter.StartDate == nil {
			break
		}

		return e.complexity.CharacterCharacter.StartDate(childComplexity), true

	case "CharacterCreature.character":
		if e.complexity.CharacterCreature.Character == nil {
			break
		}

		return e.complexity.CharacterCreature.Character(childComplexity), true

	case "CharacterCreature.creature":
		if e.complexity.CharacterCreature.Creature == nil {
			break
		}

		return e.complexity.CharacterCreature.Creature(childComplexity), true

	case "CharacterCreature.endDate":
		if e.complexity.CharacterCreature.EndDate == nil {
			break
		}

		return e.complexity.CharacterCreature.EndDate(childComplexity), true

	case "CharacterCreature.id":
		if e.complexity.CharacterCreature.ID == nil {
			break
		}

		return e.complexity.CharacterCreature.ID(childComplexity), true

	case "CharacterCreature.relation":
		if e.complexity.CharacterCreature.Relation == nil {
			break
		}

		return e.complexity.CharacterCreature.Relation(childComplexity), true

	case "CharacterCreature.startDate":
		if e.complexity.CharacterCreature.StartDate == nil {
			break
		}

		return e.complexity.CharacterCreature.StartDate(childComplexity), true

	case "CharacterEvent.character":
		if e.complexity.CharacterEvent.Character == nil {
			break
		}

		return e.complexity.CharacterEvent.Character(childComplexity), true

	case "CharacterEvent.endDate":
		if e.complexity.CharacterEvent.EndDate == nil {
			break
		}

		return e.complexity.CharacterEvent.EndDate(childComplexity), true

	case "CharacterEvent.event":
		if e.complexity.CharacterEvent.Event == nil {
			break
		}

		return e.complexity.CharacterEvent.Event(childComplexity), true

	case "CharacterEvent.id":
		if e.complexity.CharacterEvent.ID == nil {
			break
		}

		return e.complexity.CharacterEvent.ID(childComplexity), true

	case "CharacterEvent.relation":
		if e.complexity.CharacterEvent.Relation == nil {
			break
		}

		return e.complexity.CharacterEvent.Relation(childComplexity), true

	case "CharacterEvent.startDate":
		if e.complexity.CharacterEvent.StartDate == nil {
			break
		}

		return e.complexity.CharacterEvent.StartDate(childComplexity), true

	case "CharacterFaction.character":
		if e.complexity.CharacterFaction.Character == nil {
			break
		}

		return e.complexity.CharacterFaction.Character(childComplexity), true

	case "CharacterFaction.endDate":
		if e.complexity.CharacterFaction.EndDate == nil {
			break
		}

		return e.complexity.CharacterFaction.EndDate(childComplexity), true

	case "CharacterFaction.faction":
		if e.complexity.CharacterFaction.Faction == nil {
			break
		}

		return e.complexity.CharacterFaction.Faction(childComplexity), true

	case "CharacterFaction.id":
		if e.complexity.CharacterFaction.ID == nil {
			break
		}

		return e.complexity.CharacterFaction.ID(childComplexity), true

	case "CharacterFaction.relation":
		if e.complexity.CharacterFaction.Relation == nil {
			break
		}

		return e.complexity.CharacterFaction.Relation(childComplexity), true

	case "CharacterFaction.startDate":
		if e.complexity.CharacterFaction.StartDate == nil {
			break
		}

		return e.complexity.CharacterFaction.StartDate(childComplexity), true

	case "CharacterItem.character":
		if e.complexity.CharacterItem.Character == nil {
			break
		}

		return e.complexity.CharacterItem.Character(childComplexity), true

	case "CharacterItem.endDate":
		if e.complexity.CharacterItem.EndDate == nil {
			break
		}

		return e.complexity.CharacterItem.EndDate(childComplexity), true

	case "CharacterItem.id":
		if e.complexity.CharacterItem.ID == nil {
			break
		}

		return e.complexity.CharacterItem.ID(childComplexity), true

	case "CharacterItem.item":
		if e.complexity.CharacterItem.Item == nil {
			break
		}

		return e.complexity.CharacterItem.Item(childComplexity), true

	case "CharacterItem.relation":
		if e.complexity.CharacterItem.Relation == nil {
			break
		}

		return e.complexity.CharacterItem.Relation(childComplexity), true

	case "CharacterItem.startDate":
		if e.complexity.CharacterItem.StartDate == nil {
			break
		}

		return e.complexity.CharacterItem.StartDate(childComplexity), true

	case "CharacterLocation.character":
		if e.complexity.CharacterLocation.Character == nil {
			break
		}

		return e.complexity.CharacterLocation.Character(childComplexity), true

	case "CharacterLocation.endDate":
		if e.complexity.CharacterLocation.EndDate == nil {
			break
		}

		return e.complexity.CharacterLocation.EndDate(childComplexity), true

	case "CharacterLocation.id":
		if e.complexity.CharacterLocation.ID == nil {
			break
		}

		return e.complexity.CharacterLocation.ID(childComplexity), true

	case "CharacterLocation.location":
		if e.complexity.CharacterLocation.Location == nil {
			break
		}

		return e.complexity.CharacterLocation.Location(childComplexity), true

	case "CharacterLocation.relation":
		if e.complexity.CharacterLocation.Relation == nil {
			break
		}

		return e.complexity.CharacterLocation.Relation(childComplexity), true

	case "CharacterLocation.startDate":
		if e.complexity.CharacterLocation.StartDate == nil {
			break
		}

		return e.complexity.CharacterLocation.StartDate(childComplexity), true

	case "CharacterWorld.character":
		if e.complexity.CharacterWorld.Character == nil {
			break
		}

		return e.complexity.CharacterWorld.Character(childComplexity), true

	case "CharacterWorld.endDate":
		if e.complexity.CharacterWorld.EndDate == nil {
			break
		}

		return e.complexity.CharacterWorld.EndDate(childComplexity), true

	case "CharacterWorld.id":
		if e.complexity.CharacterWorld.ID == nil {
			break
		}

		return e.complexity.CharacterWorld.ID(childComplexity), true

	case "CharacterWorld.relation":
		if e.complexity.CharacterWorld.Relation == nil {
			break
		}

		return e.complexity.CharacterWorld.Relation(childComplexity), true

	case "CharacterWorld.startDate":
		if e.complexity.CharacterWorld.StartDate == nil {
			break
		}

		return e.complexity.CharacterWorld.StartDate(childComplexity), true

	case "CharacterWorld.world":
		if e.complexity.CharacterWorld.World == nil {
			break
		}

		return e.complexity.CharacterWorld.World(childComplexity), true

	case "Creature.abilities":
		if e.complexity.Creature.Abilities == nil {
			break
		}

		return e.complexity.Creature.Abilities(childComplexity), true

	case "Creature.behavior":
		if e.complexity.Creature.Behavior == nil {
			break
		}

		return e.complexity.Creature.Behavior(childComplexity), true

	case "Creature.birthDate":
		if e.complexity.Creature.BirthDate == nil {
			break
		}

		return e.complexity.Creature.BirthDate(childComplexity), true

	case "Creature.characters":
		if e.complexity.Creature.Characters == nil {
			break
		}

		return e.complexity.Creature.Characters(childComplexity), true

	case "Creature.createdAt":
		if e.complexity.Creature.CreatedAt == nil {
			break
		}

		return e.complexity.Creature.CreatedAt(childComplexity), true

	case "Creature.creatures":
		if e.complexity.Creature.Creatures == nil {
			break
		}

		return e.complexity.Creature.Creatures(childComplexity), true

	case "Creature.description":
		if e.complexity.Creature.Description == nil {
			break
		}

		return e.complexity.Creature.Description(childComplexity), true

	case "Creature.diet":
		if e.complexity.Creature.Diet == nil {
			break
		}

		return e.complexity.Creature.Diet(childComplexity), true

	case "Creature.events":
		if e.complexity.Creature.Events == nil {
			break
		}

		return e.complexity.Creature.Events(childComplexity), true

	case "Creature.factions":
		if e.complexity.Creature.Factions == nil {
			break
		}

		return e.complexity.Creature.Factions(childComplexity), true

	case "Creature.habitat":
		if e.complexity.Creature.Habitat == nil {
			break
		}

		return e.complexity.Creature.Habitat(childComplexity), true

	case "Creature.height":
		if e.complexity.Creature.Height == nil {
			break
		}

		return e.complexity.Creature.Height(childComplexity), true

	case "Creature.id":
		if e.complexity.Creature.ID == nil {
			break
		}

		return e.complexity.Creature.ID(childComplexity), true

	case "Creature.intelligenceLevel":
		if e.complexity.Creature.IntelligenceLevel == nil {
			break
		}

		return e.complexity.Creature.IntelligenceLevel(childComplexity), true

	case "Creature.isAlive":
		if e.complexity.Creature.IsAlive == nil {
			break
		}

		return e.complexity.Creature.IsAlive(childComplexity), true

	case "Creature.isUnique":
		if e.complexity.Creature.IsUnique == nil {
			break
		}

		return e.complexity.Creature.IsUnique(childComplexity), true

	case "Creature.lifespan":
		if e.complexity.Creature.Lifespan == nil {
			break
		}

		return e.complexity.Creature.Lifespan(childComplexity), true

	case "Creature.locations":
		if e.complexity.Creature.Locations == nil {
			break
		}

		return e.complexity.Creature.Locations(childComplexity), true

	case "Creature.name":
		if e.complexity.Creature.Name == nil {
			break
		}

		return e.complexity.Creature.Name(childComplexity), true

	case "Creature.species":
		if e.complexity.Creature.Species == nil {
			break
		}

		return e.complexity.Creature.Species(childComplexity), true

	case "Creature.type":
		if e.complexity.Creature.Type == nil {
			break
		}

		return e.complexity.Creature.Type(childComplexity), true

	case "Creature.updatedAt":
		if e.complexity.Creature.UpdatedAt == nil {
			break
		}

		return e.complexity.Creature.UpdatedAt(childComplexity), true

	case "Creature.weight":
		if e.complexity.Creature.Weight == nil {
			break
		}

		return e.complexity.Creature.Weight(childComplexity), true

	case "Creature.worlds":
		if e.complexity.Creature.Worlds == nil {
			break
		}

		return e.complexity.Creature.Worlds(childComplexity), true

	case "CreatureCreature.creature":
		if e.complexity.CreatureCreature.Creature == nil {
			break
		}

		return e.complexity.CreatureCreature.Creature(childComplexity), true

	case "CreatureCreature.endDate":
		if e.complexity.CreatureCreature.EndDate == nil {
			break
		}

		return e.complexity.CreatureCreature.EndDate(childComplexity), true

	case "CreatureCreature.id":
		if e.complexity.CreatureCreature.ID == nil {
			break
		}

		return e.complexity.CreatureCreature.ID(childComplexity), true

	case "CreatureCreature.relation":
		if e.complexity.CreatureCreature.Relation == nil {
			break
		}

		return e.complexity.CreatureCreature.Relation(childComplexity), true

	case "CreatureCreature.startDate":
		if e.complexity.CreatureCreature.StartDate == nil {
			break
		}

		return e.complexity.CreatureCreature.StartDate(childComplexity), true

	case "CreatureEvent.creature":
		if e.complexity.CreatureEvent.Creature == nil {
			break
		}

		return e.complexity.CreatureEvent.Creature(childComplexity), true

	case "CreatureEvent.endDate":
		if e.complexity.CreatureEvent.EndDate == nil {
			break
		}

		return e.complexity.CreatureEvent.EndDate(childComplexity), true

	case "CreatureEvent.event":
		if e.complexity.CreatureEvent.Event == nil {
			break
		}

		return e.complexity.CreatureEvent.Event(childComplexity), true

	case "CreatureEvent.id":
		if e.complexity.CreatureEvent.ID == nil {
			break
		}

		return e.complexity.CreatureEvent.ID(childComplexity), true

	case "CreatureEvent.relation":
		if e.complexity.CreatureEvent.Relation == nil {
			break
		}

		return e.complexity.CreatureEvent.Relation(childComplexity), true

	case "CreatureEvent.startDate":
		if e.complexity.CreatureEvent.StartDate == nil {
			break
		}

		return e.complexity.CreatureEvent.StartDate(childComplexity), true

	case "CreatureFaction.creature":
		if e.complexity.CreatureFaction.Creature == nil {
			break
		}

		return e.complexity.CreatureFaction.Creature(childComplexity), true

	case "CreatureFaction.endDate":
		if e.complexity.CreatureFaction.EndDate == nil {
			break
		}

		return e.complexity.CreatureFaction.EndDate(childComplexity), true

	case "CreatureFaction.faction":
		if e.complexity.CreatureFaction.Faction == nil {
			break
		}

		return e.complexity.CreatureFaction.Faction(childComplexity), true

	case "CreatureFaction.id":
		if e.complexity.CreatureFaction.ID == nil {
			break
		}

		return e.complexity.CreatureFaction.ID(childComplexity), true

	case "CreatureFaction.relation":
		if e.complexity.CreatureFaction.Relation == nil {
			break
		}

		return e.complexity.CreatureFaction.Relation(childComplexity), true

	case "CreatureFaction.startDate":
		if e.complexity.CreatureFaction.StartDate == nil {
			break
		}

		return e.complexity.CreatureFaction.StartDate(childComplexity), true

	case "CreatureLocation.creature":
		if e.complexity.CreatureLocation.Creature == nil {
			break
		}

		return e.complexity.CreatureLocation.Creature(childComplexity), true

	case "CreatureLocation.endDate":
		if e.complexity.CreatureLocation.EndDate == nil {
			break
		}

		return e.complexity.CreatureLocation.EndDate(childComplexity), true

	case "CreatureLocation.id":
		if e.complexity.CreatureLocation.ID == nil {
			break
		}

		return e.complexity.CreatureLocation.ID(childComplexity), true

	case "CreatureLocation.location":
		if e.complexity.CreatureLocation.Location == nil {
			break
		}

		return e.complexity.CreatureLocation.Location(childComplexity), true

	case "CreatureLocation.relation":
		if e.complexity.CreatureLocation.Relation == nil {
			break
		}

		return e.complexity.CreatureLocation.Relation(childComplexity), true

	case "CreatureLocation.startDate":
		if e.complexity.CreatureLocation.StartDate == nil {
			break
		}

		return e.complexity.CreatureLocation.StartDate(childComplexity), true

	case "CreatureWorld.creature":
		if e.complexity.CreatureWorld.Creature == nil {
			break
		}

		return e.complexity.CreatureWorld.Creature(childComplexity), true

	case "CreatureWorld.endDate":
		if e.complexity.CreatureWorld.EndDate == nil {
			break
		}

		return e.complexity.CreatureWorld.EndDate(childComplexity), true

	case "CreatureWorld.id":
		if e.complexity.CreatureWorld.ID == nil {
			break
		}

		return e.complexity.CreatureWorld.ID(childComplexity), true

	case "CreatureWorld.relation":
		if e.complexity.CreatureWorld.Relation == nil {
			break
		}

		return e.complexity.CreatureWorld.Relation(childComplexity), true

	case "CreatureWorld.startDate":
		if e.complexity.CreatureWorld.StartDate == nil {
			break
		}

		return e.complexity.CreatureWorld.StartDate(childComplexity), true

	case "CreatureWorld.world":
		if e.complexity.CreatureWorld.World == nil {
			break
		}

		return e.complexity.CreatureWorld.World(childComplexity), true

	case "Event.characters":
		if e.complexity.Event.Characters == nil {
			break
		}

		return e.complexity.Event.Characters(childComplexity), true

	case "Event.createdAt":
		if e.complexity.Event.CreatedAt == nil {
			break
		}

		return e.complexity.Event.CreatedAt(childComplexity), true

	case "Event.creatures":
		if e.complexity.Event.Creatures == nil {
			break
		}

		return e.complexity.Event.Creatures(childComplexity), true

	case "Event.description":
		if e.complexity.Event.Description == nil {
			break
		}

		return e.complexity.Event.Description(childComplexity), true

	case "Event.endDate":
		if e.complexity.Event.EndDate == nil {
			break
		}

		return e.complexity.Event.EndDate(childComplexity), true

	case "Event.factions":
		if e.complexity.Event.Factions == nil {
			break
		}

		return e.complexity.Event.Factions(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.isRecurring":
		if e.complexity.Event.IsRecurring == nil {
			break
		}

		return e.complexity.Event.IsRecurring(childComplexity), true

	case "Event.items":
		if e.complexity.Event.Items == nil {
			break
		}

		return e.complexity.Event.Items(childComplexity), true

	case "Event.locations":
		if e.complexity.Event.Locations == nil {
			break
		}

		return e.complexity.Event.Locations(childComplexity), true

	case "Event.name":
		if e.complexity.Event.Name == nil {
			break
		}

		return e.complexity.Event.Name(childComplexity), true

	case "Event.nature":
		if e.complexity.Event.Nature == nil {
			break
		}

		return e.complexity.Event.Nature(childComplexity), true

	case "Event.relatedEvents":
		if e.complexity.Event.RelatedEvents == nil {
			break
		}

		return e.complexity.Event.RelatedEvents(childComplexity), true

	case "Event.significance":
		if e.complexity.Event.Significance == nil {
			break
		}

		return e.complexity.Event.Significance(childComplexity), true

	case "Event.startDate":
		if e.complexity.Event.StartDate == nil {
			break
		}

		return e.complexity.Event.StartDate(childComplexity), true

	case "Event.type":
		if e.complexity.Event.Type == nil {
			break
		}

		return e.complexity.Event.Type(childComplexity), true

	case "Event.updatedAt":
		if e.complexity.Event.UpdatedAt == nil {
			break
		}

		return e.complexity.Event.UpdatedAt(childComplexity), true

	case "Event.worlds":
		if e.complexity.Event.Worlds == nil {
			break
		}

		return e.complexity.Event.Worlds(childComplexity), true

	case "Faction.characters":
		if e.complexity.Faction.Characters == nil {
			break
		}

		return e.complexity.Faction.Characters(childComplexity), true

	case "Faction.createdAt":
		if e.complexity.Faction.CreatedAt == nil {
			break
		}

		return e.complexity.Faction.CreatedAt(childComplexity), true

	case "Faction.creatures":
		if e.complexity.Faction.Creatures == nil {
			break
		}

		return e.complexity.Faction.Creatures(childComplexity), true

	case "Faction.description":
		if e.complexity.Faction.Description == nil {
			break
		}

		return e.complexity.Faction.Description(childComplexity), true

	case "Faction.disbandedDate":
		if e.complexity.Faction.DisbandedDate == nil {
			break
		}

		return e.complexity.Faction.DisbandedDate(childComplexity), true

	case "Faction.events":
		if e.complexity.Faction.Events == nil {
			break
		}

		return e.complexity.Faction.Events(childComplexity), true

	case "Faction.factions":
		if e.complexity.Faction.Factions == nil {
			break
		}

		return e.complexity.Faction.Factions(childComplexity), true

	case "Faction.foundedDate":
		if e.complexity.Faction.FoundedDate == nil {
			break
		}

		return e.complexity.Faction.FoundedDate(childComplexity), true

	case "Faction.id":
		if e.complexity.Faction.ID == nil {
			break
		}

		return e.complexity.Faction.ID(childComplexity), true

	case "Faction.ideology":
		if e.complexity.Faction.Ideology == nil {
			break
		}

		return e.complexity.Faction.Ideology(childComplexity), true

	case "Faction.influence":
		if e.complexity.Faction.Influence == nil {
			break
		}

		return e.complexity.Faction.Influence(childComplexity), true

	case "Faction.items":
		if e.complexity.Faction.Items == nil {
			break
		}

		return e.complexity.Faction.Items(childComplexity), true

	case "Faction.locations":
		if e.complexity.Faction.Locations == nil {
			break
		}

		return e.complexity.Faction.Locations(childComplexity), true

	case "Faction.name":
		if e.complexity.Faction.Name == nil {
			break
		}

		return e.complexity.Faction.Name(childComplexity), true

	case "Faction.status":
		if e.complexity.Faction.Status == nil {
			break
		}

		return e.complexity.Faction.Status(childComplexity), true

	case "Faction.type":
		if e.complexity.Faction.Type == nil {
			break
		}

		return e.complexity.Faction.Type(childComplexity), true

	case "Faction.updatedAt":
		if e.complexity.Faction.UpdatedAt == nil {
			break
		}

		return e.complexity.Faction.UpdatedAt(childComplexity), true

	case "Faction.worlds":
		if e.complexity.Faction.Worlds == nil {
			break
		}

		return e.complexity.Faction.Worlds(childComplexity), true

	case "FactionEvent.endDate":
		if e.complexity.FactionEvent.EndDate == nil {
			break
		}

		return e.complexity.FactionEvent.EndDate(childComplexity), true

	case "FactionEvent.event":
		if e.complexity.FactionEvent.Event == nil {
			break
		}

		return e.complexity.FactionEvent.Event(childComplexity), true

	case "FactionEvent.faction":
		if e.complexity.FactionEvent.Faction == nil {
			break
		}

		return e.complexity.FactionEvent.Faction(childComplexity), true

	case "FactionEvent.id":
		if e.complexity.FactionEvent.ID == nil {
			break
		}

		return e.complexity.FactionEvent.ID(childComplexity), true

	case "FactionEvent.relation":
		if e.complexity.FactionEvent.Relation == nil {
			break
		}

		return e.complexity.FactionEvent.Relation(childComplexity), true

	case "FactionEvent.startDate":
		if e.complexity.FactionEvent.StartDate == nil {
			break
		}

		return e.complexity.FactionEvent.StartDate(childComplexity), true

	case "FactionFaction.endDate":
		if e.complexity.FactionFaction.EndDate == nil {
			break
		}

		return e.complexity.FactionFaction.EndDate(childComplexity), true

	case "FactionFaction.faction":
		if e.complexity.FactionFaction.Faction == nil {
			break
		}

		return e.complexity.FactionFaction.Faction(childComplexity), true

	case "FactionFaction.id":
		if e.complexity.FactionFaction.ID == nil {
			break
		}

		return e.complexity.FactionFaction.ID(childComplexity), true

	case "FactionFaction.relation":
		if e.complexity.FactionFaction.Relation == nil {
			break
		}

		return e.complexity.FactionFaction.Relation(childComplexity), true

	case "FactionFaction.startDate":
		if e.complexity.FactionFaction.StartDate == nil {
			break
		}

		return e.complexity.FactionFaction.StartDate(childComplexity), true

	case "FactionItem.endDate":
		if e.complexity.FactionItem.EndDate == nil {
			break
		}

		return e.complexity.FactionItem.EndDate(childComplexity), true

	case "FactionItem.faction":
		if e.complexity.FactionItem.Faction == nil {
			break
		}

		return e.complexity.FactionItem.Faction(childComplexity), true

	case "FactionItem.id":
		if e.complexity.FactionItem.ID == nil {
			break
		}

		return e.complexity.FactionItem.ID(childComplexity), true

	case "FactionItem.item":
		if e.complexity.FactionItem.Item == nil {
			break
		}

		return e.complexity.FactionItem.Item(childComplexity), true

	case "FactionItem.relation":
		if e.complexity.FactionItem.Relation == nil {
			break
		}

		return e.complexity.FactionItem.Relation(childComplexity), true

	case "FactionItem.startDate":
		if e.complexity.FactionItem.StartDate == nil {
			break
		}

		return e.complexity.FactionItem.StartDate(childComplexity), true

	case "FactionLocation.endDate":
		if e.complexity.FactionLocation.EndDate == nil {
			break
		}

		return e.complexity.FactionLocation.EndDate(childComplexity), true

	case "FactionLocation.faction":
		if e.complexity.FactionLocation.Faction == nil {
			break
		}

		return e.complexity.FactionLocation.Faction(childComplexity), true

	case "FactionLocation.id":
		if e.complexity.FactionLocation.ID == nil {
			break
		}

		return e.complexity.FactionLocation.ID(childComplexity), true

	case "FactionLocation.location":
		if e.complexity.FactionLocation.Location == nil {
			break
		}

		return e.complexity.FactionLocation.Location(childComplexity), true

	case "FactionLocation.relation":
		if e.complexity.FactionLocation.Relation == nil {
			break
		}

		return e.complexity.FactionLocation.Relation(childComplexity), true

	case "FactionLocation.startDate":
		if e.complexity.FactionLocation.StartDate == nil {
			break
		}

		return e.complexity.FactionLocation.StartDate(childComplexity), true

	case "FactionWorld.endDate":
		if e.complexity.FactionWorld.EndDate == nil {
			break
		}

		return e.complexity.FactionWorld.EndDate(childComplexity), true

	case "FactionWorld.faction":
		if e.complexity.FactionWorld.Faction == nil {
			break
		}

		return e.complexity.FactionWorld.Faction(childComplexity), true

	case "FactionWorld.id":
		if e.complexity.FactionWorld.ID == nil {
			break
		}

		return e.complexity.FactionWorld.ID(childComplexity), true

	case "FactionWorld.relation":
		if e.complexity.FactionWorld.Relation == nil {
			break
		}

		return e.complexity.FactionWorld.Relation(childComplexity), true

	case "FactionWorld.startDate":
		if e.complexity.FactionWorld.StartDate == nil {
			break
		}

		return e.complexity.FactionWorld.StartDate(childComplexity), true

	case "FactionWorld.world":
		if e.complexity.FactionWorld.World == nil {
			break
		}

		return e.complexity.FactionWorld.World(childComplexity), true

	case "Item.abilities":
		if e.complexity.Item.Abilities == nil {
			break
		}

		return e.complexity.Item.Abilities(childComplexity), true

	case "Item.characters":
		if e.complexity.Item.Characters == nil {
			break
		}

		return e.complexity.Item.Characters(childComplexity), true

	case "Item.condition":
		if e.complexity.Item.Condition == nil {
			break
		}

		return e.complexity.Item.Condition(childComplexity), true

	case "Item.createdAt":
		if e.complexity.Item.CreatedAt == nil {
			break
		}

		return e.complexity.Item.CreatedAt(childComplexity), true

	case "Item.creationDate":
		if e.complexity.Item.CreationDate == nil {
			break
		}

		return e.complexity.Item.CreationDate(childComplexity), true

	case "Item.description":
		if e.complexity.Item.Description == nil {
			break
		}

		return e.complexity.Item.Description(childComplexity), true

	case "Item.destructionDate":
		if e.complexity.Item.DestructionDate == nil {
			break
		}

		return e.complexity.Item.DestructionDate(childComplexity), true

	case "Item.dimensions":
		if e.complexity.Item.Dimensions == nil {
			break
		}

		return e.complexity.Item.Dimensions(childComplexity), true

	case "Item.events":
		if e.complexity.Item.Events == nil {
			break
		}

		return e.complexity.Item.Events(childComplexity), true

	case "Item.factions":
		if e.complexity.Item.Factions == nil {
			break
		}

		return e.complexity.Item.Factions(childComplexity), true

	case "Item.id":
		if e.complexity.Item.ID == nil {
			break
		}

		return e.complexity.Item.ID(childComplexity), true

	case "Item.isMagical":
		if e.complexity.Item.IsMagical == nil {
			break
		}

		return e.complexity.Item.IsMagical(childComplexity), true

	case "Item.locations":
		if e.complexity.Item.Locations == nil {
			break
		}

		return e.complexity.Item.Locations(childComplexity), true

	case "Item.material":
		if e.complexity.Item.Material == nil {
			break
		}

		return e.complexity.Item.Material(childComplexity), true

	case "Item.name":
		if e.complexity.Item.Name == nil {
			break
		}

		return e.complexity.Item.Name(childComplexity), true

	case "Item.rarity":
		if e.complexity.Item.Rarity == nil {
			break
		}

		return e.complexity.Item.Rarity(childComplexity), true

	case "Item.relatedItems":
		if e.complexity.Item.RelatedItems == nil {
			break
		}

		return e.complexity.Item.RelatedItems(childComplexity), true

	case "Item.slot":
		if e.complexity.Item.Slot == nil {
			break
		}

		return e.complexity.Item.Slot(childComplexity), true

	case "Item.type":
		if e.complexity.Item.Type == nil {
			break
		}

		return e.complexity.Item.Type(childComplexity), true

	case "Item.updatedAt":
		if e.complexity.Item.UpdatedAt == nil {
			break
		}

		return e.complexity.Item.UpdatedAt(childComplexity), true

	case "Item.value":
		if e.complexity.Item.Value == nil {
			break
		}

		return e.complexity.Item.Value(childComplexity), true

	case "Item.weight":
		if e.complexity.Item.Weight == nil {
			break
		}

		return e.complexity.Item.Weight(childComplexity), true

	case "ItemEvent.endDate":
		if e.complexity.ItemEvent.EndDate == nil {
			break
		}

		return e.complexity.ItemEvent.EndDate(childComplexity), true

	case "ItemEvent.event":
		if e.complexity.ItemEvent.Event == nil {
			break
		}

		return e.complexity.ItemEvent.Event(childComplexity), true

	case "ItemEvent.id":
		if e.complexity.ItemEvent.ID == nil {
			break
		}

		return e.complexity.ItemEvent.ID(childComplexity), true

	case "ItemEvent.item":
		if e.complexity.ItemEvent.Item == nil {
			break
		}

		return e.complexity.ItemEvent.Item(childComplexity), true

	case "ItemEvent.relation":
		if e.complexity.ItemEvent.Relation == nil {
			break
		}

		return e.complexity.ItemEvent.Relation(childComplexity), true

	case "ItemEvent.startDate":
		if e.complexity.ItemEvent.StartDate == nil {
			break
		}

		return e.complexity.ItemEvent.StartDate(childComplexity), true

	case "ItemItem.endDate":
		if e.complexity.ItemItem.EndDate == nil {
			break
		}

		return e.complexity.ItemItem.EndDate(childComplexity), true

	case "ItemItem.id":
		if e.complexity.ItemItem.ID == nil {
			break
		}

		return e.complexity.ItemItem.ID(childComplexity), true

	case "ItemItem.item":
		if e.complexity.ItemItem.Item == nil {
			break
		}

		return e.complexity.ItemItem.Item(childComplexity), true

	case "ItemItem.relation":
		if e.complexity.ItemItem.Relation == nil {
			break
		}

		return e.complexity.ItemItem.Relation(childComplexity), true

	case "ItemItem.startDate":
		if e.complexity.ItemItem.StartDate == nil {
			break
		}

		return e.complexity.ItemItem.StartDate(childComplexity), true

	case "ItemLocation.endDate":
		if e.complexity.ItemLocation.EndDate == nil {
			break
		}

		return e.complexity.ItemLocation.EndDate(childComplexity), true

	case "ItemLocation.id":
		if e.complexity.ItemLocation.ID == nil {
			break
		}

		return e.complexity.ItemLocation.ID(childComplexity), true

	case "ItemLocation.item":
		if e.complexity.ItemLocation.Item == nil {
			break
		}

		return e.complexity.ItemLocation.Item(childComplexity), true

	case "ItemLocation.relation":
		if e.complexity.ItemLocation.Relation == nil {
			break
		}

		return e.complexity.ItemLocation.Relation(childComplexity), true

	case "ItemLocation.startDate":
		if e.complexity.ItemLocation.StartDate == nil {
			break
		}

		return e.complexity.ItemLocation.StartDate(childComplexity), true

	case "ItemLocation.with":
		if e.complexity.ItemLocation.With == nil {
			break
		}

		return e.complexity.ItemLocation.With(childComplexity), true

	case "Location.accessibility":
		if e.complexity.Location.Accessibility == nil {
			break
		}

		return e.complexity.Location.Accessibility(childComplexity), true

	case "Location.characters":
		if e.complexity.Location.Characters == nil {
			break
		}

		return e.complexity.Location.Characters(childComplexity), true

	case "Location.climate":
		if e.complexity.Location.Climate == nil {
			break
		}

		return e.complexity.Location.Climate(childComplexity), true

	case "Location.coordinates":
		if e.complexity.Location.Coordinates == nil {
			break
		}

		return e.complexity.Location.Coordinates(childComplexity), true

	case "Location.createdAt":
		if e.complexity.Location.CreatedAt == nil {
			break
		}

		return e.complexity.Location.CreatedAt(childComplexity), true

	case "Location.creatures":
		if e.complexity.Location.Creatures == nil {
			break
		}

		return e.complexity.Location.Creatures(childComplexity), true

	case "Location.description":
		if e.complexity.Location.Description == nil {
			break
		}

		return e.complexity.Location.Description(childComplexity), true

	case "Location.ecosystem":
		if e.complexity.Location.Ecosystem == nil {
			break
		}

		return e.complexity.Location.Ecosystem(childComplexity), true

	case "Location.events":
		if e.complexity.Location.Events == nil {
			break
		}

		return e.complexity.Location.Events(childComplexity), true

	case "Location.factions":
		if e.complexity.Location.Factions == nil {
			break
		}

		return e.complexity.Location.Factions(childComplexity), true

	case "Location.id":
		if e.complexity.Location.ID == nil {
			break
		}

		return e.complexity.Location.ID(childComplexity), true

	case "Location.isNatural":
		if e.complexity.Location.IsNatural == nil {
			break
		}

		return e.complexity.Location.IsNatural(childComplexity), true

	case "Location.items":
		if e.complexity.Location.Items == nil {
			break
		}

		return e.complexity.Location.Items(childComplexity), true

	case "Location.name":
		if e.complexity.Location.Name == nil {
			break
		}

		return e.complexity.Location.Name(childComplexity), true

	case "Location.region":
		if e.complexity.Location.Region == nil {
			break
		}

		return e.complexity.Location.Region(childComplexity), true

	case "Location.relatedLocations":
		if e.complexity.Location.RelatedLocations == nil {
			break
		}

		return e.complexity.Location.RelatedLocations(childComplexity), true

	case "Location.type":
		if e.complexity.Location.Type == nil {
			break
		}

		return e.complexity.Location.Type(childComplexity), true

	case "Location.updatedAt":
		if e.complexity.Location.UpdatedAt == nil {
			break
		}

		return e.complexity.Location.UpdatedAt(childComplexity), true

	case "Location.worlds":
		if e.complexity.Location.Worlds == nil {
			break
		}

		return e.complexity.Location.Worlds(childComplexity), true

	case "LocationEvent.endDate":
		if e.complexity.LocationEvent.EndDate == nil {
			break
		}

		return e.complexity.LocationEvent.EndDate(childComplexity), true

	case "LocationEvent.event":
		if e.complexity.LocationEvent.Event == nil {
			break
		}

		return e.complexity.LocationEvent.Event(childComplexity), true

	case "LocationEvent.id":
		if e.complexity.LocationEvent.ID == nil {
			break
		}

		return e.complexity.LocationEvent.ID(childComplexity), true

	case "LocationEvent.location":
		if e.complexity.LocationEvent.Location == nil {
			break
		}

		return e.complexity.LocationEvent.Location(childComplexity), true

	case "LocationEvent.relation":
		if e.complexity.LocationEvent.Relation == nil {
			break
		}

		return e.complexity.LocationEvent.Relation(childComplexity), true

	case "LocationEvent.startDate":
		if e.complexity.LocationEvent.StartDate == nil {
			break
		}

		return e.complexity.LocationEvent.StartDate(childComplexity), true

	case "LocationLocation.endDate":
		if e.complexity.LocationLocation.EndDate == nil {
			break
		}

		return e.complexity.LocationLocation.EndDate(childComplexity), true

	case "LocationLocation.id":
		if e.complexity.LocationLocation.ID == nil {
			break
		}

		return e.complexity.LocationLocation.ID(childComplexity), true

	case "LocationLocation.location":
		if e.complexity.LocationLocation.Location == nil {
			break
		}

		return e.complexity.LocationLocation.Location(childComplexity), true

	case "LocationLocation.relation":
		if e.complexity.LocationLocation.Relation == nil {
			break
		}

		return e.complexity.LocationLocation.Relation(childComplexity), true

	case "LocationLocation.startDate":
		if e.complexity.LocationLocation.StartDate == nil {
			break
		}

		return e.complexity.LocationLocation.StartDate(childComplexity), true

	case "LocationWorld.endDate":
		if e.complexity.LocationWorld.EndDate == nil {
			break
		}

		return e.complexity.LocationWorld.EndDate(childComplexity), true

	case "LocationWorld.id":
		if e.complexity.LocationWorld.ID == nil {
			break
		}

		return e.complexity.LocationWorld.ID(childComplexity), true

	case "LocationWorld.location":
		if e.complexity.LocationWorld.Location == nil {
			break
		}

		return e.complexity.LocationWorld.Location(childComplexity), true

	case "LocationWorld.relation":
		if e.complexity.LocationWorld.Relation == nil {
			break
		}

		return e.complexity.LocationWorld.Relation(childComplexity), true

	case "LocationWorld.startDate":
		if e.complexity.LocationWorld.StartDate == nil {
			break
		}

		return e.complexity.LocationWorld.StartDate(childComplexity), true

	case "LocationWorld.world":
		if e.complexity.LocationWorld.World == nil {
			break
		}

		return e.complexity.LocationWorld.World(childComplexity), true

	case "Mutation.createCharacter":
		if e.complexity.Mutation.CreateCharacter == nil {
			break
		}

		args, err := ec.field_Mutation_createCharacter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCharacter(childComplexity, args["input"].(model.CreateCharacterInput)), true

	case "Mutation.createCreature":
		if e.complexity.Mutation.CreateCreature == nil {
			break
		}

		args, err := ec.field_Mutation_createCreature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCreature(childComplexity, args["input"].(model.CreateCreatureInput)), true

	case "Mutation.createEvent":
		if e.complexity.Mutation.CreateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_createEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateEvent(childComplexity, args["input"].(model.CreateEventInput)), true

	case "Mutation.createFaction":
		if e.complexity.Mutation.CreateFaction == nil {
			break
		}

		args, err := ec.field_Mutation_createFaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFaction(childComplexity, args["input"].(model.CreateFactionInput)), true

	case "Mutation.createItem":
		if e.complexity.Mutation.CreateItem == nil {
			break
		}

		args, err := ec.field_Mutation_createItem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateItem(childComplexity, args["input"].(model.CreateItemInput)), true

	case "Mutation.createLocation":
		if e.complexity.Mutation.CreateLocation == nil {
			break
		}

		args, err := ec.field_Mutation_createLocation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateLocation(childComplexity, args["input"].(model.CreateLocationInput)), true

	case "Mutation.createUniverse":
		if e.complexity.Mutation.CreateUniverse == nil {
			break
		}

		args, err := ec.field_Mutation_createUniverse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUniverse(childComplexity, args["input"].(model.CreateUniverseInput)), true

	case "Mutation.createWorld":
		if e.complexity.Mutation.CreateWorld == nil {
			break
		}

		args, err := ec.field_Mutation_createWorld_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateWorld(childComplexity, args["input"].(model.CreateWorldInput)), true

	case "Mutation.deleteCharacter":
		if e.complexity.Mutation.DeleteCharacter == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCharacter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCharacter(childComplexity, args["id"].(string)), true

	case "Mutation.deleteCreature":
		if e.complexity.Mutation.DeleteCreature == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCreature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCreature(childComplexity, args["id"].(string)), true

	case "Mutation.deleteEvent":
		if e.complexity.Mutation.DeleteEvent == nil {
			break
		}

		args, err := ec.field_Mutation_deleteEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteEvent(childComplexity, args["id"].(string)), true

	case "Mutation.deleteFaction":
		if e.complexity.Mutation.DeleteFaction == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFaction(childComplexity, args["id"].(string)), true

	case "Mutation.deleteItem":
		if e.complexity.Mutation.DeleteItem == nil {
			break
		}

		args, err := ec.field_Mutation_deleteItem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteItem(childComplexity, args["id"].(string)), true

	case "Mutation.deleteLocation":
		if e.complexity.Mutation.DeleteLocation == nil {
			break
		}

		args, err := ec.field_Mutation_deleteLocation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteLocation(childComplexity, args["id"].(string)), true

	case "Mutation.deleteUniverse":
		if e.complexity.Mutation.DeleteUniverse == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUniverse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUniverse(childComplexity, args["id"].(string)), true

	case "Mutation.deleteWorld":
		if e.complexity.Mutation.DeleteWorld == nil {
			break
		}

		args, err := ec.field_Mutation_deleteWorld_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteWorld(childComplexity, args["id"].(string)), true

	case "Mutation.updateCharacter":
		if e.complexity.Mutation.UpdateCharacter == nil {
			break
		}

		args, err := ec.field_Mutation_updateCharacter_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCharacter(childComplexity, args["input"].(model.UpdateCharacterInput)), true

	case "Mutation.updateCreature":
		if e.complexity.Mutation.UpdateCreature == nil {
			break
		}

		args, err := ec.field_Mutation_updateCreature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCreature(childComplexity, args["input"].(model.UpdateCreatureInput)), true

	case "Mutation.updateEvent":
		if e.complexity.Mutation.UpdateEvent == nil {
			break
		}

		args, err := ec.field_Mutation_updateEvent_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateEvent(childComplexity, args["input"].(model.UpdateEventInput)), true

	case "Mutation.updateFaction":
		if e.complexity.Mutation.UpdateFaction == nil {
			break
		}

		args, err := ec.field_Mutation_updateFaction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateFaction(childComplexity, args["input"].(model.UpdateFactionInput)), true

	case "Mutation.updateItem":
		if e.complexity.Mutation.UpdateItem == nil {
			break
		}

		args, err := ec.field_Mutation_updateItem_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateItem(childComplexity, args["input"].(model.UpdateItemInput)), true

	case "Mutation.updateLocation":
		if e.complexity.Mutation.UpdateLocation == nil {
			break
		}

		args, err := ec.field_Mutation_updateLocation_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateLocation(childComplexity, args["input"].(model.UpdateLocationInput)), true

	case "Mutation.updateUniverse":
		if e.complexity.Mutation.UpdateUniverse == nil {
			break
		}

		args, err := ec.field_Mutation_updateUniverse_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUniverse(childComplexity, args["input"].(model.UpdateUniverseInput)), true

	case "Mutation.updateWorld":
		if e.complexity.Mutation.UpdateWorld == nil {
			break
		}

		args, err := ec.field_Mutation_updateWorld_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateWorld(childComplexity, args["input"].(model.UpdateWorldInput)), true

	case "Query.character":
		if e.complexity.Query.Character == nil {
			break
		}

		args, err := ec.field_Query_character_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Character(childComplexity, args["id"].(string)), true

	case "Query.characters":
		if e.complexity.Query.Characters == nil {
			break
		}

		args, err := ec.field_Query_characters_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Characters(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.creature":
		if e.complexity.Query.Creature == nil {
			break
		}

		args, err := ec.field_Query_creature_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Creature(childComplexity, args["id"].(string)), true

	case "Query.creatures":
		if e.complexity.Query.Creatures == nil {
			break
		}

		args, err := ec.field_Query_creatures_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Creatures(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.event":
		if e.complexity.Query.Event == nil {
			break
		}

		args, err := ec.field_Query_event_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Event(childComplexity, args["id"].(string)), true

	case "Query.events":
		if e.complexity.Query.Events == nil {
			break
		}

		args, err := ec.field_Query_events_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Events(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.faction":
		if e.complexity.Query.Faction == nil {
			break
		}

		args, err := ec.field_Query_faction_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Faction(childComplexity, args["id"].(string)), true

	case "Query.factions":
		if e.complexity.Query.Factions == nil {
			break
		}

		args, err := ec.field_Query_factions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Factions(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.item":
		if e.complexity.Query.Item == nil {
			break
		}

		args, err := ec.field_Query_item_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Item(childComplexity, args["id"].(string)), true

	case "Query.items":
		if e.complexity.Query.Items == nil {
			break
		}

		args, err := ec.field_Query_items_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Items(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.location":
		if e.complexity.Query.Location == nil {
			break
		}

		args, err := ec.field_Query_location_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Location(childComplexity, args["id"].(string)), true

	case "Query.locations":
		if e.complexity.Query.Locations == nil {
			break
		}

		args, err := ec.field_Query_locations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Locations(childComplexity, args["worldId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Query.universe":
		if e.complexity.Query.Universe == nil {
			break
		}

		args, err := ec.field_Query_universe_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Universe(childComplexity, args["id"].(string)), true

	case "Query.universes":
		if e.complexity.Query.Universes == nil {
			break
		}

		args, err := ec.field_Query_universes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Universes(childComplexity, args["limit"].(*int), args["offset"].(*int)), true

	case "Query.world":
		if e.complexity.Query.World == nil {
			break
		}

		args, err := ec.field_Query_world_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.World(childComplexity, args["id"].(string)), true

	case "Query.worlds":
		if e.complexity.Query.Worlds == nil {
			break
		}

		args, err := ec.field_Query_worlds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Worlds(childComplexity, args["universeId"].(string), args["limit"].(*int), args["offset"].(*int)), true

	case "Response.message":
		if e.complexity.Response.Message == nil {
			break
		}

		return e.complexity.Response.Message(childComplexity), true

	case "Response.status":
		if e.complexity.Response.Status == nil {
			break
		}

		return e.complexity.Response.Status(childComplexity), true

	case "Universe.characters":
		if e.complexity.Universe.Characters == nil {
			break
		}

		return e.complexity.Universe.Characters(childComplexity), true

	case "Universe.createdAt":
		if e.complexity.Universe.CreatedAt == nil {
			break
		}

		return e.complexity.Universe.CreatedAt(childComplexity), true

	case "Universe.creatures":
		if e.complexity.Universe.Creatures == nil {
			break
		}

		return e.complexity.Universe.Creatures(childComplexity), true

	case "Universe.description":
		if e.complexity.Universe.Description == nil {
			break
		}

		return e.complexity.Universe.Description(childComplexity), true

	case "Universe.events":
		if e.complexity.Universe.Events == nil {
			break
		}

		return e.complexity.Universe.Events(childComplexity), true

	case "Universe.factions":
		if e.complexity.Universe.Factions == nil {
			break
		}

		return e.complexity.Universe.Factions(childComplexity), true

	case "Universe.id":
		if e.complexity.Universe.ID == nil {
			break
		}

		return e.complexity.Universe.ID(childComplexity), true

	case "Universe.isActive":
		if e.complexity.Universe.IsActive == nil {
			break
		}

		return e.complexity.Universe.IsActive(childComplexity), true

	case "Universe.items":
		if e.complexity.Universe.Items == nil {
			break
		}

		return e.complexity.Universe.Items(childComplexity), true

	case "Universe.locations":
		if e.complexity.Universe.Locations == nil {
			break
		}

		return e.complexity.Universe.Locations(childComplexity), true

	case "Universe.name":
		if e.complexity.Universe.Name == nil {
			break
		}

		return e.complexity.Universe.Name(childComplexity), true

	case "Universe.startYear":
		if e.complexity.Universe.StartYear == nil {
			break
		}

		return e.complexity.Universe.StartYear(childComplexity), true

	case "Universe.updatedAt":
		if e.complexity.Universe.UpdatedAt == nil {
			break
		}

		return e.complexity.Universe.UpdatedAt(childComplexity), true

	case "Universe.worlds":
		if e.complexity.Universe.Worlds == nil {
			break
		}

		return e.complexity.Universe.Worlds(childComplexity), true

	case "World.characters":
		if e.complexity.World.Characters == nil {
			break
		}

		return e.complexity.World.Characters(childComplexity), true

	case "World.climate":
		if e.complexity.World.Climate == nil {
			break
		}

		return e.complexity.World.Climate(childComplexity), true

	case "World.connectedWorlds":
		if e.complexity.World.ConnectedWorlds == nil {
			break
		}

		return e.complexity.World.ConnectedWorlds(childComplexity), true

	case "World.createdAt":
		if e.complexity.World.CreatedAt == nil {
			break
		}

		return e.complexity.World.CreatedAt(childComplexity), true

	case "World.creatures":
		if e.complexity.World.Creatures == nil {
			break
		}

		return e.complexity.World.Creatures(childComplexity), true

	case "World.description":
		if e.complexity.World.Description == nil {
			break
		}

		return e.complexity.World.Description(childComplexity), true

	case "World.ecosystem":
		if e.complexity.World.Ecosystem == nil {
			break
		}

		return e.complexity.World.Ecosystem(childComplexity), true

	case "World.energySources":
		if e.complexity.World.EnergySources == nil {
			break
		}

		return e.complexity.World.EnergySources(childComplexity), true

	case "World.events":
		if e.complexity.World.Events == nil {
			break
		}

		return e.complexity.World.Events(childComplexity), true

	case "World.factions":
		if e.complexity.World.Factions == nil {
			break
		}

		return e.complexity.World.Factions(childComplexity), true

	case "World.gravity":
		if e.complexity.World.Gravity == nil {
			break
		}

		return e.complexity.World.Gravity(childComplexity), true

	case "World.hasAtmosphere":
		if e.complexity.World.HasAtmosphere == nil {
			break
		}

		return e.complexity.World.HasAtmosphere(childComplexity), true

	case "World.id":
		if e.complexity.World.ID == nil {
			break
		}

		return e.complexity.World.ID(childComplexity), true

	case "World.isHabitable":
		if e.complexity.World.IsHabitable == nil {
			break
		}

		return e.complexity.World.IsHabitable(childComplexity), true

	case "World.locations":
		if e.complexity.World.Locations == nil {
			break
		}

		return e.complexity.World.Locations(childComplexity), true

	case "World.moons":
		if e.complexity.World.Moons == nil {
			break
		}

		return e.complexity.World.Moons(childComplexity), true

	case "World.name":
		if e.complexity.World.Name == nil {
			break
		}

		return e.complexity.World.Name(childComplexity), true

	case "World.size":
		if e.complexity.World.Size == nil {
			break
		}

		return e.complexity.World.Size(childComplexity), true

	case "World.stars":
		if e.complexity.World.Stars == nil {
			break
		}

		return e.complexity.World.Stars(childComplexity), true

	case "World.technologyLevel":
		if e.complexity.World.TechnologyLevel == nil {
			break
		}

		return e.complexity.World.TechnologyLevel(childComplexity), true

	case "World.type":
		if e.complexity.World.Type == nil {
			break
		}

		return e.complexity.World.Type(childComplexity), true

	case "World.universe":
		if e.complexity.World.Universe == nil {
			break
		}

		return e.complexity.World.Universe(childComplexity), true

	case "World.updatedAt":
		if e.complexity.World.UpdatedAt == nil {
			break
		}

		return e.complexity.World.UpdatedAt(childComplexity), true

	case "WorldEvent.endDate":
		if e.complexity.WorldEvent.EndDate == nil {
			break
		}

		return e.complexity.WorldEvent.EndDate(childComplexity), true

	case "WorldEvent.event":
		if e.complexity.WorldEvent.Event == nil {
			break
		}

		return e.complexity.WorldEvent.Event(childComplexity), true

	case "WorldEvent.id":
		if e.complexity.WorldEvent.ID == nil {
			break
		}

		return e.complexity.WorldEvent.ID(childComplexity), true

	case "WorldEvent.relation":
		if e.complexity.WorldEvent.Relation == nil {
			break
		}

		return e.complexity.WorldEvent.Relation(childComplexity), true

	case "WorldEvent.startDate":
		if e.complexity.WorldEvent.StartDate == nil {
			break
		}

		return e.complexity.WorldEvent.StartDate(childComplexity), true

	case "WorldEvent.world":
		if e.complexity.WorldEvent.World == nil {
			break
		}

		return e.complexity.WorldEvent.World(childComplexity), true

	case "WorldWorld.endDate":
		if e.complexity.WorldWorld.EndDate == nil {
			break
		}

		return e.complexity.WorldWorld.EndDate(childComplexity), true

	case "WorldWorld.id":
		if e.complexity.WorldWorld.ID == nil {
			break
		}

		return e.complexity.WorldWorld.ID(childComplexity), true

	case "WorldWorld.relation":
		if e.complexity.WorldWorld.Relation == nil {
			break
		}

		return e.complexity.WorldWorld.Relation(childComplexity), true

	case "WorldWorld.startDate":
		if e.complexity.WorldWorld.StartDate == nil {
			break
		}

		return e.complexity.WorldWorld.StartDate(childComplexity), true

	case "WorldWorld.world":
		if e.complexity.WorldWorld.World == nil {
			break
		}

		return e.complexity.WorldWorld.World(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateCharacterInput,
		ec.unmarshalInputCreateCreatureInput,
		ec.unmarshalInputCreateEventInput,
		ec.unmarshalInputCreateFactionInput,
		ec.unmarshalInputCreateItemInput,
		ec.unmarshalInputCreateLocationInput,
		ec.unmarshalInputCreateUniverseInput,
		ec.unmarshalInputCreateWorldInput,
		ec.unmarshalInputUpdateCharacterInput,
		ec.unmarshalInputUpdateCreatureInput,
		ec.unmarshalInputUpdateEventInput,
		ec.unmarshalInputUpdateFactionInput,
		ec.unmarshalInputUpdateItemInput,
		ec.unmarshalInputUpdateLocationInput,
		ec.unmarshalInputUpdateUniverseInput,
		ec.unmarshalInputUpdateWorldInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../graphql/Character/enum.graphqls", Input: `"""
Representa el nivel de relación entre dos personajes.
Incluye relaciones de amistad, rivalidad, mentoría, familia y jerarquía profesional.
"""
enum CharacterRelationLevel {
    # Relaciones de enemistad y rivalidad
    """
    Relación de enemistad extrema o de larga duración. Oponentes acérrimos con un conflicto prolongado.
    """
    ARCHENEMY

    """
    Oposición activa con conflictos frecuentes y hostilidad evidente.
    """
    ENEMY

    """
    Competencia recurrente sin llegar al odio extremo. Puede incluir rivalidad deportiva, profesional o personal.
    """
    RIVAL

    # Relaciones neutrales y superficiales
    """
    Relación sin una inclinación fuerte. Desconocidos o con interacciones superficiales sin impacto significativo.
    """
    NEUTRAL

    """
    Conocidos casuales, sin una conexión profunda. Se han cruzado en el pasado pero no tienen una relación establecida.
    """
    ACQUAINTANCE

    # Relaciones de amistad
    """
    Amistad cercana o alianza de confianza. Relación basada en apoyo mutuo y cooperación.
    """
    FRIEND

    """
    Amistad extremadamente fuerte, cercana al concepto de familia. Puede incluir lazos de hermandad sin ser de sangre.
    """
    BEST_FRIEND

    # Relaciones de mentoría y aprendizaje
    """
    Relación maestro-alumno o de enseñanza. Un personaje guía al otro en su desarrollo personal o profesional.
    """
    MENTOR

    """
    Recíproco del mentor: el protegido o aprendiz que recibe conocimiento, entrenamiento o apoyo de un mentor.
    """
    PROTEGE

    # Relaciones románticas y familiares
    """
    Relación amorosa en cualquier etapa inicial. Puede ser un interés romántico, enamoramiento o relación incipiente.
    """
    ROMANTIC

    """
    Relación romántica establecida. Puede incluir parejas casadas, comprometidas o con un vínculo consolidado.
    """
    PARTNER

    """
    Relación de parentesco, ya sea por sangre o adopción. Incluye lazos familiares directos o extendidos.
    """
    FAMILY

    """
    Amor no correspondido. Un personaje siente afecto por otro, pero este no le responde de la misma manera.
    """
    UNREQUITED

    """
    Amistad rota por eventos pasados. Dos personajes que fueron amigos pero cuya relación se ha deteriorado o ha terminado.
    """
    FORMER_FRIEND

    """
    Relación amorosa que terminó, pero cuyo impacto sigue presente en la historia o en la dinámica entre personajes.
    """
    FORMER_LOVER

    # Relaciones de jerarquía y organización
    """
    Asociación basada en un interés común, sin necesidad de amistad. Puede incluir alianzas temporales o estratégicas.
    """
    ALLY

    """
    Miembros de la misma organización, grupo o facción. Comparten una afiliación en un contexto militar, político, religioso o social.
    """
    FACTION_MEMBER

    """
    Relación de autoridad en la que un personaje tiene poder sobre otro. Puede representar jefe-subordinado o líder-miembro.
    """
    SUPERIOR

    """
    Relación inversa de autoridad: el personaje es subordinado o está bajo las órdenes de otro.
    """
    SUBORDINATE
}

"""
Representa relaciones familiares entre personajes, incluyendo parentescos directos e indirectos.
Distingue entre lazos de sangre, adopción y vínculos familiares extendidos.
"""
enum FamilyRelation {
    # Relación familiar directa

    """
    Padre o madre biológico/a del personaje.
    """
    PARENT

    """
    Hijo o hija biológico/a del personaje.
    """
    CHILD

    """
    Hermano o hermana del personaje, comparten al menos uno de los padres.
    """
    SIBLING

    """
    Abuelo o abuela del personaje, ascendencia dos generaciones atrás.
    """
    GRANDPARENT

    """
    Nieto o nieta del personaje, descendencia dos generaciones adelante.
    """
    GRANDCHILD

    # Familia extendida

    """
    Tío o tía del personaje, hermano/a del padre o la madre.
    """
    UNCLE_AUNT

    """
    Sobrino o sobrina del personaje, hijo/a de un hermano o hermana.
    """
    NEPHEW_NIECE

    """
    Primo o prima del personaje, hijo/a de los tíos o tías.
    """
    COUSIN

    # Relaciones conyugales

    """
    Esposo o esposa del personaje, relación legalmente reconocida o establecida románticamente.
    """
    SPOUSE

    """
    Exesposo/a del personaje. Relación con lazos matrimoniales que han sido disueltos.
    """
    EX_SPOUSE

    # Relaciones familiares no biológicas

    """
    Padrastro o madrastra del personaje. Relación por matrimonio con uno de los padres del personaje.
    """
    STEP_PARENT

    """
    Hijastro o hijastra del personaje. Hijo/a de su pareja en una relación previa.
    """
    STEP_CHILD

    """
    Medio hermano/a del personaje. Comparten solo uno de los padres.
    """
    HALF_SIBLING

    """
    Padre o madre adoptivo/a del personaje. Relación establecida legalmente sin lazo de sangre.
    """
    ADOPTIVE_PARENT

    """
    Hijo o hija adoptivo/a del personaje. Relación establecida legalmente sin lazo de sangre.
    """
    ADOPTIVE_CHILD

    # Relaciones de tutela

    """
    Tutor legal del personaje. Puede ser una figura parental, un mentor o protector.
    """
    GUARDIAN

    """
    Menor bajo tutela legal de otro personaje. No es necesariamente hijo adoptivo.
    """
    WARD
}

"""
Define el tipo de relación que un personaje puede tener con una criatura.
Estos valores se usan para modelar interacciones en el mundo ficticio.
"""
enum CharacterCreatureRelation {
    # Relaciones de propiedad y domesticación

    """
    El personaje es dueño de la criatura (mascota, montura, familiar).
    """
    OWNER

    """
    El personaje está intentando domesticar la criatura, pero aún no tiene éxito.
    """
    TAME_ATTEMPT

    """
    La criatura ha sido domesticada con éxito y obedece al personaje.
    """
    TAMED

    """
    La criatura protege o vigila al personaje (lobo guardián, gólem, etc.).
    """
    GUARDIAN

    # Relaciones de combate y caza

    """
    La criatura y el personaje son compañeros, pero sin una relación de propiedad.
    """
    COMPANION

    """
    El personaje y la criatura cazan juntos como aliados.
    """
    HUNTING_PARTNER

    """
    El personaje caza activamente a la criatura.
    """
    HUNTED

    """
    La criatura es hostil hacia el personaje y lo ataca al verlo.
    """
    ENEMY

    # Relaciones mágicas y sobrenaturales

    """
    El personaje venera a la criatura como una entidad divina.
    """
    WORSHIPS

    """
    La criatura es una manifestación de un dios o entidad superior.
    """
    DEITY_AVATAR

    """
    El personaje invocó a la criatura con un ritual (demonios, elementales, etc.).
    """
    SUMMONED

    """
    La criatura y el personaje están fusionados por un vínculo sobrenatural.
    """
    FUSED

    """
    La criatura fue creada a partir de una maldición lanzada por el personaje.
    """
    CURSED

    # Relaciones de utilidad y transporte

    """
    El personaje monta a la criatura como un medio de transporte (caballo, dragón).
    """
    RIDES

    """
    La criatura es un experimento creado por el personaje (quimera, mutación).
    """
    EXPERIMENT
}

"""
Define la relación que un personaje puede tener con un evento en el mundo ficticio.
Incluye participación directa, testimonio, organización, influencia y otras interacciones posibles.
"""
enum CharacterEventRelation {
    # Roles activos en el evento

    """
    El personaje fue el principal responsable del evento. Puede ser el iniciador, el líder o el causante del suceso.
    """
    INITIATOR

    """
    El personaje participó activamente en el evento como protagonista o actor clave.
    """
    PARTICIPANT

    """
    El personaje organizó el evento, pero no participó directamente en su desarrollo.
    """
    ORGANIZER

    # Roles pasivos o circunstanciales

    """
    El personaje fue testigo del evento sin intervenir activamente.
    """
    WITNESS

    """
    El personaje fue afectado por el evento, ya sea de manera positiva o negativa, pero sin participación directa.
    """
    AFFECTED

    """
    El personaje influyó en el evento de alguna manera indirecta, sin estar presente.
    """
    INFLUENCER

    # Respuestas al evento

    """
    El personaje intentó detener el evento o evitar que sucediera.
    """
    OPPOSER

    """
    El personaje investigó o estudió el evento después de que ocurriera, sin haber estado presente en el momento.
    """
    INVESTIGATOR

    """
    El personaje se enteró del evento y lo difundió a otras personas.
    """
    REPORTER

    # Otras interacciones

    """
    El personaje utilizó el evento como una oportunidad para su propio beneficio (económico, político, militar, etc.).
    """
    OPPORTUNIST

    """
    El personaje sufrió una pérdida o fue una víctima directa del evento.
    """
    VICTIM

    """
    El personaje fue rescatado durante el evento o dependió de la ayuda de otros para sobrevivir.
    """
    RESCUED

    """
    El personaje rescató a otras personas o ayudó a mitigar los efectos del evento.
    """
    SAVIOR

    """
    El personaje creó una obra basada en el evento (arte, literatura, música, etc.).
    """
    CHRONICLER
}

"""
Define la relación entre un personaje y una facción.
Incluye afiliaciones, liderazgos, enemistades e interacciones indirectas.
"""
enum CharacterFactionRelation {
    # Afiliaciones oficiales

    """
    El personaje es el líder absoluto de la facción (rey, emperador, comandante supremo).
    """
    LEADER

    """
    El personaje es un miembro activo de la facción.
    """
    MEMBER

    """
    El personaje es un ex-miembro que dejó la facción de manera voluntaria o fue expulsado.
    """
    FORMER_MEMBER

    # Relaciones externas

    """
    El personaje es un aliado de la facción sin ser miembro oficial.
    """
    ALLY

    """
    El personaje es un enemigo de la facción y se opone a sus intereses.
    """
    ENEMY

    """
    El personaje financia o apoya a la facción sin ser miembro activo.
    """
    SPONSOR

    """
    El personaje trabaja para la facción bajo contrato, sin lealtad directa.
    """
    MERCENARY

    # Interacciones estratégicas

    """
    El personaje ha sido capturado por la facción y está prisionero.
    """
    PRISONER

    """
    El personaje es un informante o espía dentro de la facción.
    """
    INFORMANT

    """
    El personaje está siendo manipulado por la facción sin su conocimiento.
    """
    PUPPET
}

"""
Define la relación entre un personaje y un ítem.
Puede representar posesión, uso, creación, destrucción o influencia del objeto en el personaje.
"""
enum CharacterItemRelation {
    # Relaciones de propiedad y uso
    """
    El personaje es el dueño actual del ítem.
    """
    OWNER

    """
    El personaje fue dueño del ítem, pero lo perdió o se deshizo de él.
    """
    FORMER_OWNER

    """
    El personaje usa activamente el ítem, aunque no sea el dueño.
    """
    USER

    # Relaciones de creación y destrucción
    """
    El personaje creó el ítem (forja, magia, ingeniería, etc.).
    """
    CREATOR

    """
    El personaje destruyó el ítem o fue responsable de su pérdida.
    """
    DESTROYER

    # Interacciones estratégicas
    """
    El personaje busca obtener el ítem por algún motivo.
    """
    SEEKER

    """
    El personaje protege el ítem y evita que caiga en malas manos.
    """
    GUARDIAN

    """
    El personaje está maldito o influenciado negativamente por el ítem.
    """
    CURSED

    """
    El personaje vendió, intercambió o regaló el ítem.
    """
    MERCHANT

    """
    El personaje investigó el ítem para conocer su origen y propiedades.
    """
    SCHOLAR
}

"""
Define la relación entre un personaje y una ubicación.
Puede representar origen, residencia, gobierno, exploración o conflicto con el lugar.
"""
enum CharacterLocationRelation {
    # Residencia y origen
    """
    El personaje nació en esta ubicación.
    """
    BIRTHPLACE

    """
    El personaje vive en esta ubicación de manera permanente.
    """
    RESIDENT

    # Control y gobierno
    """
    El personaje gobierna la ubicación o tiene autoridad sobre ella.
    """
    RULER

    # Exploración y viajes
    """
    El personaje pasó por la ubicación temporalmente.
    """
    VISITOR

    """
    El personaje exploró la ubicación en busca de conocimiento o recursos.
    """
    EXPLORER

    # Conflictos y castigos
    """
    El personaje fue exiliado de la ubicación y no puede regresar.
    """
    EXILED

    """
    El personaje está en la ubicación en contra de su voluntad (prisión, secuestro).
    """
    CAPTIVE

    """
    El personaje participó en una batalla que ocurrió en la ubicación.
    """
    BATTLEFIELD_PARTICIPANT

    """
    El personaje destruyó parte o toda la ubicación.
    """
    DESTROYER
}

"""
Define la relación entre un personaje y un mundo.
Puede representar ciudadanía, exploración, influencia o enemistad con el mundo.
"""
enum CharacterWorldRelation {
    # Pertenencia y origen
    """
    El personaje nació en este mundo.
    """
    NATIVE

    """
    El personaje es un residente actual del mundo, pero no necesariamente nativo.
    """
    RESIDENT

    """
    El personaje es un extranjero que llegó desde otro mundo.
    """
    OUTSIDER

    # Influencia sobre el mundo
    """
    El personaje tiene una influencia significativa en la política, cultura o historia del mundo.
    """
    INFLUENCER

    """
    El personaje busca activamente proteger el mundo o mantener su equilibrio.
    """
    GUARDIAN

    """
    El personaje es un conquistador que busca dominar el mundo.
    """
    CONQUEROR

    """
    El personaje es un destructor que quiere traer caos o aniquilación al mundo.
    """
    DESTROYER

    # Exploración y descubrimiento
    """
    El personaje explora el mundo en busca de conocimiento o aventuras.
    """
    EXPLORER

    """
    El personaje fue exiliado del mundo y no puede regresar.
    """
    EXILED

    """
    El personaje fue convocado a este mundo por medios sobrenaturales (magia, rituales, etc.).
    """
    SUMMONED
}
`, BuiltIn: false},
	{Name: "../../../graphql/Character/input.graphqls", Input: `"""
Estructura para crear un nuevo personaje dentro de un mundo.
"""
input CreateCharacterInput {
    """
    ID del mundo al que pertenece el personaje.
    """
    worldId: ID!

    """
    Nombre del personaje.
    """
    name: String!

    """
    Descripción del personaje, incluyendo trasfondo o detalles relevantes.
    """
    description: String!

    """
    Tipo de entidad, útil para clasificar personajes en el sistema.
    """
    type: String!

    # Atributos físicos y estado
    """
    Fecha de nacimiento del personaje en formato ISO 8601 (YYYY-MM-DD).
    """
    birthDate: String!

    """
    Altura del personaje en metros (m).
    """
    height: Float!

    """
    Peso del personaje en kilogramos (kg).
    """
    weight: Float!

    """
    Indica si el personaje está vivo (true) o muerto (false).
    """
    isAlive: Boolean!

    """
    Indica si el personaje es un protagonista o figura central en la historia.
    """
    isMain: Boolean!

    """
    Alineamiento moral o ético del personaje (según el sistema usado).
    """
    alignment: Alignment
}

"""
Estructura para actualizar un personaje existente.
"""
input UpdateCharacterInput {
    """
    ID del personaje a modificar.
    """
    id: ID!

    """
    Nuevo nombre del personaje (opcional).
    """
    name: String

    """
    Nueva descripción del personaje (opcional).
    """
    description: String

    """
    Modificar el tipo del personaje (opcional).
    """
    type: String

    # Atributos físicos y estado
    """
    Modificar la fecha de nacimiento del personaje (opcional).
    """
    birthDate: String

    """
    Modificar la altura del personaje (opcional).
    """
    height: Float

    """
    Modificar el peso del personaje (opcional).
    """
    weight: Float

    """
    Modificar si el personaje está vivo o muerto (opcional).
    """
    isAlive: Boolean

    """
    Modificar si el personaje es un protagonista o no (opcional).
    """
    isMain: Boolean

    """
    Modificar el alineamiento del personaje (opcional).
    """
    alignment: Alignment
}
`, BuiltIn: false},
	{Name: "../../../graphql/Character/type.graphqls", Input: `"""
Representa un personaje en el mundo ficticio.
Incluye datos generales, atributos físicos, estado de vida y relaciones con otras entidades.
"""
type Character implements Entity {
    # Identificación y metadatos
    """
    Identificador único del personaje.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creación del personaje en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de última actualización del personaje en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Información general
    """
    Nombre del personaje.
    """
    name: String!

    """
    Descripción del personaje, incluyendo trasfondo o detalles relevantes.
    """
    description: String!

    """
    Tipo de entidad, útil para clasificar personajes en el sistema.
    """
    type: String!

    # Atributos físicos y estado
    """
    Fecha de nacimiento del personaje en formato ISO 8601 (YYYY-MM-DD).
    """
    birthDate: String!

    """
    Altura del personaje en metros (m).
    """
    height: Float!

    """
    Peso del personaje en kilogramos (kg).
    """
    weight: Float!

    """
    Indica si el personaje está vivo (true) o muerto (false).
    """
    isAlive: Boolean!

    """
    Indica si el personaje es un protagonista o figura central en la historia.
    """
    isMain: Boolean!

    """
    Alineamiento moral o ético del personaje (según el sistema usado).
    """
    alignment: Alignment

    # Relaciones con otras entidades
    """
    Lista de relaciones con otros personajes, incluyendo amistad, enemistad o parentesco.
    """
    characters: [CharacterCharacter!]!

    """
    Lista de relaciones del personaje con criaturas, incluyendo domesticación o conflicto.
    """
    creatures: [CharacterCreature!]!

    """
    Lista de relaciones del personaje con facciones, como afiliaciones o enemistades.
    """
    factions: [CharacterFaction!]!

    """
    Lista de relaciones del personaje con eventos, como participación o influencia.
    """
    events: [CharacterEvent!]!

    """
    Lista de relaciones del personaje con ítems, como posesión, uso o creación.
    """
    items: [CharacterItem!]!

    """
    Lista de relaciones del personaje con ubicaciones, como residencia o exploración.
    """
    locations: [CharacterLocation!]!

    """
    Lista de relaciones del personaje con mundos, como origen, exilio o conquista.
    """
    worlds: [CharacterWorld!]!
}

"""
Define la relación entre dos personajes.
Puede incluir amistad, enemistad, parentesco y otros vínculos narrativos.
"""
type CharacterCharacter {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje con el que se establece la relación.
    """
    character: Character!

    """
    Nivel de relación entre los personajes, desde amistad hasta enemistad extrema.
    """
    characterRelationLevel: CharacterRelationLevel!

    """
    Relación familiar si existe un vínculo de parentesco (opcional).
    """
    familyRelation: FamilyRelation

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Representa la relación entre un personaje y una criatura.
Puede incluir domesticación, caza, invocación y otros vínculos narrativos.
"""
type CharacterCreature {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relación con la criatura.
    """
    character: Character!

    """
    La criatura con la que el personaje está relacionado.
    """
    creature: Creature!

    """
    Tipo de relación entre el personaje y la criatura (dueño, enemigo, protector, etc.).
    """
    relation: CharacterCreatureRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre un personaje y una facción.
Incluye afiliaciones, liderazgos, enemistades e interacciones indirectas.
"""
type CharacterFaction {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relación con la facción.
    """
    character: Character!

    """
    La facción con la que el personaje tiene una relación.
    """
    faction: Faction!

    """
    Tipo de relación entre el personaje y la facción (miembro, líder, enemigo, etc.).
    """
    relation: CharacterFactionRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre un personaje y un evento.
Puede representar participación directa, testimonio, organización o influencia.
"""
type CharacterEvent {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relación con el evento.
    """
    character: Character!

    """
    El evento con el que el personaje tiene una relación.
    """
    event: Event!

    """
    Tipo de relación entre el personaje y el evento (participante, organizador, testigo, etc.).
    """
    relation: CharacterEventRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre un personaje y un ítem.
Puede representar posesión, uso, creación, destrucción o influencia del objeto en el personaje.
"""
type CharacterItem {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relación con el ítem.
    """
    character: Character!

    """
    El ítem con el que el personaje tiene una relación.
    """
    item: Item!

    """
    Tipo de relación entre el personaje y el ítem (dueño, usuario, creador, etc.).
    """
    relation: CharacterItemRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre un personaje y una ubicación.
Puede representar origen, residencia, gobierno, exploración o conflicto con el lugar.
"""
type CharacterLocation {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relación con la ubicación.
    """
    character: Character!

    """
    La ubicación con la que el personaje tiene una relación.
    """
    location: Location!

    """
    Tipo de relación entre el personaje y la ubicación (residente, explorador, exiliado, etc.).
    """
    relation: CharacterLocationRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre un personaje y un mundo.
Puede representar ciudadanía, exploración, influencia o enemistad con el mundo.
"""
type CharacterWorld {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El personaje que tiene la relación con el mundo.
    """
    character: Character!

    """
    El mundo con el que el personaje tiene una relación.
    """
    world: World!

    """
    Tipo de relación entre el personaje y el mundo (nativo, explorador, conquistador, etc.).
    """
    relation: CharacterWorldRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/Creature/enum.graphqls", Input: `"""
Define la relación entre dos criaturas.
Puede representar jerarquía, rivalidad, simbiosis y otras interacciones naturales o mágicas.
"""
enum CreatureCreatureRelation {
    # Relaciones de jerarquía y grupo
    """
    Una criatura es la líder de la otra dentro de una manada o sociedad.
    """
    LEADER

    """
    Las criaturas forman parte de la misma manada, colonia o sociedad.
    """
    PACK_MEMBER

    """
    Las criaturas tienen una relación parental (madre/padre e hijo).
    """
    PARENT

    """
    Las criaturas son hermanos de la misma especie o camada.
    """
    SIBLING

    # Relaciones de cooperación y simbiosis
    """
    Las criaturas tienen una relación simbiótica en la que ambas se benefician.
    """
    SYMBIOTIC

    """
    Las criaturas tienen una relación de mutualismo, sin dependencia extrema.
    """
    MUTUALISTIC

    """
    Una criatura protege a la otra de forma voluntaria o instintiva.
    """
    PROTECTOR

    # Relaciones de rivalidad y conflicto
    """
    Las criaturas compiten por territorio, alimento o dominio.
    """
    RIVAL

    """
    Las criaturas se consideran enemigas y se atacan mutuamente.
    """
    ENEMY

    """
    Una criatura es depredadora y caza a la otra como parte de su dieta.
    """
    PREDATOR

    """
    Una criatura es presa natural de la otra.
    """
    PREY

    # Relaciones artificiales o mágicas
    """
    Una criatura fue creada artificialmente a partir de la otra (clonación, magia, experimentos).
    """
    CREATED_FROM

    """
    Las criaturas están conectadas por una maldición, pacto o lazo sobrenatural.
    """
    CURSED
}

"""
Define la relación entre una criatura y una facción.
Puede representar uso militar, veneración, domesticación o conflicto.
"""
enum CreatureFactionRelation {
    # Relaciones de pertenencia y control
    """
    La criatura pertenece a la facción como una mascota, montura o bestia domesticada.
    """
    ASSET

    """
    La criatura es utilizada como arma de guerra o para defensa militar.
    """
    WAR_BEAST

    """
    La criatura es venerada como un símbolo sagrado o deidad.
    """
    WORSHIPPED

    """
    La criatura fue capturada y está bajo el control de la facción.
    """
    CAPTURED

    # Relaciones de conflicto
    """
    La criatura es considerada una amenaza y la facción busca eliminarla.
    """
    HUNTED

    """
    La criatura ha sido una enemiga recurrente de la facción.
    """
    ENEMY

    """
    La criatura es vista como un símbolo de mala fortuna o castigo divino.
    """
    OMEN

    # Relaciones de cooperación
    """
    La criatura actúa como aliada de la facción sin estar controlada.
    """
    ALLY

    """
    La criatura es utilizada como un experimento dentro de la facción.
    """
    EXPERIMENT
}

"""
Define la relación entre una criatura y un evento.
Puede representar participación en desastres, batallas, invocaciones y otros sucesos importantes.
"""
enum CreatureEventRelation {
    # Participación activa
    """
    La criatura inició o causó el evento (ej. plaga, destrucción, guerra).
    """
    INITIATOR

    """
    La criatura participó en el evento, pero no fue la causa principal.
    """
    PARTICIPANT

    """
    La criatura fue invocada o traída al evento de forma mágica o tecnológica.
    """
    SUMMONED

    # Relaciones pasivas o circunstanciales
    """
    La criatura fue testigo del evento sin intervenir directamente.
    """
    WITNESS

    """
    El evento afectó a la criatura, alterando su estado o comportamiento.
    """
    AFFECTED

    # Relaciones de respuesta y resolución
    """
    La criatura intentó detener el evento o proteger a otros de sus efectos.
    """
    DEFENDER

    """
    La criatura fue rescatada durante el evento (ej. incendio, terremoto).
    """
    RESCUED

    """
    La criatura rescató a otros o ayudó a mitigar los efectos del evento.
    """
    SAVIOR

    # Relaciones simbólicas o narrativas
    """
    El evento fue interpretado como una profecía relacionada con la criatura.
    """
    OMEN

    """
    El evento se originó como una maldición o consecuencia de la criatura.
    """
    CURSED
}

"""
Define la relación entre una criatura y una ubicación.
Puede representar su hábitat, migraciones, dominio territorial y más.
"""
enum CreatureLocationRelation {
    # Hábitat y residencia
    """
    La criatura tiene su hábitat natural en esta ubicación.
    """
    NATIVE

    """
    La criatura reside en esta ubicación, pero no es su hábitat original.
    """
    RESIDENT

    """
    La criatura migró a esta ubicación desde otro lugar.
    """
    MIGRATED

    # Control y territorio
    """
    La criatura reclama esta ubicación como su dominio y la protege.
    """
    TERRITORIAL

    """
    La criatura está atrapada en esta ubicación contra su voluntad.
    """
    TRAPPED

    """
    La criatura fue exiliada de esta ubicación y no puede regresar.
    """
    EXILED

    # Relaciones con la ubicación
    """
    La criatura es una amenaza para la ubicación y causa destrucción.
    """
    THREAT

    """
    La criatura protege la ubicación o mantiene su equilibrio ecológico.
    """
    GUARDIAN

    """
    La criatura es un símbolo de la ubicación, ya sea mitológico o cultural.
    """
    SYMBOL
}

"""
Define la relación entre una criatura y un mundo.
Puede representar origen, influencia interdimensional, exilio y más.
"""
enum CreatureWorldRelation {
    # Origen y pertenencia
    """
    La criatura es nativa de este mundo.
    """
    NATIVE

    """
    La criatura no pertenece a este mundo y proviene de otro plano o dimensión.
    """
    OUTSIDER

    """
    La criatura es el resultado de una mutación o adaptación a este mundo.
    """
    ADAPTED

    # Relaciones de influencia
    """
    La criatura tiene un impacto significativo en la ecología o historia del mundo.
    """
    INFLUENCER

    """
    La criatura fue convocada a este mundo a través de medios sobrenaturales.
    """
    SUMMONED

    """
    La criatura protege el mundo o mantiene su equilibrio.
    """
    GUARDIAN

    # Relaciones de conflicto y destrucción
    """
    La criatura amenaza la existencia del mundo.
    """
    DESTROYER

    """
    La criatura fue exiliada del mundo y no puede regresar.
    """
    EXILED
}
`, BuiltIn: false},
	{Name: "../../../graphql/Creature/input.graphqls", Input: `"""
Estructura para crear una nueva criatura dentro de un mundo.
"""
input CreateCreatureInput {
    """
    ID del mundo al que pertenece la criatura.
    """
    worldId: ID!

    """
    Nombre de la criatura.
    """
    name: String!

    """
    Descripción detallada de la criatura, incluyendo características únicas y comportamiento.
    """
    description: String!

    """
    Tipo de entidad, útil para clasificar criaturas en el sistema.
    """
    type: String!

    """
    Especie o categoría de la criatura (dragón, gólem, quimera, etc.).
    """
    species: String!

    """
    Nivel de inteligencia de la criatura (bestia, sapiente, semisapiente, etc.).
    """
    intelligenceLevel: String!

    # Atributos físicos y estado
    """
    Altura de la criatura en metros (m).
    """
    height: Float!

    """
    Peso de la criatura en kilogramos (kg).
    """
    weight: Float!

    """
    Fecha de nacimiento de la criatura en formato ISO 8601 (YYYY-MM-DD).
    """
    birthDate: String!

    """
    Indica si la criatura está viva (true) o muerta (false).
    """
    isAlive: Boolean!

    """
    Esperanza de vida aproximada de la criatura en años.
    """
    lifespan: Int

    """
    Indica si la criatura es única o pertenece a una especie con múltiples individuos.
    """
    isUnique: Boolean!

    # Hábitat y comportamiento
    """
    Ambiente donde la criatura vive (bosques, montañas, océanos, etc.).
    """
    habitat: String!

    """
    Comportamiento de la criatura (pacífica, territorial, agresiva, etc.).
    """
    behavior: String!

    """
    Dieta de la criatura (carnívora, herbívora, omnívora, etc.).
    """
    diet: String!

    """
    Lista de habilidades especiales que posee la criatura (aliento de fuego, regeneración, telepatía, etc.).
    """
    abilities: [String!]!
}

"""
Estructura para actualizar una criatura existente.
"""
input UpdateCreatureInput {
    """
    ID de la criatura a modificar.
    """
    id: ID!

    """
    Nuevo nombre de la criatura (opcional).
    """
    name: String

    """
    Nueva descripción de la criatura (opcional).
    """
    description: String

    """
    Modificar el tipo de la criatura (opcional).
    """
    type: String

    """
    Modificar la especie de la criatura (opcional).
    """
    species: String

    """
    Modificar el nivel de inteligencia de la criatura (opcional).
    """
    intelligenceLevel: String

    # Atributos físicos y estado
    """
    Modificar la altura de la criatura (opcional).
    """
    height: Float

    """
    Modificar el peso de la criatura (opcional).
    """
    weight: Float

    """
    Modificar la fecha de nacimiento de la criatura (opcional).
    """
    birthDate: String

    """
    Modificar si la criatura está viva o muerta (opcional).
    """
    isAlive: Boolean

    """
    Modificar la esperanza de vida de la criatura (opcional).
    """
    lifespan: Int

    """
    Modificar si la criatura es única o no (opcional).
    """
    isUnique: Boolean

    # Hábitat y comportamiento
    """
    Modificar el hábitat de la criatura (opcional).
    """
    habitat: String

    """
    Modificar el comportamiento de la criatura (opcional).
    """
    behavior: String

    """
    Modificar la dieta de la criatura (opcional).
    """
    diet: String

    """
    Modificar las habilidades de la criatura (opcional).
    """
    abilities: [String!]
}
`, BuiltIn: false},
	{Name: "../../../graphql/Creature/type.graphqls", Input: `"""
Representa una criatura dentro del mundo ficticio.
Incluye datos generales, atributos físicos, hábitat y relaciones con otras entidades.
"""
type Creature implements Entity {
    # Identificación y metadatos
    """
    Identificador único de la criatura.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creación de la criatura en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de última actualización de la criatura en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Información general
    """
    Nombre de la criatura.
    """
    name: String!

    """
    Descripción de la criatura, incluyendo características únicas y comportamiento.
    """
    description: String!

    """
    Tipo de entidad, útil para clasificar criaturas en el sistema.
    """
    type: String!

    """
    Especie o categoría de la criatura (dragón, gólem, quimera, etc.).
    """
    species: String!

    """
    Nivel de inteligencia de la criatura (bestia, sapiente, semisapiente, etc.).
    """
    intelligenceLevel: String!

    # Atributos físicos y estado
    """
    Altura de la criatura en metros (m).
    """
    height: Float!

    """
    Peso de la criatura en kilogramos (kg).
    """
    weight: Float!

    # Atributos físicos y estado
    """
    Fecha de nacimiento de la criatura en formato ISO 8601 (YYYY-MM-DD).
    """
    birthDate: String!

    """
    Indica si la criatura está viva (true) o muerta (false).
    """
    isAlive: Boolean!

    """
    Esperanza de vida aproximada de la criatura en años.
    """
    lifespan: Int

    """
    Indica si la criatura es única o pertenece a una especie con múltiples individuos.
    """
    isUnique: Boolean!

    # Hábitat y comportamiento
    """
    Ambiente donde la criatura vive (bosques, montañas, océanos, etc.).
    """
    habitat: String!

    """
    Comportamiento de la criatura (pacífica, territorial, agresiva, etc.).
    """
    behavior: String!

    """
    Dieta de la criatura (carnívora, herbívora, omnívora, etc.).
    """
    diet: String!

    """
    Lista de habilidades especiales que posee la criatura (aliento de fuego, regeneración, telepatía, etc.).
    """
    abilities: [String!]!

    # Relaciones con otras entidades
    """
    Lista de relaciones de la criatura con personajes, incluyendo domesticación o conflicto.
    """
    characters: [CharacterCreature!]!

    """
    Lista de relaciones de la criatura con otras criaturas, incluyendo jerarquías o rivalidades.
    """
    creatures: [CreatureCreature!]!

    """
    Lista de relaciones de la criatura con facciones, como uso militar o veneración.
    """
    factions: [CreatureFaction!]!

    """
    Lista de relaciones de la criatura con eventos, como participación en batallas o desastres naturales.
    """
    events: [CreatureEvent!]!

    """
    Lista de relaciones de la criatura con ubicaciones, como hábitat o migraciones.
    """
    locations: [CreatureLocation!]!

    """
    Lista de relaciones de la criatura con mundos, como su origen o influencia interdimensional.
    """
    worlds: [CreatureWorld!]!
}

"""
Define la relación entre dos criaturas.
Puede representar jerarquía, rivalidad, simbiosis y otras interacciones naturales o mágicas.
"""
type CreatureCreature {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La criatura con la que se establece la relación.
    """
    creature: Creature!

    """
    Tipo de relación entre ambas criaturas (jerárquica, depredador-presa, simbiótica, etc.).
    """
    relation: CreatureCreatureRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre una criatura y una facción.
Puede representar uso militar, veneración, domesticación o conflicto.
"""
type CreatureFaction {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La criatura con la que la facción tiene una relación.
    """
    creature: Creature!

    """
    La facción con la que la criatura tiene una relación.
    """
    faction: Faction!

    """
    Tipo de relación entre la criatura y la facción (mascota, bestia de guerra, símbolo sagrado, etc.).
    """
    relation: CreatureFactionRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre una criatura y un evento.
Puede representar participación en desastres, batallas, invocaciones y otros sucesos importantes.
"""
type CreatureEvent {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La criatura con la que el evento tiene una relación.
    """
    creature: Creature!

    """
    El evento con el que la criatura tiene una relación.
    """
    event: Event!

    """
    Tipo de relación entre la criatura y el evento (iniciador, participante, testigo, etc.).
    """
    relation: CreatureEventRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre una criatura y una ubicación.
Puede representar su hábitat, migraciones, dominio territorial y más.
"""
type CreatureLocation {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La criatura con la que la ubicación tiene una relación.
    """
    creature: Creature!

    """
    La ubicación con la que la criatura tiene una relación.
    """
    location: Location!

    """
    Tipo de relación entre la criatura y la ubicación (hábitat, migración, dominio territorial, etc.).
    """
    relation: CreatureLocationRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre una criatura y un mundo.
Puede representar origen, influencia interdimensional, exilio y más.
"""
type CreatureWorld {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La criatura con la que el mundo tiene una relación.
    """
    creature: Creature!

    """
    El mundo con el que la criatura tiene una relación.
    """
    world: World!

    """
    Tipo de relación entre la criatura y el mundo (nativa, invocada, exiliada, etc.).
    """
    relation: CreatureWorldRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/enum.graphqls", Input: `enum Alignment {
    LAWFUL_GOOD
    NEUTRAL_GOOD
    CHAOTIC_GOOD
    LAWFUL_NEUTRAL
    TRUE_NEUTRAL
    CHAOTIC_NEUTRAL
    LAWFUL_EVIL
    NEUTRAL_EVIL
    CHAOTIC_EVIL
}
`, BuiltIn: false},
	{Name: "../../../graphql/Event/enum.graphqls", Input: `"""
Clasifica los eventos según su naturaleza.
Puede representar batallas, descubrimientos, rituales, catástrofes y otros sucesos.
"""
enum EventType {
    # Eventos históricos y políticos
    """
    Un evento donde se produce un conflicto armado entre facciones o naciones.
    """
    BATTLE

    """
    Un tratado, negociación o evento diplomático entre entidades.
    """
    DIPLOMATIC_EVENT

    """
    Un golpe de estado, revolución o cambio radical de poder.
    """
    POLITICAL_UPHEAVAL

    # Eventos de exploración y descubrimiento
    """
    Un evento donde se descubre un nuevo territorio o lugar significativo.
    """
    DISCOVERY

    """
    Un evento donde se revela información crucial para la historia.
    """
    REVELATION

    # Eventos religiosos y mágicos
    """
    Un ritual realizado con propósitos religiosos, mágicos o esotéricos.
    """
    RITUAL

    """
    Una profecía que influye en la historia del mundo.
    """
    PROPHECY

    """
    Un evento donde una entidad divina interviene en el mundo.
    """
    DIVINE_INTERVENTION

    # Catástrofes y desastres
    """
    Un desastre natural (terremoto, erupción volcánica, tsunami, etc.).
    """
    NATURAL_DISASTER

    """
    Una pandemia o plaga que afecta a una región o población.
    """
    PLAGUE

    """
    Un evento en el que se produce un incendio de gran magnitud.
    """
    FIRE

    """
    Un evento en el que se genera caos y destrucción por causas no naturales.
    """
    CALAMITY

    # Eventos culturales y sociales
    """
    Un evento festivo, celebración o competencia deportiva.
    """
    FESTIVAL

    """
    Un evento académico, científico o reunión intelectual relevante.
    """
    SCHOLARLY_EVENT

    """
    Un juicio o evento de condena pública.
    """
    TRIAL

    # Eventos sobrenaturales o inexplicables
    """
    Un evento paranormal o que desafía la lógica del mundo.
    """
    SUPERNATURAL_EVENT

    """
    Un evento donde se abre un portal a otra dimensión o plano.
    """
    INTERDIMENSIONAL_RIFT
}

"""
Indica la importancia de un evento dentro de la historia.
Puede determinar su impacto en la narrativa del mundo.
"""
enum EventSignificance {
    """
    Un evento menor con impacto limitado en la historia general.
    """
    LOW

    """
    Un evento de relevancia media que afecta a una región o a un grupo importante de personajes.
    """
    MEDIUM

    """
    Un evento crucial que cambia la historia del mundo de forma permanente.
    """
    HIGH
}

"""
Define la relación entre dos eventos.
Puede representar causalidad, continuidad, interdependencia o influencia entre eventos.
"""
enum EventEvent {
    # Relaciones de causalidad
    """
    El evento A causó directamente el evento B.
    """
    CAUSE

    """
    El evento B ocurrió como consecuencia del evento A.
    """
    CONSEQUENCE

    """
    El evento B es una reacción directa al evento A (ej. represalia, respuesta diplomática).
    """
    RESPONSE

    # Relaciones de continuidad
    """
    El evento B es una continuación lógica del evento A.
    """
    CONTINUATION

    """
    El evento B es una repetición o iteración del evento A.
    """
    REOCCURRENCE

    """
    El evento B se produce en paralelo con el evento A, sin que uno cause al otro.
    """
    PARALLEL

    # Relaciones de influencia
    """
    El evento A inspiró o motivó el evento B sin ser su causa directa.
    """
    INSPIRATION

    """
    El evento A y el evento B están profetizados como parte de un mismo ciclo.
    """
    PROPHECY_LINK

    """
    Ambos eventos están mágicamente o sobrenaturalmente conectados.
    """
    SUPERNATURAL_LINK
}

"""
Indica la naturaleza del evento, diferenciando entre encuentros planificados, espontáneos o accidentales.
"""
enum EventNature {
    # Eventos planificados
    """
    El evento fue planeado con anticipación (ceremonias, batallas estratégicas, reuniones).
    """
    PLANNED

    """
    El evento ocurrió debido a una cita o reunión acordada entre personajes o facciones.
    """
    APPOINTMENT

    """
    El evento fue provocado intencionalmente por una de las partes (ataques, conspiraciones, emboscadas).
    """
    INTENTIONAL

    # Eventos espontáneos
    """
    El evento ocurrió sin planificación previa, como encuentros fortuitos o descubrimientos inesperados.
    """
    SPONTANEOUS

    """
    El evento fue un accidente sin intención detrás (explosión accidental, tropiezo, equivocación).
    """
    ACCIDENTAL

    """
    El evento ocurrió por coincidencia, sin intervención intencional de los involucrados.
    """
    COINCIDENCE

    # Eventos inevitables o forzados
    """
    El evento era inevitable por razones naturales, sobrenaturales o predestinadas (profecía cumplida, fin del mundo).
    """
    INEVITABLE

    """
    El evento ocurrió debido a fuerzas externas sin que los personajes tuvieran control sobre él (terremoto, tormenta, invasión repentina).
    """
    FORCED
}
`, BuiltIn: false},
	{Name: "../../../graphql/Event/input.graphqls", Input: `"""
Estructura para crear un nuevo evento dentro de un mundo.
"""
input CreateEventInput {
    """
    ID del mundo en el que ocurre el evento.
    """
    worldId: ID!

    """
    Nombre del evento.
    """
    name: String!

    """
    Descripción detallada del evento, incluyendo su impacto y contexto.
    """
    description: String!

    """
    Clasificación del evento según su naturaleza (batalla, descubrimiento, ritual, etc.).
    """
    type: EventType!

    """
    Indica la naturaleza del evento (planificado, accidental, fortuito, inevitable, etc.).
    """
    nature: EventNature!

    # Duración y recurrencia
    """
    Fecha de inicio del evento en formato ISO 8601 (YYYY-MM-DD).
    """
    startDate: String!

    """
    Fecha de finalización del evento en formato ISO 8601 (YYYY-MM-DD).
    """
    endDate: String!

    """
    Indica si el evento es recurrente (true) o único (false).
    """
    isRecurring: Boolean!

    """
    Importancia del evento dentro de la historia (baja, media, alta).
    """
    significance: EventSignificance!

    # Ubicación y contexto
    """
    Lista de ubicaciones donde ocurrió el evento.
    """
    locations: [ID!]!

    """
    Mundos en los que el evento tuvo un impacto.
    """
    worlds: [ID!]!
}

"""
Estructura para actualizar un evento existente.
"""
input UpdateEventInput {
    """
    ID del evento a modificar.
    """
    id: ID!

    """
    Nuevo nombre del evento (opcional).
    """
    name: String

    """
    Nueva descripción del evento (opcional).
    """
    description: String

    """
    Modificar la clasificación del evento (opcional).
    """
    type: EventType

    """
    Modificar la naturaleza del evento (opcional).
    """
    nature: EventNature

    # Duración y recurrencia
    """
    Modificar la fecha de inicio del evento (opcional).
    """
    startDate: String

    """
    Modificar la fecha de finalización del evento (opcional).
    """
    endDate: String

    """
    Modificar si el evento es recurrente (opcional).
    """
    isRecurring: Boolean

    """
    Modificar la importancia del evento en la historia (opcional).
    """
    significance: EventSignificance

    # Ubicación y contexto
    """
    Modificar la lista de ubicaciones del evento (opcional).
    """
    locations: [ID!]

    """
    Modificar la lista de mundos afectados por el evento (opcional).
    """
    worlds: [ID!]
}
`, BuiltIn: false},
	{Name: "../../../graphql/Event/type.graphqls", Input: `"""
Representa un evento dentro del mundo ficticio.
Incluye datos generales, ubicación, impacto y relaciones con otras entidades.
"""
type Event implements Entity {
    # Identificación y metadatos
    """
    Identificador único del evento.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creación del evento en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de última actualización del evento en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Información general
    """
    Nombre del evento.
    """
    name: String!

    """
    Descripción detallada del evento, incluyendo su impacto y contexto.
    """
    description: String!

    """
    Clasificación del evento según su naturaleza (batalla, descubrimiento, ritual, etc.).
    """
    type: EventType!

    """
    Indica la naturaleza del evento (planificado, accidental, fortuito, inevitable, etc.).
    """
    nature: EventNature!

    # Duración y recurrencia
    """
    Fecha de inicio del evento en formato ISO 8601 (YYYY-MM-DD).
    """
    startDate: String!

    """
    Fecha de finalización del evento en formato ISO 8601 (YYYY-MM-DD).
    """
    endDate: String!

    """
    Indica si el evento es recurrente (true) o único (false).
    """
    isRecurring: Boolean!

    """
    Importancia del evento dentro de la historia (baja, media, alta).
    """
    significance: EventSignificance!

    # Ubicación y contexto
    """
    Lista de ubicaciones donde ocurrió el evento.
    """
    locations: [LocationEvent!]!

    """
    Mundos en los que el evento tuvo un impacto.
    """
    worlds: [WorldEvent!]!

    # Relaciones con otras entidades
    """
    Lista de personajes involucrados en el evento.
    """
    characters: [CharacterEvent!]!

    """
    Lista de criaturas que participaron en el evento.
    """
    creatures: [CreatureEvent!]!

    """
    Lista de facciones relacionadas con el evento.
    """
    factions: [FactionEvent!]!

    """
    Lista de ítems asociados al evento (artefactos, armas, reliquias, etc.).
    """
    items: [ItemEvent!]!

    """
    Lista de eventos relacionados que ocurrieron antes, después o en paralelo.
    """
    relatedEvents: [EventEvent!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Faction/enum.graphqls", Input: `"""
Clasifica las facciones según su estructura y propósito.
Incluye gobiernos, cultos, gremios, clanes, ejércitos y más.
"""
enum FactionType {
    # Estructuras de gobierno y poder
    """
    Una nación o reino gobernado por una autoridad central.
    """
    NATION

    """
    Un estado independiente o ciudad-estado con gobierno propio.
    """
    CITY_STATE

    """
    Un imperio con dominio sobre múltiples territorios.
    """
    EMPIRE

    """
    Un grupo de resistencia o revolución contra el poder establecido.
    """
    REBELLION

    # Grupos ideológicos y religiosos
    """
    Una organización religiosa con dogmas y seguidores.
    """
    RELIGIOUS_ORDER

    """
    Un culto dedicado a una deidad, entidad o creencia específica.
    """
    CULT

    """
    Una hermandad secreta o sociedad con propósitos ocultos.
    """
    SECRET_SOCIETY

    # Organizaciones militares y mercenarias
    """
    Un ejército formal al servicio de un estado o gobernante.
    """
    MILITARY

    """
    Un grupo de mercenarios que ofrece servicios de combate o protección.
    """
    MERCENARY_COMPANY

    """
    Una banda de saqueadores, piratas o criminales organizados.
    """
    RAIDERS

    # Grupos económicos y comerciales
    """
    Un gremio de artesanos, comerciantes o profesionales.
    """
    GUILD

    """
    Una megacorporación o grupo empresarial con gran influencia económica.
    """
    MEGACORPORATION

    # Clanes y grupos tribales
    """
    Una tribu con una cultura propia y gobierno descentralizado.
    """
    TRIBE

    """
    Un clan familiar con influencia en una región o esfera de poder.
    """
    CLAN
}

"""
Indica el estado actual de la facción en la historia.
Puede estar activa, disuelta, exiliada, entre otros.
"""
enum FactionStatus {
    """
    La facción sigue operativa y tiene actividad en el mundo.
    """
    ACTIVE

    """
    La facción se ha disuelto y ya no existe como organización.
    """
    DISBANDED

    """
    La facción fue exiliada y ya no tiene territorio propio.
    """
    EXILED

    """
    La facción opera en secreto y no es reconocida públicamente.
    """
    UNDERGROUND

    """
    La facción está en decadencia y perdiendo influencia.
    """
    DECLINING

    """
    La facción está en auge y expandiendo su poder.
    """
    ASCENDING
}

"""
Indica el nivel de influencia de la facción en el mundo o sociedad.
Determina su relevancia histórica y social.
"""
enum FactionInfluence {
    """
    Facción menor con presencia local o influencia limitada.
    """
    MINOR

    """
    Facción con una influencia considerable en una región o sector de la sociedad.
    """
    REGIONAL

    """
    Facción con impacto significativo en múltiples regiones o áreas de poder.
    """
    MAJOR

    """
    Facción de importancia global o interdimensional.
    """
    WORLDWIDE
}

"""
Define la relación entre dos facciones.
Puede representar alianzas, enemistades, subordinación y competencia.
"""
enum FactionFactionRelation {
    # Relaciones de cooperación
    """
    Las facciones están aliadas y colaboran activamente.
    """
    ALLIED

    """
    Una facción está subordinada a otra.
    """
    VASSAL

    """
    Ambas facciones tienen un pacto de no agresión o comercio.
    """
    NEUTRAL_PACT

    # Relaciones de conflicto
    """
    Las facciones son enemigas y están en guerra o conflicto activo.
    """
    ENEMY

    """
    Una facción busca la destrucción o disolución de la otra.
    """
    RIVALRY

    """
    Las facciones tienen desacuerdos políticos, económicos o ideológicos.
    """
    TENSION

    # Relaciones diplomáticas
    """
    Una facción ha sido absorbida por otra y ya no existe como entidad independiente.
    """
    ABSORBED

    """
    Las facciones están en tregua temporal tras un conflicto.
    """
    TRUCE
}

"""
Define la relación entre una facción y un evento.
Puede representar participación en batallas, diplomacia, rebeliones y más.
"""
enum FactionEventRelation {
    # Participación activa
    """
    La facción inició o provocó el evento.
    """
    INITIATOR

    """
    La facción participó activamente en el evento.
    """
    PARTICIPANT

    """
    La facción organizó el evento, pero no participó directamente.
    """
    ORGANIZER

    # Relaciones de conflicto o respuesta
    """
    La facción intentó evitar o detener el evento.
    """
    OPPOSER

    """
    La facción sufrió las consecuencias del evento.
    """
    AFFECTED

    """
    La facción usó el evento como una oportunidad política o económica.
    """
    OPPORTUNIST

    # Relaciones diplomáticas
    """
    El evento llevó a la facción a hacer un tratado de paz o alianza.
    """
    DIPLOMATIC_SHIFT

    """
    El evento causó la disolución de la facción.
    """
    DISSOLUTION
}

"""
Define la relación entre una facción y un ítem.
Puede representar reliquias, símbolos de poder, armamento y más.
"""
enum FactionItemRelation {
    # Relaciones de posesión y uso
    """
    El ítem es un símbolo de poder o autoridad de la facción.
    """
    SYMBOL

    """
    El ítem es una reliquia sagrada o de gran valor para la facción.
    """
    RELIC

    """
    El ítem es parte del armamento de la facción.
    """
    WEAPON

    """
    El ítem es un documento, tratado o código legal de la facción.
    """
    DOCUMENT

    # Relaciones históricas y mitológicas
    """
    El ítem está vinculado a la historia de la facción.
    """
    HISTORICAL

    """
    El ítem tiene un valor cultural o religioso para la facción.
    """
    CULTURAL
}

"""
Define la relación entre una facción y una ubicación.
Puede representar dominio, influencia, exilio y más.
"""
enum FactionLocationRelation {
    # Relaciones de control y dominio
    """
    La facción controla la ubicación como su territorio principal.
    """
    CAPITAL

    """
    La facción posee la ubicación como parte de su territorio.
    """
    OWNED

    """
    La facción ejerce influencia política, económica o militar en la ubicación.
    """
    INFLUENCE

    # Relaciones de conflicto y exilio
    """
    La facción perdió la ubicación tras un conflicto o caída de poder.
    """
    LOST_TERRITORY

    """
    La facción fue exiliada de esta ubicación y no puede regresar.
    """
    EXILED

    """
    La facción intenta conquistar la ubicación.
    """
    CONQUERING

    """
    La facción ha ocupado temporalmente la ubicación mediante fuerza militar o diplomacia.
    """
    OCCUPIED

    # Relaciones neutrales y estratégicas
    """
    La facción tiene presencia en la ubicación, pero no la controla.
    """
    OUTPOST

    """
    La facción considera la ubicación sagrada o importante por razones religiosas o culturales.
    """
    SACRED_SITE
}

"""
Define la relación entre una facción y un mundo.
Puede representar su origen, dominio, influencia interdimensional y más.
"""
enum FactionWorldRelation {
    # Existencia y origen
    """
    La facción fue fundada en este mundo y es nativa de él.
    """
    NATIVE

    """
    La facción se expandió a este mundo desde otro plano de existencia.
    """
    EXPANDED

    """
    La facción gobierna o tiene control absoluto sobre este mundo.
    """
    RULER

    """
    La facción ha sido exiliada de este mundo y no puede regresar.
    """
    EXILED

    # Influencia y operaciones
    """
    La facción tiene influencia política, económica o militar en este mundo.
    """
    INFLUENCE

    """
    La facción opera en este mundo, pero sin un territorio propio.
    """
    OPERATES_HERE

    """
    La facción ha sido eliminada de este mundo y ya no existe en él.
    """
    ERADICATED

    # Conexiones interdimensionales
    """
    La facción usa este mundo como punto de acceso para otros planos o dimensiones.
    """
    INTERPLANAR_BASE

    """
    La facción es una anomalía en este mundo y no pertenece a su realidad.
    """
    ANOMALY
}
`, BuiltIn: false},
	{Name: "../../../graphql/Faction/input.graphqls", Input: `"""
Estructura para crear una nueva facción dentro de un mundo.
"""
input CreateFactionInput {
    """
    ID del mundo al que pertenece la facción.
    """
    worldId: ID!

    """
    Nombre de la facción.
    """
    name: String!

    """
    Descripción de la facción, incluyendo su historia, cultura y propósito.
    """
    description: String!

    """
    Clasificación de la facción según su estructura y propósito.
    """
    type: FactionType!

    """
    Ideología, valores o principios que rigen a la facción.
    """
    ideology: String!

    """
    Estatus actual de la facción (activa, disuelta, exiliada, etc.).
    """
    status: FactionStatus!

    """
    Fecha de fundación de la facción en formato ISO 8601 (YYYY-MM-DD).
    """
    foundedDate: String!

    """
    Fecha de disolución de la facción (opcional, en caso de que ya no exista).
    """
    disbandedDate: String

    """
    Nivel de influencia de la facción en la historia o sociedad.
    """
    influence: FactionInfluence!

    """
    Lista de ubicaciones donde la facción tiene presencia, dominio o influencia.
    """
    locations: [ID!]!

    """
    Lista de mundos donde la facción tiene presencia, influencia o ha sido exiliada.
    """
    worlds: [ID!]!
}

"""
Estructura para actualizar una facción existente.
"""
input UpdateFactionInput {
    """
    ID de la facción a modificar.
    """
    id: ID!

    """
    Nuevo nombre de la facción (opcional).
    """
    name: String

    """
    Nueva descripción de la facción (opcional).
    """
    description: String

    """
    Modificar la clasificación de la facción (opcional).
    """
    type: FactionType

    """
    Modificar la ideología de la facción (opcional).
    """
    ideology: String

    """
    Modificar el estatus actual de la facción (opcional).
    """
    status: FactionStatus

    """
    Modificar la fecha de fundación de la facción (opcional).
    """
    foundedDate: String

    """
    Modificar la fecha de disolución de la facción (opcional).
    """
    disbandedDate: String

    """
    Modificar el nivel de influencia de la facción (opcional).
    """
    influence: FactionInfluence

    """
    Modificar las ubicaciones donde la facción tiene presencia (opcional).
    """
    locations: [ID!]

    """
    Modificar los mundos donde la facción tiene influencia (opcional).
    """
    worlds: [ID!]
}
`, BuiltIn: false},
	{Name: "../../../graphql/Faction/type.graphqls", Input: `"""
Representa una facción dentro del mundo ficticio.
Incluye datos generales, estructura organizativa, ideología y relaciones con otras entidades.
"""
type Faction implements Entity {
    # Identificación y metadatos
    """
    Identificador único de la facción.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creación de la facción en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de última actualización de la facción en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Información general
    """
    Nombre de la facción.
    """
    name: String!

    """
    Descripción de la facción, incluyendo su historia, cultura y propósito.
    """
    description: String!

    """
    Clasificación de la facción según su estructura y propósito.
    """
    type: FactionType!

    """
    Ideología, valores o principios que rigen a la facción.
    """
    ideology: String!

    """
    Estatus actual de la facción (activa, disuelta, exiliada, etc.).
    """
    status: FactionStatus!

    """
    Fecha de fundación de la facción en formato ISO 8601 (YYYY-MM-DD).
    """
    foundedDate: String!

    """
    Fecha de disolución de la facción (opcional, en caso de que ya no exista).
    """
    disbandedDate: String

    """
    Nivel de influencia de la facción en la historia o sociedad.
    """
    influence: FactionInfluence!

    # Ubicación y dominio
    """
    Lista de ubicaciones donde la facción tiene presencia, dominio o influencia.
    """
    locations: [FactionLocation!]!

    """
    Lista de mundos donde la facción tiene presencia, influencia o ha sido exiliada.
    """
    worlds: [FactionWorld!]!

    # Relaciones con otras entidades
    """
    Lista de personajes afiliados a la facción.
    """
    characters: [CharacterFaction!]!

    """
    Lista de criaturas asociadas a la facción (usadas en combate, veneradas, etc.).
    """
    creatures: [CreatureFaction!]!

    """
    Lista de facciones relacionadas (aliadas, enemigas, subordinadas, etc.).
    """
    factions: [FactionFaction!]!

    """
    Lista de eventos clave en los que la facción estuvo involucrada.
    """
    events: [FactionEvent!]!

    """
    Lista de ítems asociados a la facción (armamento, reliquias, símbolos).
    """
    items: [FactionItem!]!
}

"""
Define la relación entre dos facciones.
Puede incluir alianzas, enemistades, pactos y subordinación.
"""
type FactionFaction {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La facción con la que se establece la relación.
    """
    faction: Faction!

    """
    Tipo de relación entre ambas facciones (aliadas, enemigas, vasallaje, etc.).
    """
    relation: FactionFactionRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre una facción y un evento.
Puede representar participación en batallas, diplomacia o conflictos internos.
"""
type FactionEvent {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La facción que tiene la relación con el evento.
    """
    faction: Faction!

    """
    El evento con el que la facción tiene una relación.
    """
    event: Event!

    """
    Tipo de relación entre la facción y el evento (participación, iniciador, oposición, etc.).
    """
    relation: FactionEventRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre una facción y un ítem.
Puede representar reliquias, símbolos de poder, armamento y más.
"""
type FactionItem {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La facción que tiene la relación con el ítem.
    """
    faction: Faction!

    """
    El ítem con el que la facción tiene una relación.
    """
    item: Item!

    """
    Tipo de relación entre la facción y el ítem (símbolo, reliquia, armamento, etc.).
    """
    relation: FactionItemRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre una facción y una ubicación.
Puede representar control, influencia, exilio o presencia estratégica.
"""
type FactionLocation {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La facción que tiene la relación con la ubicación.
    """
    faction: Faction!

    """
    La ubicación con la que la facción tiene una relación.
    """
    location: Location!

    """
    Tipo de relación entre la facción y la ubicación (control, influencia, exilio, etc.).
    """
    relation: FactionLocationRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre una facción y un mundo.
Puede representar su origen, dominio, influencia interdimensional o exilio.
"""
type FactionWorld {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La facción que tiene la relación con el mundo.
    """
    faction: Faction!

    """
    El mundo con el que la facción tiene una relación.
    """
    world: World!

    """
    Tipo de relación entre la facción y el mundo (nativa, exiliada, gobernante, etc.).
    """
    relation: FactionWorldRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/Item/enum.graphqls", Input: `"""
Define en qué parte del cuerpo o en qué espacio del inventario se equipa un ítem.
Incluye armaduras, armas, accesorios y objetos especiales.
"""
enum ItemSlot {
    # Equipamiento en la cabeza y rostro
    """
    Casco, corona o cualquier tipo de protección para la cabeza.
    """
    HEAD

    """
    Pendientes o accesorios equipados en las orejas.
    """
    EARS

    """
    Collares, amuletos u objetos usados en el cuello.
    """
    NECK

    # Equipamiento en la parte superior del cuerpo
    """
    Hombreras o protecciones colocadas en los hombros.
    """
    SHOULDERS

    """
    Capa, manto o cualquier accesorio usado en la espalda.
    """
    BACK

    """
    Protecciones o equipamiento en los brazos (manguitos, brazales, etc.).
    """
    ARMS

    """
    Muñequeras, pulseras o protecciones en las muñecas.
    """
    WRISTS

    """
    Guantes, garras o cualquier ítem usado en las manos.
    """
    HANDS

    """
    Anillos y sortijas usados en los dedos.
    """
    FINGERS

    """
    Armadura o vestimenta que cubre el torso del personaje.
    """
    CHEST

    """
    Cinturones, fajines u otros objetos equipados en la cintura.
    """
    WAIST

    # Equipamiento en las piernas y pies
    """
    Armaduras o vestimenta que cubre las piernas completas.
    """
    LEGS

    """
    Equipamiento para la parte inferior de las piernas (grebas, espinilleras).
    """
    LOWER_LEGS

    """
    Equipamiento para la parte superior de las piernas (musleras, faldones).
    """
    UPPER_LEGS

    """
    Protecciones específicas para las rodillas (rodilleras).
    """
    KNEES

    """
    Botas, sandalias o cualquier calzado usado en los pies.
    """
    FEET

    # Equipamiento de armas y combate
    """
    Arma de combate cuerpo a cuerpo de una mano.
    """
    MELEE_ONE_HAND

    """
    Arma de combate cuerpo a cuerpo de dos manos.
    """
    MELEE_TWO_HAND

    """
    Arma a distancia de una mano (pistolas, dagas arrojadizas).
    """
    RANGED_ONE_HAND

    """
    Arma a distancia de dos manos (arcos, ballestas, rifles).
    """
    RANGED_TWO_HAND

    """
    Arma híbrida de una mano (arma que puede ser usada cuerpo a cuerpo y a distancia).
    """
    HYBRID_ONE_HAND

    """
    Arma híbrida de dos manos (arma de uso mixto con ambas manos).
    """
    HYBRID_TWO_HAND

    """
    Escudos y defensas que se pueden equipar en una mano.
    """
    SHIELD

    # Accesorios y objetos especiales
    """
    Tabardos o emblemas que representan facciones o grupos.
    """
    TABARD

    """
    Camisas y prendas interiores que no afectan la armadura.
    """
    SHIRT

    """
    Objetos especiales con habilidades activas o pasivas.
    """
    TRINKET

    """
    Reliquias o artefactos sagrados de gran poder.
    """
    RELIC
}

"""
Clasifica los ítems según su función o propósito dentro del mundo ficticio.
"""
enum ItemType {
    # Armas y equipo de combate
    """
    Un arma utilizada en combate (espada, lanza, arco, etc.).
    """
    WEAPON

    """
    Armadura o escudo diseñado para la protección del usuario.
    """
    ARMOR

    """
    Accesorios de combate como anillos, amuletos, brazales.
    """
    COMBAT_ACCESSORY

    # Objetos mágicos y sobrenaturales
    """
    Un artefacto mágico con habilidades únicas.
    """
    ARTIFACT

    """
    Un pergamino o tomo con conocimientos ocultos o conjuros.
    """
    SPELLBOOK

    """
    Un ítem maldito que tiene efectos negativos sobre su portador.
    """
    CURSED_ITEM

    # Ítems utilitarios
    """
    Herramientas de uso general como llaves, brújulas, o dagas multiusos.
    """
    TOOL

    """
    Pociones y consumibles que otorgan efectos temporales.
    """
    POTION

    """
    Un mapa que proporciona información sobre el mundo o una región.
    """
    MAP

    # Objetos históricos y simbólicos
    """
    Un ítem con importancia histórica o cultural.
    """
    RELIC

    """
    Un documento escrito, como un tratado, un contrato o un diario.
    """
    DOCUMENT

    """
    Un objeto de alto valor simbólico o representativo de una facción.
    """
    SYMBOL
}

"""
Clasifica los ítems según su rareza dentro del mundo ficticio.
"""
enum ItemRarity {
    """
    Ítems comunes y de fácil acceso en el mundo.
    """
    COMMON

    """
    Ítems poco comunes, difíciles de encontrar pero no únicos.
    """
    UNCOMMON

    """
    Ítems raros, con habilidades especiales o historias únicas.
    """
    RARE

    """
    Ítems extremadamente raros, con gran poder o significado.
    """
    LEGENDARY

    """
    Ítems únicos, con una sola existencia en el mundo.
    """
    UNIQUE
}

"""
Define el estado físico de un ítem, indicando su grado de desgaste o conservación.
"""
enum ItemCondition {
    """
    El ítem está en perfectas condiciones, sin daños ni desgaste.
    """
    PRISTINE

    """
    El ítem muestra signos de uso, pero aún está en buen estado.
    """
    USED

    """
    El ítem está dañado o desgastado, pero sigue siendo funcional.
    """
    WORN

    """
    El ítem está roto o inutilizable en su estado actual.
    """
    BROKEN

    """
    El ítem ha sido encantado o alterado mágicamente.
    """
    ENCHANTED

    """
    El ítem está corroído o en proceso de deterioro.
    """
    CORRODED
}

"""
Define la relación entre dos ítems.
Puede representar combinaciones, piezas de un set, transformación y otras interacciones.
"""
enum ItemItemRelation {
    # Relaciones de combinación y mejora
    """
    Los ítems se pueden combinar para formar un nuevo objeto.
    """
    COMBINABLE

    """
    Uno de los ítems es un componente necesario para otro.
    """
    COMPONENT

    """
    Los ítems forman parte de un set o conjunto especial.
    """
    SET_ITEM

    """
    Un ítem puede evolucionar en otro mediante uso o mejora.
    """
    EVOLUTION

    # Relaciones de influencia
    """
    Los ítems son opuestos o tienen efectos que se anulan mutuamente.
    """
    OPPOSITE

    """
    Los ítems tienen una conexión histórica o mitológica.
    """
    LINKED_HISTORY

    """
    Uno de los ítems fue creado a partir del otro.
    """
    DERIVED_FROM
}

"""
Define la relación entre un ítem y una ubicación.
Puede representar su almacenamiento, hallazgo o pérdida.
"""
enum ItemLocationRelation {
    # Relaciones de posesión y almacenamiento
    """
    El ítem está guardado o almacenado en la ubicación.
    """
    STORED

    """
    El ítem fue encontrado en la ubicación.
    """
    DISCOVERED

    """
    El ítem está oculto o sellado en la ubicación.
    """
    SEALED

    """
    El ítem está perdido o abandonado en la ubicación.
    """
    LOST

    # Relaciones de creación y destrucción
    """
    El ítem fue forjado, creado o ensamblado en la ubicación.
    """
    CREATED

    """
    El ítem fue destruido o desmantelado en la ubicación.
    """
    DESTROYED
}

"""
Define la relación entre un ítem y un evento.
Puede representar su uso, descubrimiento, destrucción y más.
"""
enum ItemEventRelation {
    # Relaciones de descubrimiento y posesión
    """
    El ítem fue descubierto o adquirido durante el evento.
    """
    DISCOVERED

    """
    El ítem fue entregado o transferido a otra entidad en el evento.
    """
    TRADED

    """
    El ítem fue robado o perdido durante el evento.
    """
    STOLEN

    # Relaciones de influencia y uso
    """
    El ítem fue utilizado activamente en el evento.
    """
    USED

    """
    El ítem fue clave para el desarrollo o desenlace del evento.
    """
    KEY_ITEM

    """
    El ítem fue destruido o inutilizado durante el evento.
    """
    DESTROYED
}
`, BuiltIn: false},
	{Name: "../../../graphql/Item/input.graphqls", Input: `"""
Estructura para crear un nuevo ítem dentro de un mundo.
"""
input CreateItemInput {
    """
    ID del mundo al que pertenece el ítem.
    """
    worldId: ID!

    """
    Nombre del ítem.
    """
    name: String!

    """
    Descripción del ítem, incluyendo su historia y propiedades únicas.
    """
    description: String!

    """
    Clasificación del ítem según su función o propósito.
    """
    type: ItemType!

    """
    Rareza del ítem dentro del mundo (común, poco común, raro, legendario).
    """
    rarity: ItemRarity!

    """
    Espacio donde se equipa el ítem en el cuerpo o inventario.
    """
    slot: ItemSlot!

    """
    Material principal del que está hecho el ítem.
    """
    material: String!

    """
    Estado del ítem (nuevo, desgastado, roto, encantado, etc.).
    """
    condition: ItemCondition!

    """
    Peso del ítem en kilogramos (kg).
    """
    weight: Float!

    """
    Dimensiones del ítem (alto, ancho, largo).
    """
    dimensions: String!

    """
    Fecha de creación o forja del ítem (opcional).
    """
    creationDate: String

    """
    Fecha de destrucción del ítem (opcional, si ya no existe).
    """
    destructionDate: String

    # Propiedades especiales
    """
    Indica si el ítem tiene propiedades mágicas o sobrenaturales.
    """
    isMagical: Boolean!

    """
    Lista de habilidades o efectos que posee el ítem (si es mágico o especial).
    """
    abilities: [String!]!

    """
    Costo del ítem en la moneda estándar del mundo.
    """
    value: Float!
}

"""
Estructura para actualizar un ítem existente.
"""
input UpdateItemInput {
    """
    ID del ítem a modificar.
    """
    id: ID!

    """
    Nuevo nombre del ítem (opcional).
    """
    name: String

    """
    Nueva descripción del ítem (opcional).
    """
    description: String

    """
    Modificar la clasificación del ítem (opcional).
    """
    type: ItemType

    """
    Modificar la rareza del ítem (opcional).
    """
    rarity: ItemRarity

    """
    Modificar el espacio donde se equipa el ítem (opcional).
    """
    slot: ItemSlot

    """
    Modificar el material del ítem (opcional).
    """
    material: String

    """
    Modificar el estado del ítem (opcional).
    """
    condition: ItemCondition

    """
    Modificar el peso del ítem (opcional).
    """
    weight: Float

    """
    Modificar las dimensiones del ítem (opcional).
    """
    dimensions: String

    """
    Modificar la fecha de creación del ítem (opcional).
    """
    creationDate: String

    """
    Modificar la fecha de destrucción del ítem (opcional).
    """
    destructionDate: String

    # Propiedades especiales
    """
    Modificar si el ítem tiene propiedades mágicas (opcional).
    """
    isMagical: Boolean

    """
    Modificar las habilidades del ítem (opcional).
    """
    abilities: [String!]

    """
    Modificar el costo del ítem (opcional).
    """
    value: Float
}
`, BuiltIn: false},
	{Name: "../../../graphql/Item/type.graphqls", Input: `"""
Representa un ítem dentro del mundo ficticio.
Incluye datos generales, características, propiedades y relaciones con otras entidades.
"""
type Item implements Entity {
    # Identificación y metadatos
    """
    Identificador único del ítem.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creación del ítem en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de última actualización del ítem en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Información general
    """
    Nombre del ítem.
    """
    name: String!

    """
    Descripción del ítem, incluyendo su historia y propiedades únicas.
    """
    description: String!

    """
    Clasificación del ítem según su función o propósito.
    """
    type: ItemType!

    """
    Rareza del ítem dentro del mundo (común, poco común, raro, legendario).
    """
    rarity: ItemRarity!

    """
    Espacio donde se equipa el ítem en el cuerpo o inventario.
    """
    slot: ItemSlot!

    """
    Material principal del que está hecho el ítem.
    """
    material: String!

    """
    Estado del ítem (nuevo, desgastado, roto, encantado, etc.).
    """
    condition: ItemCondition!

    """
    Peso del ítem en kilogramos (kg).
    """
    weight: Float!

    """
    Dimensiones del ítem (alto, ancho, largo).
    """
    dimensions: String!

    """
    Fecha de creación o forja del ítem (opcional).
    """
    creationDate: String

    """
    Fecha de destrucción del ítem (opcional, si ya no existe).
    """
    destructionDate: String

    # Propiedades especiales
    """
    Indica si el ítem tiene propiedades mágicas o sobrenaturales.
    """
    isMagical: Boolean!

    """
    Lista de habilidades o efectos que posee el ítem (si es mágico o especial).
    """
    abilities: [String!]!

    """
    Costo del ítem en la moneda estándar del mundo.
    """
    value: Float!

    # Relaciones con otras entidades
    """
    Lista de personajes que han tenido o usado el ítem.
    """
    characters: [CharacterItem!]!

    """
    Lista de facciones que han poseído o utilizado el ítem.
    """
    factions: [FactionItem!]!

    """
    Lista de eventos en los que el ítem ha jugado un papel importante.
    """
    events: [ItemEvent!]!

    """
    Lista de ubicaciones donde el ítem ha estado o puede encontrarse.
    """
    locations: [ItemLocation!]!

    """
    Lista de otros ítems relacionados (artefactos combinables, piezas de un set, etc.).
    """
    relatedItems: [ItemItem!]!
}

"""
Define la relación entre un ítem y un evento.
Puede representar su uso, descubrimiento, destrucción y más.
"""
type ItemEvent {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El item con el que el evento tiene una relación.
    """
    item: Item!

    """
    El evento con el que el ítem tiene una relación.
    """
    event: Event!

    """
    Tipo de relación entre el ítem y el evento (descubrimiento, destrucción, uso, etc.).
    """
    relation: ItemEventRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre un ítem y una ubicación.
Puede representar su almacenamiento, hallazgo o pérdida.
"""
type ItemLocation {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El ítem con el que la ubicación tiene una relación.
    """
    item: Item!

    """
    La ubicación con la que el ítem tiene una relación.
    """
    with: Location!

    """
    Tipo de relación entre el ítem y la ubicación (almacenado, perdido, descubierto, etc.).
    """
    relation: ItemLocationRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre dos ítems.
Puede representar combinaciones, piezas de un set o evolución.
"""
type ItemItem {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El otro ítem con el que se establece la relación.
    """
    item: Item!

    """
    Tipo de relación entre ambos ítems (combinables, piezas de un set, evolución, etc.).
    """
    relation: ItemItemRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/Location/enum.graphqls", Input: `"""
Clasifica las ubicaciones según su naturaleza y propósito.
Incluye ciudades, mazmorras, asentamientos y entornos naturales.
"""
enum LocationType {
    # Asentamientos y ciudades
    """
    Una ciudad grande con estructuras avanzadas y una alta población.
    """
    CITY

    """
    Una pequeña aldea o comunidad rural.
    """
    VILLAGE

    """
    Un castillo o fortaleza con fines defensivos o administrativos.
    """
    FORTRESS

    """
    Un puesto comercial o enclave en una zona aislada.
    """
    OUTPOST

    # Entornos naturales
    """
    Un bosque denso con vegetación abundante.
    """
    FOREST

    """
    Una región desértica con escasez de agua y temperaturas extremas.
    """
    DESERT

    """
    Una cueva natural o sistema de cavernas subterráneas.
    """
    CAVE

    """
    Un cuerpo de agua, como un lago, río o mar.
    """
    WATER_BODY

    """
    Una cadena montañosa o área rocosa con elevaciones pronunciadas.
    """
    MOUNTAINS

    """
    Una isla o archipiélago rodeado de agua.
    """
    ISLAND

    """
    Una zona pantanosa con terrenos inestables y humedad alta.
    """
    SWAMP

    # Lugares artificiales y místicos
    """
    Una mazmorra o estructura subterránea con secretos ocultos.
    """
    DUNGEON

    """
    Un templo o santuario con significado religioso o espiritual.
    """
    TEMPLE

    """
    Un portal interdimensional o conexión con otro plano de existencia.
    """
    PORTAL

    """
    Un laboratorio o taller donde se realizan experimentos científicos o mágicos.
    """
    LABORATORY
}

"""
Define el nivel de accesibilidad de una ubicación.
Indica si es pública, restringida, oculta o de difícil acceso.
"""
enum LocationAccessibility {
    """
    Ubicación de libre acceso para cualquier persona.
    """
    PUBLIC

    """
    Ubicación restringida, accesible solo para ciertos grupos o con permisos especiales.
    """
    RESTRICTED

    """
    Ubicación oculta o secreta, su existencia no es de conocimiento público.
    """
    HIDDEN

    """
    Ubicación de acceso extremadamente difícil por razones naturales o mágicas.
    """
    INACCESSIBLE
}

"""
Define la relación entre dos ubicaciones.
Puede representar conexiones geográficas, políticas o mágicas.
"""
enum LocationLocationRelation {
    """
    Una ubicación está dentro de otra (ej. ciudad dentro de un reino).
    """
    CONTAINED_WITHIN

    """
    Las ubicaciones están conectadas por caminos, túneles o portales.
    """
    CONNECTED

    """
    Una ubicación es la capital o centro administrativo de otra.
    """
    CAPITAL

    """
    Las ubicaciones son rivales o han tenido conflictos históricos.
    """
    RIVALRY
}

"""
Define la relación entre una ubicación y un evento.
Puede representar batallas, desastres, fundaciones y más.
"""
enum LocationEventRelation {
    """
    El evento ocurrió en esta ubicación.
    """
    OCCURRED_HERE

    """
    La ubicación fue destruida o gravemente afectada por el evento.
    """
    DESTROYED

    """
    El evento llevó a la fundación de la ubicación.
    """
    FOUNDED

    """
    La ubicación fue abandonada como resultado del evento.
    """
    ABANDONED
}

"""
Define la relación entre una ubicación y un mundo.
Puede representar su existencia, influencia interdimensional y más.
"""
enum LocationWorldRelation {
    # Existencia y origen
    """
    La ubicación es originaria de este mundo.
    """
    NATIVE

    """
    La ubicación fue creada artificialmente en este mundo.
    """
    ARTIFICIAL

    """
    La ubicación existe en múltiples mundos al mismo tiempo (multiversal, interdimensional).
    """
    MULTIVERSE_EXISTENCE

    # Conexiones y accesibilidad
    """
    La ubicación tiene portales o conexiones con este mundo.
    """
    CONNECTED

    """
    La ubicación es inaccesible desde este mundo sin medios especiales.
    """
    INACCESSIBLE

    """
    La ubicación es una anomalía dentro del mundo (cambio de realidad, error mágico).
    """
    ANOMALY
}
`, BuiltIn: false},
	{Name: "../../../graphql/Location/input.graphqls", Input: `"""
Estructura para crear una nueva ubicación dentro de un mundo.
"""
input CreateLocationInput {
    """
    ID del mundo al que pertenece la ubicación.
    """
    worldId: ID!

    """
    Nombre de la ubicación.
    """
    name: String!

    """
    Descripción detallada de la ubicación, incluyendo su historia y características.
    """
    description: String!

    """
    Clasificación de la ubicación según su tipo (ciudad, bosque, mazmorra, etc.).
    """
    type: LocationType!

    """
    Región o territorio al que pertenece la ubicación.
    """
    region: String!

    """
    Coordenadas geográficas aproximadas (latitud, longitud).
    """
    coordinates: String!

    """
    Nivel de accesibilidad de la ubicación (pública, restringida, oculta, etc.).
    """
    accessibility: LocationAccessibility!

    """
    Indica si la ubicación es natural o artificial.
    """
    isNatural: Boolean!

    """
    Clima predominante en la ubicación.
    """
    climate: String!

    """
    Ecosistema de la ubicación (bosque, desierto, pantano, etc.).
    """
    ecosystem: String!
}

"""
Estructura para actualizar una ubicación existente.
"""
input UpdateLocationInput {
    """
    ID de la ubicación a modificar.
    """
    id: ID!

    """
    Nuevo nombre de la ubicación (opcional).
    """
    name: String

    """
    Nueva descripción de la ubicación (opcional).
    """
    description: String

    """
    Modificar la clasificación de la ubicación (opcional).
    """
    type: LocationType

    """
    Modificar la región o territorio de la ubicación (opcional).
    """
    region: String

    """
    Modificar las coordenadas de la ubicación (opcional).
    """
    coordinates: String

    """
    Modificar el nivel de accesibilidad de la ubicación (opcional).
    """
    accessibility: LocationAccessibility

    """
    Modificar si la ubicación es natural o artificial (opcional).
    """
    isNatural: Boolean

    """
    Modificar el clima de la ubicación (opcional).
    """
    climate: String

    """
    Modificar el ecosistema de la ubicación (opcional).
    """
    ecosystem: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/Location/type.graphqls", Input: `"""
Representa una ubicación dentro del mundo ficticio.
Incluye datos generales, características geográficas y relaciones con otras entidades.
"""
type Location implements Entity {
    # Identificación y metadatos
    """
    Identificador único de la ubicación.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creación de la ubicación en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de última actualización de la ubicación en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Información general
    """
    Nombre de la ubicación.
    """
    name: String!

    """
    Descripción detallada de la ubicación, incluyendo su historia y características.
    """
    description: String!

    """
    Clasificación de la ubicación según su tipo (ciudad, bosque, mazmorra, etc.).
    """
    type: LocationType!

    """
    Región o territorio al que pertenece la ubicación.
    """
    region: String!

    """
    Coordenadas geográficas aproximadas (latitud, longitud).
    """
    coordinates: String!

    """
    Nivel de accesibilidad de la ubicación (pública, restringida, oculta, etc.).
    """
    accessibility: LocationAccessibility!

    """
    Indica si la ubicación es natural o artificial.
    """
    isNatural: Boolean!

    """
    Clima predominante en la ubicación.
    """
    climate: String!

    """
    Ecosistema de la ubicación (bosque, desierto, pantano, etc.).
    """
    ecosystem: String!

    # Relaciones con otras entidades
    """
    Lista de personajes que residen o han estado en la ubicación.
    """
    characters: [CharacterLocation!]!

    """
    Lista de criaturas que habitan o han pasado por la ubicación.
    """
    creatures: [CreatureLocation!]!

    """
    Lista de facciones que controlan o han operado en la ubicación.
    """
    factions: [FactionLocation!]!

    """
    Lista de eventos históricos que han ocurrido en la ubicación.
    """
    events: [LocationEvent!]!

    """
    Lista de ítems que han sido encontrados o almacenados en la ubicación.
    """
    items: [ItemLocation!]!

    """
    Lista de otras ubicaciones relacionadas (ciudades dentro de un país, conexiones mágicas, etc.).
    """
    relatedLocations: [LocationLocation!]!

    """
    Lista de mundos en los que existe o influye esta ubicación.
    """
    worlds: [LocationWorld!]!
}

"""
Define la relación entre dos ubicaciones.
Puede representar conexiones geográficas, políticas o mágicas.
"""
type LocationLocation {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La otra ubicación con la que se establece la relación.
    """
    location: Location!

    """
    Tipo de relación entre ambas ubicaciones (contenida dentro, conectada, capital, etc.).
    """
    relation: LocationLocationRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre una ubicación y un evento.
Puede representar batallas, desastres, fundaciones y más.
"""
type LocationEvent {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La ubicación con la que el evento tiene una relación.
    """
    location: Location!

    """
    El evento con el que la ubicación tiene una relación.
    """
    event: Event!

    """
    Tipo de relación entre la ubicación y el evento (batalla, destrucción, fundación, etc.).
    """
    relation: LocationEventRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre una ubicación y un mundo.
Puede representar su existencia, conexiones interdimensionales o anomalías.
"""
type LocationWorld {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    La ubicación con la que el mundo tiene una relación.
    """
    location: Location!

    """
    El mundo con el que la ubicación tiene una relación.
    """
    world: World!

    """
    Tipo de relación entre la ubicación y el mundo (nativa, artificial, conectada, etc.).
    """
    relation: LocationWorldRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
	{Name: "../../../graphql/mutation.graphqls", Input: `"""
Mutaciones para crear, actualizar y eliminar universos.
"""
type Mutation {
    """
    Crea un nuevo personaje dentro de un mundo.
    """
    createCharacter(input: CreateCharacterInput!): Character!

    """
    Actualiza los datos de un personaje existente.
    """
    updateCharacter(input: UpdateCharacterInput!): Character!

    """
    Elimina un personaje por su ID.
    """
    deleteCharacter(id: ID!): Boolean!

    """
    Crea una nueva criatura dentro de un mundo.
    """
    createCreature(input: CreateCreatureInput!): Creature!

    """
    Actualiza los datos de una criatura existente.
    """
    updateCreature(input: UpdateCreatureInput!): Creature!

    """
    Elimina una criatura por su ID.
    """
    deleteCreature(id: ID!): Boolean!

    """
    Crea un nuevo ítem dentro de un mundo.
    """
    createItem(input: CreateItemInput!): Item!

    """
    Actualiza los datos de un ítem existente.
    """
    updateItem(input: UpdateItemInput!): Item!

    """
    Elimina un ítem por su ID.
    """
    deleteItem(id: ID!): Boolean!

    """
    Crea una nueva ubicación dentro de un mundo.
    """
    createLocation(input: CreateLocationInput!): Location!

    """
    Actualiza los datos de una ubicación existente.
    """
    updateLocation(input: UpdateLocationInput!): Location!

    """
    Elimina una ubicación por su ID.
    """
    deleteLocation(id: ID!): Boolean!

    """
    Crea una nueva facción dentro de un mundo.
    """
    createFaction(input: CreateFactionInput!): Faction!

    """
    Actualiza los datos de una facción existente.
    """
    updateFaction(input: UpdateFactionInput!): Faction!

    """
    Elimina una facción por su ID.
    """
    deleteFaction(id: ID!): Boolean!

    """
    Crea un nuevo evento dentro de un mundo.
    """
    createEvent(input: CreateEventInput!): Event!

    """
    Actualiza los datos de un evento existente.
    """
    updateEvent(input: UpdateEventInput!): Event!

    """
    Elimina un evento por su ID.
    """
    deleteEvent(id: ID!): Boolean!

    """
    Crea un nuevo mundo dentro de un universo.
    """
    createWorld(input: CreateWorldInput!): World!

    """
    Actualiza los datos de un mundo existente.
    """
    updateWorld(input: UpdateWorldInput!): World!

    """
    Elimina un mundo por su ID.
    """
    deleteWorld(id: ID!): Boolean!

    """
    Crea un nuevo universo.
    """
    createUniverse(input: CreateUniverseInput!): Universe!

    """
    Actualiza los datos de un universo existente.
    """
    updateUniverse(input: UpdateUniverseInput!): Universe!

    """
    Elimina un universo por su ID.
    """
    deleteUniverse(id: ID!): Boolean!
}
`, BuiltIn: false},
	{Name: "../../../graphql/query.graphqls", Input: `"""
Consultas relacionadas con los universos dentro del sistema.
"""
type Query {
    # Obtención de Personajes
    """
    Devuelve un personaje específico por su ID.
    """
    character(id: ID!): Character

    """
    Devuelve una lista de personajes dentro de un mundo, con paginación opcional.
    """
    characters(worldId: ID!, limit: Int = 10, offset: Int = 0): [Character!]!

    # Obtención de Criaturas
    """
    Devuelve una criatura específica por su ID.
    """
    creature(id: ID!): Creature

    """
    Devuelve una lista de criaturas dentro de un mundo, con paginación opcional.
    """
    creatures(worldId: ID!, limit: Int = 10, offset: Int = 0): [Creature!]!

    # Obtención de Ítems
    """
    Devuelve un ítem específico por su ID.
    """
    item(id: ID!): Item

    """
    Devuelve una lista de ítems dentro de un mundo, con paginación opcional.
    """
    items(worldId: ID!, limit: Int = 10, offset: Int = 0): [Item!]!

    # Obtención de Ubicaciones
    """
    Devuelve una ubicación específica por su ID.
    """
    location(id: ID!): Location

    """
    Devuelve una lista de ubicaciones dentro de un mundo, con paginación opcional.
    """
    locations(worldId: ID!, limit: Int = 10, offset: Int = 0): [Location!]!

    # Obtención de Facciones
    """
    Devuelve una facción específica por su ID.
    """
    faction(id: ID!): Faction

    """
    Devuelve una lista de facciones dentro de un mundo, con paginación opcional.
    """
    factions(worldId: ID!, limit: Int = 10, offset: Int = 0): [Faction!]!

    # Obtención de Eventos
    """
    Devuelve un evento específico por su ID.
    """
    event(id: ID!): Event

    """
    Devuelve una lista de eventos dentro de un mundo, con paginación opcional.
    """
    events(worldId: ID!, limit: Int = 10, offset: Int = 0): [Event!]!

    # Obtención de Mundos
    """
    Devuelve un mundo específico por su ID.
    """
    world(id: ID!): World

    """
    Devuelve una lista de mundos, con paginación opcional.
    """
    worlds(universeId: ID!, limit: Int = 10, offset: Int = 0): [World!]!

    # Obtención de Universos
    """
    Devuelve un universo específico por su ID.
    """
    universe(id: ID!): Universe

    """
    Devuelve una lista de universos, con paginación opcional.
    """
    universes(limit: Int = 10, offset: Int = 0): [Universe!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/type.base.graphqls", Input: `directive @goTag(key: String!, value: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

type Response {
    status: Boolean!
    message: String
}

interface Entity {
    id: ID!
    createdAt: String!
    updatedAt: String!
    name: String!
    description: String!
}
`, BuiltIn: false},
	{Name: "../../../graphql/Universe/input.graphqls", Input: `"""
Estructura para crear un nuevo universo.
"""
input CreateUniverseInput {
    """
    Nombre del universo.
    """
    name: String!

    """
    Descripción del universo, incluyendo historia y detalles generales.
    """
    description: String!

    """
    Año de creación o punto de referencia inicial del universo.
    """
    startYear: Int
}

"""
Estructura para actualizar un universo existente.
"""
input UpdateUniverseInput {
    """
    ID del universo a modificar.
    """
    id: ID!

    """
    Nuevo nombre del universo (opcional).
    """
    name: String

    """
    Nueva descripción del universo (opcional).
    """
    description: String

    """
    Modificar el año de inicio del universo (opcional).
    """
    startYear: Int

    """
    Indicar si el universo sigue en expansión o ha finalizado (opcional).
    """
    isActive: Boolean
}
`, BuiltIn: false},
	{Name: "../../../graphql/Universe/type.graphqls", Input: `"""
Representa un universo dentro del sistema de worldbuilding.
Un universo agrupa múltiples mundos y sus respectivas entidades.
"""
type Universe implements Entity {
    # Identificación y metadatos
    """
    Identificador único del universo.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creación del universo en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de última actualización del universo en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Información general
    """
    Nombre del universo.
    """
    name: String!

    """
    Descripción del universo, incluyendo su historia general y concepto.
    """
    description: String!

    """
    Año de creación o punto de partida del universo en el sistema.
    """
    startYear: Int!

    """
    Indica si el universo está activo o archivado.
    """
    isActive: Boolean!

    # Contenido del universo
    """
    Lista de mundos dentro de este universo.
    """
    worlds: [World!]!

    """
    Lista de facciones que operan en este universo.
    """
    factions: [Faction!]!

    """
    Lista de personajes que pertenecen a este universo.
    """
    characters: [Character!]!

    """
    Lista de criaturas que existen en este universo.
    """
    creatures: [Creature!]!

    """
    Lista de eventos importantes ocurridos en este universo.
    """
    events: [Event!]!

    """
    Lista de ubicaciones dentro de este universo.
    """
    locations: [Location!]!

    """
    Lista de ítems únicos o de importancia en el universo.
    """
    items: [Item!]!
}
`, BuiltIn: false},
	{Name: "../../../graphql/World/enum.graphqls", Input: `"""
Clasifica los mundos según su naturaleza, origen y características principales.
"""
enum WorldType {
    # Mundos físicos
    """
    Un mundo con características similares a la Tierra.
    """
    TERRESTRIAL

    """
    Un mundo desértico, árido y con escasez de agua.
    """
    DESERT

    """
    Un mundo oceánico con vastas masas de agua y pocas tierras emergidas.
    """
    OCEANIC

    """
    Un mundo cubierto de hielo y nieve con temperaturas extremas.
    """
    ICE

    """
    Un mundo volcánico, con actividad geológica intensa.
    """
    VOLCANIC

    """
    Un mundo gaseoso sin superficie sólida (tipo Júpiter o Saturno).
    """
    GAS_GIANT

    # Mundos sobrenaturales o interdimensionales
    """
    Un mundo conectado a lo divino o gobernado por entidades celestiales.
    """
    DIVINE_REALM

    """
    Un mundo demoníaco, caótico o infernal.
    """
    HELLISH

    """
    Un mundo de sueños, ilusiones o materialización del pensamiento.
    """
    DREAM_REALM

    """
    Un mundo que existe en múltiples dimensiones simultáneamente.
    """
    MULTIDIMENSIONAL

    """
    Un mundo artificialmente construido, como una megaestructura o nave-mundo.
    """
    ARTIFICIAL

    """
    Un mundo apocalíptico o en ruinas, con civilizaciones colapsadas.
    """
    POST_APOCALYPTIC

    """
    Un mundo que ha sido abandonado o en el que la vida ha desaparecido.
    """
    DEAD_WORLD
}

"""
Define la relación entre un mundo y un evento.
Puede representar desastres, descubrimientos, guerras y más.
"""
enum WorldEventRelation {
    """
    El evento ocurrió en este mundo.
    """
    OCCURRED_HERE

    """
    El evento llevó a la destrucción parcial o total del mundo.
    """
    DEVASTATED

    """
    El evento llevó al descubrimiento del mundo por otras civilizaciones.
    """
    DISCOVERED

    """
    El evento alteró la realidad o estructura del mundo de manera significativa.
    """
    ALTERED
}

"""
Define la relación entre dos mundos.
Puede representar conexiones interdimensionales, origen compartido y más.
"""
enum WorldWorldRelation {
    """
    Los mundos están conectados por portales, magia o tecnología avanzada.
    """
    CONNECTED

    """
    Un mundo es una versión alternativa o divergente del otro.
    """
    ALTERNATE_VERSION

    """
    Uno de los mundos fue creado artificialmente a partir del otro.
    """
    CREATED_FROM

    """
    Los mundos comparten un mismo origen cósmico o mitológico.
    """
    SHARED_ORIGIN
}
`, BuiltIn: false},
	{Name: "../../../graphql/World/input.graphqls", Input: `"""
Estructura para crear un nuevo mundo dentro de un universo.
"""
input CreateWorldInput {
    """
    ID del universo al que pertenece el mundo.
    """
    universeId: ID!

    """
    Nombre del mundo.
    """
    name: String!

    """
    Descripción detallada del mundo, incluyendo historia y características únicas.
    """
    description: String!

    """
    Clasificación del mundo según su naturaleza y origen.
    """
    type: WorldType!

    """
    Nivel tecnológico predominante en el mundo (medieval, avanzado, mágico, etc.).
    """
    technologyLevel: String!

    """
    Principales fuentes de energía utilizadas en el mundo.
    """
    energySources: [String!]!

    """
    Gravedad relativa del mundo en comparación con la Tierra (1.0 = gravedad terrestre).
    """
    gravity: Float!

    """
    Tamaño del mundo en relación a la Tierra (1.0 = tamaño terrestre).
    """
    size: Float!

    """
    Número de lunas o satélites naturales del mundo.
    """
    moons: Int!

    """
    Número de soles o estrellas alrededor de las cuales orbita el mundo.
    """
    stars: Int!

    """
    Clima predominante del mundo.
    """
    climate: String!

    """
    Ecosistema y bioma dominante del mundo.
    """
    ecosystem: String!

    """
    Indica si el mundo tiene atmósfera y si es respirable por humanos.
    """
    hasAtmosphere: Boolean!

    """
    Indica si el mundo está habitado por seres vivos.
    """
    isHabitable: Boolean!
}

"""
Estructura para actualizar un mundo existente.
"""
input UpdateWorldInput {
    """
    ID del mundo a modificar.
    """
    id: ID!

    """
    Nuevo nombre del mundo (opcional).
    """
    name: String

    """
    Nueva descripción del mundo (opcional).
    """
    description: String

    """
    Modificar la clasificación del mundo (opcional).
    """
    type: WorldType

    """
    Modificar el nivel tecnológico del mundo (opcional).
    """
    technologyLevel: String

    """
    Modificar las fuentes de energía utilizadas en el mundo (opcional).
    """
    energySources: [String!]

    """
    Modificar la gravedad del mundo (opcional).
    """
    gravity: Float

    """
    Modificar el tamaño del mundo en relación a la Tierra (opcional).
    """
    size: Float

    """
    Modificar el número de lunas del mundo (opcional).
    """
    moons: Int

    """
    Modificar el número de estrellas alrededor del mundo (opcional).
    """
    stars: Int

    """
    Modificar el clima del mundo (opcional).
    """
    climate: String

    """
    Modificar el ecosistema y bioma del mundo (opcional).
    """
    ecosystem: String

    """
    Modificar si el mundo tiene atmósfera y si es respirable (opcional).
    """
    hasAtmosphere: Boolean

    """
    Modificar si el mundo es habitable (opcional).
    """
    isHabitable: Boolean
}
`, BuiltIn: false},
	{Name: "../../../graphql/World/type.graphqls", Input: `"""
Representa un mundo dentro de un universo ficticio.
Incluye datos generales, características físicas y conexiones interdimensionales.
"""
type World implements Entity {
    # Identificación y metadatos
    """
    Identificador único del mundo.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    Fecha de creación del mundo en el sistema (ISO 8601).
    """
    createdAt: String!

    """
    Fecha de última actualización del mundo en el sistema (ISO 8601).
    """
    updatedAt: String!

    # Información general
    """
    Nombre del mundo.
    """
    name: String!

    """
    Descripción detallada del mundo, incluyendo su historia y características únicas.
    """
    description: String!

    """
    Clasificación del mundo según su naturaleza y origen.
    """
    type: WorldType!

    """
    El universo al que pertenece este mundo.
    """
    universe: Universe!

    """
    Nivel tecnológico predominante en el mundo (medieval, avanzado, mágico, etc.).
    """
    technologyLevel: String!

    """
    Principales fuentes de energía utilizadas en el mundo.
    """
    energySources: [String!]!

    """
    Gravedad relativa del mundo en comparación con la Tierra (1.0 = gravedad terrestre).
    """
    gravity: Float!

    """
    Tamaño del mundo en relación a la Tierra (1.0 = tamaño terrestre).
    """
    size: Float!

    """
    Número de lunas o satélites naturales del mundo.
    """
    moons: Int!

    """
    Número de soles o estrellas alrededor de las cuales orbita el mundo.
    """
    stars: Int!

    """
    Clima predominante del mundo.
    """
    climate: String!

    """
    Ecosistema y bioma dominante del mundo.
    """
    ecosystem: String!

    """
    Indica si el mundo tiene atmósfera y si es respirable por humanos.
    """
    hasAtmosphere: Boolean!

    """
    Indica si el mundo está habitado por seres vivos.
    """
    isHabitable: Boolean!

    # Relaciones con otras entidades
    """
    Lista de personajes asociados a este mundo.
    """
    characters: [CharacterWorld!]!

    """
    Lista de criaturas que existen o han existido en este mundo.
    """
    creatures: [CreatureWorld!]!

    """
    Lista de facciones con presencia o influencia en este mundo.
    """
    factions: [FactionWorld!]!

    """
    Lista de eventos importantes que han ocurrido en este mundo.
    """
    events: [WorldEvent!]!

    """
    Lista de ubicaciones dentro del mundo.
    """
    locations: [LocationWorld!]!

    """
    Lista de mundos conectados a este a través de portales o interacciones interdimensionales.
    """
    connectedWorlds: [WorldWorld!]!
}

"""
Define la relación entre un mundo y un evento.
Puede representar desastres, descubrimientos, guerras y más.
"""
type WorldEvent {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El mundo en el que ocurrió el evento.
    """
    world: World!
    """
    El evento con el que el mundo tiene una relación.
    """
    event: Event!

    """
    Tipo de relación entre el mundo y el evento (destrucción, descubrimiento, alteración, etc.).
    """
    relation: WorldEventRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}

"""
Define la relación entre dos mundos.
Puede representar conexiones interdimensionales, origen compartido y más.
"""
type WorldWorld {
    """
    El id de la relación entre personajes.
    """
    id: ID! @goTag(key: "json", value: "_key")

    """
    El otro mundo con el que se establece la relación.
    """
    world: World!

    """
    Tipo de relación entre ambos mundos (conectados, creados uno a partir del otro, etc.).
    """
    relation: WorldWorldRelation!

    """
    Fecha en que comenzó la relación (opcional).
    """
    startDate: String

    """
    Fecha en que terminó la relación (opcional).
    """
    endDate: String
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createCharacter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateCharacterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateCharacterInput2ordoᚑmapᚋgraphᚋmodelᚐCreateCharacterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createCreature_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateCreatureInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateCreatureInput2ordoᚑmapᚋgraphᚋmodelᚐCreateCreatureInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateEventInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateEventInput2ordoᚑmapᚋgraphᚋmodelᚐCreateEventInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createFaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateFactionInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateFactionInput2ordoᚑmapᚋgraphᚋmodelᚐCreateFactionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createItem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateItemInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateItemInput2ordoᚑmapᚋgraphᚋmodelᚐCreateItemInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createLocation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateLocationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateLocationInput2ordoᚑmapᚋgraphᚋmodelᚐCreateLocationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createUniverse_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateUniverseInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateUniverseInput2ordoᚑmapᚋgraphᚋmodelᚐCreateUniverseInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createWorld_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CreateWorldInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNCreateWorldInput2ordoᚑmapᚋgraphᚋmodelᚐCreateWorldInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteCharacter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteCreature_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteFaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteItem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteLocation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteUniverse_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteWorld_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCharacter_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateCharacterInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateCharacterInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateCharacterInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateCreature_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateCreatureInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateCreatureInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateCreatureInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateEvent_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateEventInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateEventInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateEventInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateFaction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateFactionInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateFactionInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateFactionInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateItem_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateItemInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateItemInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateItemInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateLocation_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateLocationInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateLocationInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateLocationInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUniverse_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateUniverseInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateUniverseInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateUniverseInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateWorld_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.UpdateWorldInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalNUpdateWorldInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateWorldInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_character_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_characters_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_creature_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_creatures_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_event_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_events_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_faction_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_factions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_item_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_items_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_location_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_locations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["worldId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["worldId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_universe_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_universes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_world_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_worlds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["universeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("universeId"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["universeId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["offset"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("offset"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["offset"] = arg2
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Character_id(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_name(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_description(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_type(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_birthDate(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_birthDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BirthDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_birthDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_height(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_weight(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_weight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_weight(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_isAlive(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_isAlive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_isAlive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_isMain(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_isMain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsMain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_isMain(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_alignment(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_alignment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alignment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Alignment)
	fc.Result = res
	return ec.marshalOAlignment2ᚖordoᚑmapᚋgraphᚋmodelᚐAlignment(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_alignment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Alignment does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_characters(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterCharacter)
	fc.Result = res
	return ec.marshalNCharacterCharacter2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterCharacterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterCharacter_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterCharacter_character(ctx, field)
			case "characterRelationLevel":
				return ec.fieldContext_CharacterCharacter_characterRelationLevel(ctx, field)
			case "familyRelation":
				return ec.fieldContext_CharacterCharacter_familyRelation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterCharacter_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterCharacter_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterCharacter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterCreature)
	fc.Result = res
	return ec.marshalNCharacterCreature2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterCreatureᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterCreature_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterCreature_character(ctx, field)
			case "creature":
				return ec.fieldContext_CharacterCreature_creature(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterCreature_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterCreature_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterCreature_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterCreature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_factions(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterFaction)
	fc.Result = res
	return ec.marshalNCharacterFaction2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterFactionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterFaction_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterFaction_character(ctx, field)
			case "faction":
				return ec.fieldContext_CharacterFaction_faction(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterFaction_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterFaction_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterFaction_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterFaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_events(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterEvent)
	fc.Result = res
	return ec.marshalNCharacterEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterEvent_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterEvent_character(ctx, field)
			case "event":
				return ec.fieldContext_CharacterEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_items(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterItem)
	fc.Result = res
	return ec.marshalNCharacterItem2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterItem_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterItem_character(ctx, field)
			case "item":
				return ec.fieldContext_CharacterItem_item(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterItem_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterItem_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterItem_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_locations(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterLocation)
	fc.Result = res
	return ec.marshalNCharacterLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterLocationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterLocation_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterLocation_character(ctx, field)
			case "location":
				return ec.fieldContext_CharacterLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Character_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Character) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Character_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterWorld)
	fc.Result = res
	return ec.marshalNCharacterWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterWorldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Character_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Character",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterWorld_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterWorld_character(ctx, field)
			case "world":
				return ec.fieldContext_CharacterWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_characterRelationLevel(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_characterRelationLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CharacterRelationLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterRelationLevel)
	fc.Result = res
	return ec.marshalNCharacterRelationLevel2ordoᚑmapᚋgraphᚋmodelᚐCharacterRelationLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_characterRelationLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterRelationLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_familyRelation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_familyRelation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FamilyRelation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FamilyRelation)
	fc.Result = res
	return ec.marshalOFamilyRelation2ᚖordoᚑmapᚋgraphᚋmodelᚐFamilyRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_familyRelation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FamilyRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCharacter_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCharacter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCharacter_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCharacter_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCharacter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_creature(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterCreatureRelation)
	fc.Result = res
	return ec.marshalNCharacterCreatureRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterCreatureRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterCreatureRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterCreature_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterCreature_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterCreature_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterEventRelation)
	fc.Result = res
	return ec.marshalNCharacterEventRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_faction(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterFactionRelation)
	fc.Result = res
	return ec.marshalNCharacterFactionRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterFactionRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterFactionRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterFaction_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterFaction_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterFaction_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_item(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterItemRelation)
	fc.Result = res
	return ec.marshalNCharacterItemRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterItemRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterItemRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterItem_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterItem_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterItem_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_location(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterLocationRelation)
	fc.Result = res
	return ec.marshalNCharacterLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterLocationRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterLocationRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterLocation_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterLocation_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterLocation_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_id(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_character(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Character, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_world(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_relation(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CharacterWorldRelation)
	fc.Result = res
	return ec.marshalNCharacterWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterWorldRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CharacterWorldRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CharacterWorld_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CharacterWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CharacterWorld_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CharacterWorld_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CharacterWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_id(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_name(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_description(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_type(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_species(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_species(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Species, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_species(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_intelligenceLevel(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_intelligenceLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntelligenceLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_intelligenceLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_height(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_height(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Height, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_height(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_weight(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_weight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_weight(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_birthDate(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_birthDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BirthDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_birthDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_isAlive(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_isAlive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsAlive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_isAlive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_lifespan(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_lifespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lifespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_lifespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_isUnique(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_isUnique(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsUnique, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_isUnique(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_habitat(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_habitat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Habitat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_habitat(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_behavior(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_behavior(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Behavior, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_behavior(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_diet(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_diet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Diet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_diet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_abilities(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_abilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Abilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_abilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_characters(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterCreature)
	fc.Result = res
	return ec.marshalNCharacterCreature2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterCreatureᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterCreature_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterCreature_character(ctx, field)
			case "creature":
				return ec.fieldContext_CharacterCreature_creature(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterCreature_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterCreature_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterCreature_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterCreature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureCreature)
	fc.Result = res
	return ec.marshalNCreatureCreature2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureCreatureᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureCreature_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureCreature_creature(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureCreature_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureCreature_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureCreature_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureCreature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_factions(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureFaction)
	fc.Result = res
	return ec.marshalNCreatureFaction2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureFactionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureFaction_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureFaction_creature(ctx, field)
			case "faction":
				return ec.fieldContext_CreatureFaction_faction(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureFaction_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureFaction_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureFaction_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureFaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_events(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureEvent)
	fc.Result = res
	return ec.marshalNCreatureEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureEvent_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureEvent_creature(ctx, field)
			case "event":
				return ec.fieldContext_CreatureEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_locations(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureLocation)
	fc.Result = res
	return ec.marshalNCreatureLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureLocationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureLocation_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureLocation_creature(ctx, field)
			case "location":
				return ec.fieldContext_CreatureLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Creature_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Creature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Creature_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureWorld)
	fc.Result = res
	return ec.marshalNCreatureWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureWorldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Creature_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Creature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureWorld_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureWorld_creature(ctx, field)
			case "world":
				return ec.fieldContext_CreatureWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureCreature_id(ctx context.Context, field graphql.CollectedField, obj *model.CreatureCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureCreature_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureCreature_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureCreature_creature(ctx context.Context, field graphql.CollectedField, obj *model.CreatureCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureCreature_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureCreature_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureCreature_relation(ctx context.Context, field graphql.CollectedField, obj *model.CreatureCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureCreature_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreatureCreatureRelation)
	fc.Result = res
	return ec.marshalNCreatureCreatureRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureCreatureRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureCreature_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreatureCreatureRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureCreature_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureCreature_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureCreature_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureCreature_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureCreature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureCreature_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureCreature_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureCreature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_creature(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreatureEventRelation)
	fc.Result = res
	return ec.marshalNCreatureEventRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreatureEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_id(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_creature(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_faction(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_relation(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreatureFactionRelation)
	fc.Result = res
	return ec.marshalNCreatureFactionRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureFactionRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreatureFactionRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureFaction_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureFaction_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureFaction_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_id(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_creature(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_location(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_relation(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreatureLocationRelation)
	fc.Result = res
	return ec.marshalNCreatureLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureLocationRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreatureLocationRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureLocation_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureLocation_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureLocation_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_id(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_creature(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_world(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_relation(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.CreatureWorldRelation)
	fc.Result = res
	return ec.marshalNCreatureWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureWorldRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CreatureWorldRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_startDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CreatureWorld_endDate(ctx context.Context, field graphql.CollectedField, obj *model.CreatureWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CreatureWorld_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CreatureWorld_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CreatureWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_name(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_description(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_type(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventType)
	fc.Result = res
	return ec.marshalNEventType2ordoᚑmapᚋgraphᚋmodelᚐEventType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_nature(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_nature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nature, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventNature)
	fc.Result = res
	return ec.marshalNEventNature2ordoᚑmapᚋgraphᚋmodelᚐEventNature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_nature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventNature does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_startDate(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_endDate(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_isRecurring(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_isRecurring(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRecurring, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_isRecurring(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_significance(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_significance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Significance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.EventSignificance)
	fc.Result = res
	return ec.marshalNEventSignificance2ordoᚑmapᚋgraphᚋmodelᚐEventSignificance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_significance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventSignificance does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_locations(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationEvent)
	fc.Result = res
	return ec.marshalNLocationEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐLocationEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationEvent_id(ctx, field)
			case "location":
				return ec.fieldContext_LocationEvent_location(ctx, field)
			case "event":
				return ec.fieldContext_LocationEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_LocationEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_LocationEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_LocationEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorldEvent)
	fc.Result = res
	return ec.marshalNWorldEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐWorldEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WorldEvent_id(ctx, field)
			case "world":
				return ec.fieldContext_WorldEvent_world(ctx, field)
			case "event":
				return ec.fieldContext_WorldEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_WorldEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_WorldEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_WorldEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorldEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_characters(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterEvent)
	fc.Result = res
	return ec.marshalNCharacterEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterEvent_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterEvent_character(ctx, field)
			case "event":
				return ec.fieldContext_CharacterEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureEvent)
	fc.Result = res
	return ec.marshalNCreatureEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureEvent_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureEvent_creature(ctx, field)
			case "event":
				return ec.fieldContext_CreatureEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_factions(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionEvent)
	fc.Result = res
	return ec.marshalNFactionEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionEvent_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionEvent_faction(ctx, field)
			case "event":
				return ec.fieldContext_FactionEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_FactionEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_items(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ItemEvent)
	fc.Result = res
	return ec.marshalNItemEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐItemEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ItemEvent_id(ctx, field)
			case "item":
				return ec.fieldContext_ItemEvent_item(ctx, field)
			case "event":
				return ec.fieldContext_ItemEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_ItemEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_ItemEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_ItemEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_relatedEvents(ctx context.Context, field graphql.CollectedField, obj *model.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_relatedEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedEvents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.EventEvent)
	fc.Result = res
	return ec.marshalNEventEvent2ᚕordoᚑmapᚋgraphᚋmodelᚐEventEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_relatedEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type EventEvent does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_id(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_name(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_description(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_type(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionType)
	fc.Result = res
	return ec.marshalNFactionType2ordoᚑmapᚋgraphᚋmodelᚐFactionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_ideology(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_ideology(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ideology, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_ideology(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_status(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionStatus)
	fc.Result = res
	return ec.marshalNFactionStatus2ordoᚑmapᚋgraphᚋmodelᚐFactionStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_foundedDate(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_foundedDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FoundedDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_foundedDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_disbandedDate(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_disbandedDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisbandedDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_disbandedDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_influence(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_influence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Influence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionInfluence)
	fc.Result = res
	return ec.marshalNFactionInfluence2ordoᚑmapᚋgraphᚋmodelᚐFactionInfluence(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_influence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionInfluence does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_locations(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionLocation)
	fc.Result = res
	return ec.marshalNFactionLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionLocationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionLocation_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionLocation_faction(ctx, field)
			case "location":
				return ec.fieldContext_FactionLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_FactionLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionWorld)
	fc.Result = res
	return ec.marshalNFactionWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionWorldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionWorld_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionWorld_faction(ctx, field)
			case "world":
				return ec.fieldContext_FactionWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_FactionWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_characters(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterFaction)
	fc.Result = res
	return ec.marshalNCharacterFaction2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterFactionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterFaction_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterFaction_character(ctx, field)
			case "faction":
				return ec.fieldContext_CharacterFaction_faction(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterFaction_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterFaction_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterFaction_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterFaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureFaction)
	fc.Result = res
	return ec.marshalNCreatureFaction2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureFactionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureFaction_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureFaction_creature(ctx, field)
			case "faction":
				return ec.fieldContext_CreatureFaction_faction(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureFaction_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureFaction_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureFaction_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureFaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_factions(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionFaction)
	fc.Result = res
	return ec.marshalNFactionFaction2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionFactionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionFaction_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionFaction_faction(ctx, field)
			case "relation":
				return ec.fieldContext_FactionFaction_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionFaction_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionFaction_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionFaction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_events(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionEvent)
	fc.Result = res
	return ec.marshalNFactionEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionEvent_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionEvent_faction(ctx, field)
			case "event":
				return ec.fieldContext_FactionEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_FactionEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Faction_items(ctx context.Context, field graphql.CollectedField, obj *model.Faction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Faction_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionItem)
	fc.Result = res
	return ec.marshalNFactionItem2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Faction_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Faction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionItem_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionItem_faction(ctx, field)
			case "item":
				return ec.fieldContext_FactionItem_item(ctx, field)
			case "relation":
				return ec.fieldContext_FactionItem_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionItem_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionItem_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_faction(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionEventRelation)
	fc.Result = res
	return ec.marshalNFactionEventRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionFaction_id(ctx context.Context, field graphql.CollectedField, obj *model.FactionFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionFaction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionFaction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionFaction_faction(ctx context.Context, field graphql.CollectedField, obj *model.FactionFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionFaction_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionFaction_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionFaction_relation(ctx context.Context, field graphql.CollectedField, obj *model.FactionFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionFaction_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionFactionRelation)
	fc.Result = res
	return ec.marshalNFactionFactionRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionFactionRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionFaction_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionFactionRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionFaction_startDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionFaction_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionFaction_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionFaction_endDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionFaction) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionFaction_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionFaction_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionFaction",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_id(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_faction(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_item(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_relation(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionItemRelation)
	fc.Result = res
	return ec.marshalNFactionItemRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionItemRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionItemRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_startDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionItem_endDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionItem_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionItem_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_id(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_faction(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_location(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_relation(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionLocationRelation)
	fc.Result = res
	return ec.marshalNFactionLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionLocationRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionLocationRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_startDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionLocation_endDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionLocation_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionLocation_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_id(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_faction(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Faction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_world(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_relation(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.FactionWorldRelation)
	fc.Result = res
	return ec.marshalNFactionWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionWorldRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FactionWorldRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_startDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FactionWorld_endDate(ctx context.Context, field graphql.CollectedField, obj *model.FactionWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FactionWorld_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FactionWorld_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FactionWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_id(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_name(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_description(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_type(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemType)
	fc.Result = res
	return ec.marshalNItemType2ordoᚑmapᚋgraphᚋmodelᚐItemType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_rarity(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_rarity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rarity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemRarity)
	fc.Result = res
	return ec.marshalNItemRarity2ordoᚑmapᚋgraphᚋmodelᚐItemRarity(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_rarity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemRarity does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_slot(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_slot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemSlot)
	fc.Result = res
	return ec.marshalNItemSlot2ordoᚑmapᚋgraphᚋmodelᚐItemSlot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_slot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemSlot does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_material(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_material(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Material, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_material(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_condition(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_condition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Condition, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemCondition)
	fc.Result = res
	return ec.marshalNItemCondition2ordoᚑmapᚋgraphᚋmodelᚐItemCondition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_condition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemCondition does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_weight(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_weight(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_weight(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_dimensions(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_dimensions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dimensions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_dimensions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_creationDate(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_creationDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_creationDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_destructionDate(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_destructionDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DestructionDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_destructionDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_isMagical(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_isMagical(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsMagical, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_isMagical(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_abilities(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_abilities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Abilities, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_abilities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_value(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_characters(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterItem)
	fc.Result = res
	return ec.marshalNCharacterItem2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterItem_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterItem_character(ctx, field)
			case "item":
				return ec.fieldContext_CharacterItem_item(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterItem_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterItem_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterItem_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_factions(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionItem)
	fc.Result = res
	return ec.marshalNFactionItem2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionItem_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionItem_faction(ctx, field)
			case "item":
				return ec.fieldContext_FactionItem_item(ctx, field)
			case "relation":
				return ec.fieldContext_FactionItem_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionItem_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionItem_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_events(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ItemEvent)
	fc.Result = res
	return ec.marshalNItemEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐItemEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ItemEvent_id(ctx, field)
			case "item":
				return ec.fieldContext_ItemEvent_item(ctx, field)
			case "event":
				return ec.fieldContext_ItemEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_ItemEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_ItemEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_ItemEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_locations(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ItemLocation)
	fc.Result = res
	return ec.marshalNItemLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐItemLocationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ItemLocation_id(ctx, field)
			case "item":
				return ec.fieldContext_ItemLocation_item(ctx, field)
			case "with":
				return ec.fieldContext_ItemLocation_with(ctx, field)
			case "relation":
				return ec.fieldContext_ItemLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_ItemLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_ItemLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_relatedItems(ctx context.Context, field graphql.CollectedField, obj *model.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_relatedItems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedItems, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ItemItem)
	fc.Result = res
	return ec.marshalNItemItem2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐItemItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_relatedItems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ItemItem_id(ctx, field)
			case "item":
				return ec.fieldContext_ItemItem_item(ctx, field)
			case "relation":
				return ec.fieldContext_ItemItem_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_ItemItem_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_ItemItem_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_item(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemEventRelation)
	fc.Result = res
	return ec.marshalNItemEventRelation2ordoᚑmapᚋgraphᚋmodelᚐItemEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemItem_id(ctx context.Context, field graphql.CollectedField, obj *model.ItemItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemItem_item(ctx context.Context, field graphql.CollectedField, obj *model.ItemItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemItem_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemItem_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemItem_relation(ctx context.Context, field graphql.CollectedField, obj *model.ItemItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemItem_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemItemRelation)
	fc.Result = res
	return ec.marshalNItemItemRelation2ordoᚑmapᚋgraphᚋmodelᚐItemItemRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemItem_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemItemRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemItem_startDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemItem_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemItem_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemItem_endDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemItem_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemItem_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_id(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_item(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_with(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_with(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.With, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_with(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_relation(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.ItemLocationRelation)
	fc.Result = res
	return ec.marshalNItemLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐItemLocationRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemLocationRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_startDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemLocation_endDate(ctx context.Context, field graphql.CollectedField, obj *model.ItemLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemLocation_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemLocation_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_id(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_name(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_description(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_type(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LocationType)
	fc.Result = res
	return ec.marshalNLocationType2ordoᚑmapᚋgraphᚋmodelᚐLocationType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LocationType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_region(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_region(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Region, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_region(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_coordinates(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_coordinates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Coordinates, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_coordinates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_accessibility(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_accessibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accessibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LocationAccessibility)
	fc.Result = res
	return ec.marshalNLocationAccessibility2ordoᚑmapᚋgraphᚋmodelᚐLocationAccessibility(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_accessibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LocationAccessibility does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_isNatural(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_isNatural(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsNatural, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_isNatural(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_climate(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_climate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Climate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_climate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_ecosystem(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_ecosystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ecosystem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_ecosystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_characters(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterLocation)
	fc.Result = res
	return ec.marshalNCharacterLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterLocationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterLocation_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterLocation_character(ctx, field)
			case "location":
				return ec.fieldContext_CharacterLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureLocation)
	fc.Result = res
	return ec.marshalNCreatureLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureLocationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureLocation_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureLocation_creature(ctx, field)
			case "location":
				return ec.fieldContext_CreatureLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_factions(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionLocation)
	fc.Result = res
	return ec.marshalNFactionLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionLocationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionLocation_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionLocation_faction(ctx, field)
			case "location":
				return ec.fieldContext_FactionLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_FactionLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_events(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationEvent)
	fc.Result = res
	return ec.marshalNLocationEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐLocationEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationEvent_id(ctx, field)
			case "location":
				return ec.fieldContext_LocationEvent_location(ctx, field)
			case "event":
				return ec.fieldContext_LocationEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_LocationEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_LocationEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_LocationEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_items(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ItemLocation)
	fc.Result = res
	return ec.marshalNItemLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐItemLocationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ItemLocation_id(ctx, field)
			case "item":
				return ec.fieldContext_ItemLocation_item(ctx, field)
			case "with":
				return ec.fieldContext_ItemLocation_with(ctx, field)
			case "relation":
				return ec.fieldContext_ItemLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_ItemLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_ItemLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_relatedLocations(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_relatedLocations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RelatedLocations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationLocation)
	fc.Result = res
	return ec.marshalNLocationLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐLocationLocationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_relatedLocations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationLocation_id(ctx, field)
			case "location":
				return ec.fieldContext_LocationLocation_location(ctx, field)
			case "relation":
				return ec.fieldContext_LocationLocation_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_LocationLocation_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_LocationLocation_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationLocation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Location_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Location) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Location_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationWorld)
	fc.Result = res
	return ec.marshalNLocationWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐLocationWorldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Location_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Location",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationWorld_id(ctx, field)
			case "location":
				return ec.fieldContext_LocationWorld_location(ctx, field)
			case "world":
				return ec.fieldContext_LocationWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_LocationWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_LocationWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_LocationWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_location(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LocationEventRelation)
	fc.Result = res
	return ec.marshalNLocationEventRelation2ordoᚑmapᚋgraphᚋmodelᚐLocationEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LocationEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationLocation_id(ctx context.Context, field graphql.CollectedField, obj *model.LocationLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationLocation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationLocation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationLocation_location(ctx context.Context, field graphql.CollectedField, obj *model.LocationLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationLocation_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationLocation_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationLocation_relation(ctx context.Context, field graphql.CollectedField, obj *model.LocationLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationLocation_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LocationLocationRelation)
	fc.Result = res
	return ec.marshalNLocationLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐLocationLocationRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationLocation_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LocationLocationRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationLocation_startDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationLocation_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationLocation_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationLocation_endDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationLocation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationLocation_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationLocation_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationLocation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_id(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_location(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Location, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_world(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_relation(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LocationWorldRelation)
	fc.Result = res
	return ec.marshalNLocationWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐLocationWorldRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LocationWorldRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_startDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LocationWorld_endDate(ctx context.Context, field graphql.CollectedField, obj *model.LocationWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LocationWorld_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LocationWorld_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LocationWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCharacter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCharacter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCharacter(rctx, fc.Args["input"].(model.CreateCharacterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCharacter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCharacter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCharacter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCharacter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateCharacter(rctx, fc.Args["input"].(model.UpdateCharacterInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCharacter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCharacter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteCharacter(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteCharacter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteCharacter(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteCharacter(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteCharacter_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createCreature(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createCreature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCreature(rctx, fc.Args["input"].(model.CreateCreatureInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createCreature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createCreature_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateCreature(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateCreature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateCreature(rctx, fc.Args["input"].(model.UpdateCreatureInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateCreature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateCreature_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteCreature(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteCreature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteCreature(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteCreature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteCreature_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateItem(rctx, fc.Args["input"].(model.CreateItemInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateItem(rctx, fc.Args["input"].(model.UpdateItemInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalNItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteItem(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteItem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteItem(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteItem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteItem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createLocation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createLocation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateLocation(rctx, fc.Args["input"].(model.CreateLocationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createLocation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createLocation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateLocation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateLocation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateLocation(rctx, fc.Args["input"].(model.UpdateLocationInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateLocation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateLocation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteLocation(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteLocation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteLocation(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteLocation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteLocation_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createFaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createFaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateFaction(rctx, fc.Args["input"].(model.CreateFactionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createFaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createFaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateFaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateFaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateFaction(rctx, fc.Args["input"].(model.UpdateFactionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateFaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateFaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteFaction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteFaction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteFaction(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteFaction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteFaction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateEvent(rctx, fc.Args["input"].(model.CreateEventInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateEvent(rctx, fc.Args["input"].(model.UpdateEventInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteEvent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteEvent(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteEvent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteEvent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createWorld(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createWorld(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateWorld(rctx, fc.Args["input"].(model.CreateWorldInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createWorld(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createWorld_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateWorld(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateWorld(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateWorld(rctx, fc.Args["input"].(model.UpdateWorldInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateWorld(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateWorld_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteWorld(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteWorld(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteWorld(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteWorld(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteWorld_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createUniverse(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createUniverse(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateUniverse(rctx, fc.Args["input"].(model.CreateUniverseInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Universe)
	fc.Result = res
	return ec.marshalNUniverse2ᚖordoᚑmapᚋgraphᚋmodelᚐUniverse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createUniverse(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Universe_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Universe_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Universe_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Universe_name(ctx, field)
			case "description":
				return ec.fieldContext_Universe_description(ctx, field)
			case "startYear":
				return ec.fieldContext_Universe_startYear(ctx, field)
			case "isActive":
				return ec.fieldContext_Universe_isActive(ctx, field)
			case "worlds":
				return ec.fieldContext_Universe_worlds(ctx, field)
			case "factions":
				return ec.fieldContext_Universe_factions(ctx, field)
			case "characters":
				return ec.fieldContext_Universe_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Universe_creatures(ctx, field)
			case "events":
				return ec.fieldContext_Universe_events(ctx, field)
			case "locations":
				return ec.fieldContext_Universe_locations(ctx, field)
			case "items":
				return ec.fieldContext_Universe_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Universe", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createUniverse_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUniverse(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUniverse(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUniverse(rctx, fc.Args["input"].(model.UpdateUniverseInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Universe)
	fc.Result = res
	return ec.marshalNUniverse2ᚖordoᚑmapᚋgraphᚋmodelᚐUniverse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUniverse(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Universe_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Universe_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Universe_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Universe_name(ctx, field)
			case "description":
				return ec.fieldContext_Universe_description(ctx, field)
			case "startYear":
				return ec.fieldContext_Universe_startYear(ctx, field)
			case "isActive":
				return ec.fieldContext_Universe_isActive(ctx, field)
			case "worlds":
				return ec.fieldContext_Universe_worlds(ctx, field)
			case "factions":
				return ec.fieldContext_Universe_factions(ctx, field)
			case "characters":
				return ec.fieldContext_Universe_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Universe_creatures(ctx, field)
			case "events":
				return ec.fieldContext_Universe_events(ctx, field)
			case "locations":
				return ec.fieldContext_Universe_locations(ctx, field)
			case "items":
				return ec.fieldContext_Universe_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Universe", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUniverse_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteUniverse(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteUniverse(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteUniverse(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteUniverse(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteUniverse_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_character(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_character(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Character(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Character)
	fc.Result = res
	return ec.marshalOCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_character(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_character_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_characters(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Characters(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_characters_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_creature(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_creature(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Creature(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Creature)
	fc.Result = res
	return ec.marshalOCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_creature(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_creature_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_creatures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Creatures(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_creatures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_item(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Item(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_item_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_items(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Items(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Item)
	fc.Result = res
	return ec.marshalNItem2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_items_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_location(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_location(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Location(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Location)
	fc.Result = res
	return ec.marshalOLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_location(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_location_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_locations(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Locations(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐLocationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_locations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_faction(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_faction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Faction(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Faction)
	fc.Result = res
	return ec.marshalOFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_faction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_faction_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_factions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Factions(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_factions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_event(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Event(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalOEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_event_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_events(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Events(rctx, fc.Args["worldId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_world(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().World(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalOWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_world_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_worlds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Worlds(rctx, fc.Args["universeId"].(string), fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.World)
	fc.Result = res
	return ec.marshalNWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐWorldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_worlds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_universe(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_universe(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Universe(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Universe)
	fc.Result = res
	return ec.marshalOUniverse2ᚖordoᚑmapᚋgraphᚋmodelᚐUniverse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_universe(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Universe_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Universe_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Universe_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Universe_name(ctx, field)
			case "description":
				return ec.fieldContext_Universe_description(ctx, field)
			case "startYear":
				return ec.fieldContext_Universe_startYear(ctx, field)
			case "isActive":
				return ec.fieldContext_Universe_isActive(ctx, field)
			case "worlds":
				return ec.fieldContext_Universe_worlds(ctx, field)
			case "factions":
				return ec.fieldContext_Universe_factions(ctx, field)
			case "characters":
				return ec.fieldContext_Universe_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Universe_creatures(ctx, field)
			case "events":
				return ec.fieldContext_Universe_events(ctx, field)
			case "locations":
				return ec.fieldContext_Universe_locations(ctx, field)
			case "items":
				return ec.fieldContext_Universe_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Universe", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_universe_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_universes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_universes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Universes(rctx, fc.Args["limit"].(*int), fc.Args["offset"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Universe)
	fc.Result = res
	return ec.marshalNUniverse2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐUniverseᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_universes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Universe_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Universe_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Universe_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Universe_name(ctx, field)
			case "description":
				return ec.fieldContext_Universe_description(ctx, field)
			case "startYear":
				return ec.fieldContext_Universe_startYear(ctx, field)
			case "isActive":
				return ec.fieldContext_Universe_isActive(ctx, field)
			case "worlds":
				return ec.fieldContext_Universe_worlds(ctx, field)
			case "factions":
				return ec.fieldContext_Universe_factions(ctx, field)
			case "characters":
				return ec.fieldContext_Universe_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Universe_creatures(ctx, field)
			case "events":
				return ec.fieldContext_Universe_events(ctx, field)
			case "locations":
				return ec.fieldContext_Universe_locations(ctx, field)
			case "items":
				return ec.fieldContext_Universe_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Universe", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_universes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_status(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Response_message(ctx context.Context, field graphql.CollectedField, obj *model.Response) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Response_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Response_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Response",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_id(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_name(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_description(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_startYear(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_startYear(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartYear, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_startYear(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_isActive(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_isActive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_isActive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_worlds(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_worlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Worlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.World)
	fc.Result = res
	return ec.marshalNWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐWorldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_worlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_factions(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Faction)
	fc.Result = res
	return ec.marshalNFaction2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Faction_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Faction_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Faction_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Faction_name(ctx, field)
			case "description":
				return ec.fieldContext_Faction_description(ctx, field)
			case "type":
				return ec.fieldContext_Faction_type(ctx, field)
			case "ideology":
				return ec.fieldContext_Faction_ideology(ctx, field)
			case "status":
				return ec.fieldContext_Faction_status(ctx, field)
			case "foundedDate":
				return ec.fieldContext_Faction_foundedDate(ctx, field)
			case "disbandedDate":
				return ec.fieldContext_Faction_disbandedDate(ctx, field)
			case "influence":
				return ec.fieldContext_Faction_influence(ctx, field)
			case "locations":
				return ec.fieldContext_Faction_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Faction_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Faction_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Faction_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Faction_factions(ctx, field)
			case "events":
				return ec.fieldContext_Faction_events(ctx, field)
			case "items":
				return ec.fieldContext_Faction_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Faction", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_characters(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Character)
	fc.Result = res
	return ec.marshalNCharacter2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Character_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Character_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Character_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Character_name(ctx, field)
			case "description":
				return ec.fieldContext_Character_description(ctx, field)
			case "type":
				return ec.fieldContext_Character_type(ctx, field)
			case "birthDate":
				return ec.fieldContext_Character_birthDate(ctx, field)
			case "height":
				return ec.fieldContext_Character_height(ctx, field)
			case "weight":
				return ec.fieldContext_Character_weight(ctx, field)
			case "isAlive":
				return ec.fieldContext_Character_isAlive(ctx, field)
			case "isMain":
				return ec.fieldContext_Character_isMain(ctx, field)
			case "alignment":
				return ec.fieldContext_Character_alignment(ctx, field)
			case "characters":
				return ec.fieldContext_Character_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Character_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Character_factions(ctx, field)
			case "events":
				return ec.fieldContext_Character_events(ctx, field)
			case "items":
				return ec.fieldContext_Character_items(ctx, field)
			case "locations":
				return ec.fieldContext_Character_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Character_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Character", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_creatures(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Creature)
	fc.Result = res
	return ec.marshalNCreature2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Creature_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Creature_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Creature_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Creature_name(ctx, field)
			case "description":
				return ec.fieldContext_Creature_description(ctx, field)
			case "type":
				return ec.fieldContext_Creature_type(ctx, field)
			case "species":
				return ec.fieldContext_Creature_species(ctx, field)
			case "intelligenceLevel":
				return ec.fieldContext_Creature_intelligenceLevel(ctx, field)
			case "height":
				return ec.fieldContext_Creature_height(ctx, field)
			case "weight":
				return ec.fieldContext_Creature_weight(ctx, field)
			case "birthDate":
				return ec.fieldContext_Creature_birthDate(ctx, field)
			case "isAlive":
				return ec.fieldContext_Creature_isAlive(ctx, field)
			case "lifespan":
				return ec.fieldContext_Creature_lifespan(ctx, field)
			case "isUnique":
				return ec.fieldContext_Creature_isUnique(ctx, field)
			case "habitat":
				return ec.fieldContext_Creature_habitat(ctx, field)
			case "behavior":
				return ec.fieldContext_Creature_behavior(ctx, field)
			case "diet":
				return ec.fieldContext_Creature_diet(ctx, field)
			case "abilities":
				return ec.fieldContext_Creature_abilities(ctx, field)
			case "characters":
				return ec.fieldContext_Creature_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Creature_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Creature_factions(ctx, field)
			case "events":
				return ec.fieldContext_Creature_events(ctx, field)
			case "locations":
				return ec.fieldContext_Creature_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Creature_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Creature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_events(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_locations(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Location)
	fc.Result = res
	return ec.marshalNLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐLocationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Location_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Location_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Location_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Location_name(ctx, field)
			case "description":
				return ec.fieldContext_Location_description(ctx, field)
			case "type":
				return ec.fieldContext_Location_type(ctx, field)
			case "region":
				return ec.fieldContext_Location_region(ctx, field)
			case "coordinates":
				return ec.fieldContext_Location_coordinates(ctx, field)
			case "accessibility":
				return ec.fieldContext_Location_accessibility(ctx, field)
			case "isNatural":
				return ec.fieldContext_Location_isNatural(ctx, field)
			case "climate":
				return ec.fieldContext_Location_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_Location_ecosystem(ctx, field)
			case "characters":
				return ec.fieldContext_Location_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Location_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Location_factions(ctx, field)
			case "events":
				return ec.fieldContext_Location_events(ctx, field)
			case "items":
				return ec.fieldContext_Location_items(ctx, field)
			case "relatedLocations":
				return ec.fieldContext_Location_relatedLocations(ctx, field)
			case "worlds":
				return ec.fieldContext_Location_worlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Location", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Universe_items(ctx context.Context, field graphql.CollectedField, obj *model.Universe) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Universe_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Item)
	fc.Result = res
	return ec.marshalNItem2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Universe_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Universe",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Item_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Item_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "description":
				return ec.fieldContext_Item_description(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "rarity":
				return ec.fieldContext_Item_rarity(ctx, field)
			case "slot":
				return ec.fieldContext_Item_slot(ctx, field)
			case "material":
				return ec.fieldContext_Item_material(ctx, field)
			case "condition":
				return ec.fieldContext_Item_condition(ctx, field)
			case "weight":
				return ec.fieldContext_Item_weight(ctx, field)
			case "dimensions":
				return ec.fieldContext_Item_dimensions(ctx, field)
			case "creationDate":
				return ec.fieldContext_Item_creationDate(ctx, field)
			case "destructionDate":
				return ec.fieldContext_Item_destructionDate(ctx, field)
			case "isMagical":
				return ec.fieldContext_Item_isMagical(ctx, field)
			case "abilities":
				return ec.fieldContext_Item_abilities(ctx, field)
			case "value":
				return ec.fieldContext_Item_value(ctx, field)
			case "characters":
				return ec.fieldContext_Item_characters(ctx, field)
			case "factions":
				return ec.fieldContext_Item_factions(ctx, field)
			case "events":
				return ec.fieldContext_Item_events(ctx, field)
			case "locations":
				return ec.fieldContext_Item_locations(ctx, field)
			case "relatedItems":
				return ec.fieldContext_Item_relatedItems(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_id(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_name(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_description(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_type(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.WorldType)
	fc.Result = res
	return ec.marshalNWorldType2ordoᚑmapᚋgraphᚋmodelᚐWorldType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorldType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_universe(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_universe(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Universe, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Universe)
	fc.Result = res
	return ec.marshalNUniverse2ᚖordoᚑmapᚋgraphᚋmodelᚐUniverse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_universe(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Universe_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Universe_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Universe_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Universe_name(ctx, field)
			case "description":
				return ec.fieldContext_Universe_description(ctx, field)
			case "startYear":
				return ec.fieldContext_Universe_startYear(ctx, field)
			case "isActive":
				return ec.fieldContext_Universe_isActive(ctx, field)
			case "worlds":
				return ec.fieldContext_Universe_worlds(ctx, field)
			case "factions":
				return ec.fieldContext_Universe_factions(ctx, field)
			case "characters":
				return ec.fieldContext_Universe_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Universe_creatures(ctx, field)
			case "events":
				return ec.fieldContext_Universe_events(ctx, field)
			case "locations":
				return ec.fieldContext_Universe_locations(ctx, field)
			case "items":
				return ec.fieldContext_Universe_items(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Universe", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_technologyLevel(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_technologyLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TechnologyLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_technologyLevel(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_energySources(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_energySources(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnergySources, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_energySources(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_gravity(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_gravity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gravity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_gravity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_size(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_moons(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_moons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Moons, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_moons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_stars(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_stars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_stars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_climate(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_climate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Climate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_climate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_ecosystem(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_ecosystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ecosystem, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_ecosystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_hasAtmosphere(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_hasAtmosphere(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasAtmosphere, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_hasAtmosphere(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_isHabitable(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_isHabitable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsHabitable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_isHabitable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_characters(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_characters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Characters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CharacterWorld)
	fc.Result = res
	return ec.marshalNCharacterWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterWorldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_characters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CharacterWorld_id(ctx, field)
			case "character":
				return ec.fieldContext_CharacterWorld_character(ctx, field)
			case "world":
				return ec.fieldContext_CharacterWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_CharacterWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CharacterWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CharacterWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CharacterWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_creatures(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_creatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Creatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CreatureWorld)
	fc.Result = res
	return ec.marshalNCreatureWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureWorldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_creatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CreatureWorld_id(ctx, field)
			case "creature":
				return ec.fieldContext_CreatureWorld_creature(ctx, field)
			case "world":
				return ec.fieldContext_CreatureWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_CreatureWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_CreatureWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_CreatureWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CreatureWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_factions(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_factions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FactionWorld)
	fc.Result = res
	return ec.marshalNFactionWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionWorldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_factions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FactionWorld_id(ctx, field)
			case "faction":
				return ec.fieldContext_FactionWorld_faction(ctx, field)
			case "world":
				return ec.fieldContext_FactionWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_FactionWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_FactionWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_FactionWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FactionWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_events(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Events, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorldEvent)
	fc.Result = res
	return ec.marshalNWorldEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐWorldEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WorldEvent_id(ctx, field)
			case "world":
				return ec.fieldContext_WorldEvent_world(ctx, field)
			case "event":
				return ec.fieldContext_WorldEvent_event(ctx, field)
			case "relation":
				return ec.fieldContext_WorldEvent_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_WorldEvent_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_WorldEvent_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorldEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_locations(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.LocationWorld)
	fc.Result = res
	return ec.marshalNLocationWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐLocationWorldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LocationWorld_id(ctx, field)
			case "location":
				return ec.fieldContext_LocationWorld_location(ctx, field)
			case "world":
				return ec.fieldContext_LocationWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_LocationWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_LocationWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_LocationWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LocationWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _World_connectedWorlds(ctx context.Context, field graphql.CollectedField, obj *model.World) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_World_connectedWorlds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConnectedWorlds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.WorldWorld)
	fc.Result = res
	return ec.marshalNWorldWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐWorldWorldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_World_connectedWorlds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "World",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WorldWorld_id(ctx, field)
			case "world":
				return ec.fieldContext_WorldWorld_world(ctx, field)
			case "relation":
				return ec.fieldContext_WorldWorld_relation(ctx, field)
			case "startDate":
				return ec.fieldContext_WorldWorld_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_WorldWorld_endDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorldWorld", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_id(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_world(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_event(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_event(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Event, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Event)
	fc.Result = res
	return ec.marshalNEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_event(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Event_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_Event_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_Event_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_Event_name(ctx, field)
			case "description":
				return ec.fieldContext_Event_description(ctx, field)
			case "type":
				return ec.fieldContext_Event_type(ctx, field)
			case "nature":
				return ec.fieldContext_Event_nature(ctx, field)
			case "startDate":
				return ec.fieldContext_Event_startDate(ctx, field)
			case "endDate":
				return ec.fieldContext_Event_endDate(ctx, field)
			case "isRecurring":
				return ec.fieldContext_Event_isRecurring(ctx, field)
			case "significance":
				return ec.fieldContext_Event_significance(ctx, field)
			case "locations":
				return ec.fieldContext_Event_locations(ctx, field)
			case "worlds":
				return ec.fieldContext_Event_worlds(ctx, field)
			case "characters":
				return ec.fieldContext_Event_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_Event_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_Event_factions(ctx, field)
			case "items":
				return ec.fieldContext_Event_items(ctx, field)
			case "relatedEvents":
				return ec.fieldContext_Event_relatedEvents(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Event", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_relation(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.WorldEventRelation)
	fc.Result = res
	return ec.marshalNWorldEventRelation2ordoᚑmapᚋgraphᚋmodelᚐWorldEventRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorldEventRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_startDate(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldEvent_endDate(ctx context.Context, field graphql.CollectedField, obj *model.WorldEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldEvent_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldEvent_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldWorld_id(ctx context.Context, field graphql.CollectedField, obj *model.WorldWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldWorld_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldWorld_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldWorld_world(ctx context.Context, field graphql.CollectedField, obj *model.WorldWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldWorld_world(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.World, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.World)
	fc.Result = res
	return ec.marshalNWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldWorld_world(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_World_id(ctx, field)
			case "createdAt":
				return ec.fieldContext_World_createdAt(ctx, field)
			case "updatedAt":
				return ec.fieldContext_World_updatedAt(ctx, field)
			case "name":
				return ec.fieldContext_World_name(ctx, field)
			case "description":
				return ec.fieldContext_World_description(ctx, field)
			case "type":
				return ec.fieldContext_World_type(ctx, field)
			case "universe":
				return ec.fieldContext_World_universe(ctx, field)
			case "technologyLevel":
				return ec.fieldContext_World_technologyLevel(ctx, field)
			case "energySources":
				return ec.fieldContext_World_energySources(ctx, field)
			case "gravity":
				return ec.fieldContext_World_gravity(ctx, field)
			case "size":
				return ec.fieldContext_World_size(ctx, field)
			case "moons":
				return ec.fieldContext_World_moons(ctx, field)
			case "stars":
				return ec.fieldContext_World_stars(ctx, field)
			case "climate":
				return ec.fieldContext_World_climate(ctx, field)
			case "ecosystem":
				return ec.fieldContext_World_ecosystem(ctx, field)
			case "hasAtmosphere":
				return ec.fieldContext_World_hasAtmosphere(ctx, field)
			case "isHabitable":
				return ec.fieldContext_World_isHabitable(ctx, field)
			case "characters":
				return ec.fieldContext_World_characters(ctx, field)
			case "creatures":
				return ec.fieldContext_World_creatures(ctx, field)
			case "factions":
				return ec.fieldContext_World_factions(ctx, field)
			case "events":
				return ec.fieldContext_World_events(ctx, field)
			case "locations":
				return ec.fieldContext_World_locations(ctx, field)
			case "connectedWorlds":
				return ec.fieldContext_World_connectedWorlds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type World", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldWorld_relation(ctx context.Context, field graphql.CollectedField, obj *model.WorldWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldWorld_relation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.WorldWorldRelation)
	fc.Result = res
	return ec.marshalNWorldWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐWorldWorldRelation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldWorld_relation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type WorldWorldRelation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldWorld_startDate(ctx context.Context, field graphql.CollectedField, obj *model.WorldWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldWorld_startDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldWorld_startDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorldWorld_endDate(ctx context.Context, field graphql.CollectedField, obj *model.WorldWorld) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorldWorld_endDate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorldWorld_endDate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorldWorld",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCreateCharacterInput(ctx context.Context, obj interface{}) (model.CreateCharacterInput, error) {
	var it model.CreateCharacterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "birthDate", "height", "weight", "isAlive", "isMain", "alignment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "birthDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthDate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BirthDate = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "isAlive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAlive"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsAlive = data
		case "isMain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isMain"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsMain = data
		case "alignment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignment"))
			data, err := ec.unmarshalOAlignment2ᚖordoᚑmapᚋgraphᚋmodelᚐAlignment(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alignment = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateCreatureInput(ctx context.Context, obj interface{}) (model.CreateCreatureInput, error) {
	var it model.CreateCreatureInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "species", "intelligenceLevel", "height", "weight", "birthDate", "isAlive", "lifespan", "isUnique", "habitat", "behavior", "diet", "abilities"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "species":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("species"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Species = data
		case "intelligenceLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("intelligenceLevel"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntelligenceLevel = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "birthDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthDate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BirthDate = data
		case "isAlive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAlive"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsAlive = data
		case "lifespan":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lifespan"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lifespan = data
		case "isUnique":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isUnique"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsUnique = data
		case "habitat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("habitat"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Habitat = data
		case "behavior":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("behavior"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Behavior = data
		case "diet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diet"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Diet = data
		case "abilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilities"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Abilities = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateEventInput(ctx context.Context, obj interface{}) (model.CreateEventInput, error) {
	var it model.CreateEventInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "nature", "startDate", "endDate", "isRecurring", "significance", "locations", "worlds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNEventType2ordoᚑmapᚋgraphᚋmodelᚐEventType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "nature":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nature"))
			data, err := ec.unmarshalNEventNature2ordoᚑmapᚋgraphᚋmodelᚐEventNature(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nature = data
		case "startDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "endDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndDate = data
		case "isRecurring":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isRecurring"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsRecurring = data
		case "significance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("significance"))
			data, err := ec.unmarshalNEventSignificance2ordoᚑmapᚋgraphᚋmodelᚐEventSignificance(ctx, v)
			if err != nil {
				return it, err
			}
			it.Significance = data
		case "locations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locations"))
			data, err := ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locations = data
		case "worlds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worlds"))
			data, err := ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Worlds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateFactionInput(ctx context.Context, obj interface{}) (model.CreateFactionInput, error) {
	var it model.CreateFactionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "ideology", "status", "foundedDate", "disbandedDate", "influence", "locations", "worlds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNFactionType2ordoᚑmapᚋgraphᚋmodelᚐFactionType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "ideology":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ideology"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ideology = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalNFactionStatus2ordoᚑmapᚋgraphᚋmodelᚐFactionStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "foundedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("foundedDate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.FoundedDate = data
		case "disbandedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disbandedDate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisbandedDate = data
		case "influence":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("influence"))
			data, err := ec.unmarshalNFactionInfluence2ordoᚑmapᚋgraphᚋmodelᚐFactionInfluence(ctx, v)
			if err != nil {
				return it, err
			}
			it.Influence = data
		case "locations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locations"))
			data, err := ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locations = data
		case "worlds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worlds"))
			data, err := ec.unmarshalNID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Worlds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateItemInput(ctx context.Context, obj interface{}) (model.CreateItemInput, error) {
	var it model.CreateItemInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "rarity", "slot", "material", "condition", "weight", "dimensions", "creationDate", "destructionDate", "isMagical", "abilities", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNItemType2ordoᚑmapᚋgraphᚋmodelᚐItemType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalNItemRarity2ordoᚑmapᚋgraphᚋmodelᚐItemRarity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "slot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slot"))
			data, err := ec.unmarshalNItemSlot2ordoᚑmapᚋgraphᚋmodelᚐItemSlot(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slot = data
		case "material":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("material"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Material = data
		case "condition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("condition"))
			data, err := ec.unmarshalNItemCondition2ordoᚑmapᚋgraphᚋmodelᚐItemCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.Condition = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "dimensions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dimensions"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dimensions = data
		case "creationDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creationDate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreationDate = data
		case "destructionDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("destructionDate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DestructionDate = data
		case "isMagical":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isMagical"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsMagical = data
		case "abilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilities"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Abilities = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateLocationInput(ctx context.Context, obj interface{}) (model.CreateLocationInput, error) {
	var it model.CreateLocationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"worldId", "name", "description", "type", "region", "coordinates", "accessibility", "isNatural", "climate", "ecosystem"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "worldId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worldId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorldID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNLocationType2ordoᚑmapᚋgraphᚋmodelᚐLocationType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "coordinates":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coordinates"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Coordinates = data
		case "accessibility":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessibility"))
			data, err := ec.unmarshalNLocationAccessibility2ordoᚑmapᚋgraphᚋmodelᚐLocationAccessibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.Accessibility = data
		case "isNatural":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNatural"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNatural = data
		case "climate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("climate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Climate = data
		case "ecosystem":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ecosystem"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ecosystem = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateUniverseInput(ctx context.Context, obj interface{}) (model.CreateUniverseInput, error) {
	var it model.CreateUniverseInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description", "startYear"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "startYear":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startYear"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartYear = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateWorldInput(ctx context.Context, obj interface{}) (model.CreateWorldInput, error) {
	var it model.CreateWorldInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"universeId", "name", "description", "type", "technologyLevel", "energySources", "gravity", "size", "moons", "stars", "climate", "ecosystem", "hasAtmosphere", "isHabitable"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "universeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("universeId"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.UniverseID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNWorldType2ordoᚑmapᚋgraphᚋmodelᚐWorldType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "technologyLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("technologyLevel"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TechnologyLevel = data
		case "energySources":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("energySources"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnergySources = data
		case "gravity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gravity"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gravity = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "moons":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("moons"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Moons = data
		case "stars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stars"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stars = data
		case "climate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("climate"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Climate = data
		case "ecosystem":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ecosystem"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ecosystem = data
		case "hasAtmosphere":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAtmosphere"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAtmosphere = data
		case "isHabitable":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isHabitable"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsHabitable = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCharacterInput(ctx context.Context, obj interface{}) (model.UpdateCharacterInput, error) {
	var it model.UpdateCharacterInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "birthDate", "height", "weight", "isAlive", "isMain", "alignment"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "birthDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthDate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BirthDate = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "isAlive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAlive"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsAlive = data
		case "isMain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isMain"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsMain = data
		case "alignment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alignment"))
			data, err := ec.unmarshalOAlignment2ᚖordoᚑmapᚋgraphᚋmodelᚐAlignment(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alignment = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateCreatureInput(ctx context.Context, obj interface{}) (model.UpdateCreatureInput, error) {
	var it model.UpdateCreatureInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "species", "intelligenceLevel", "height", "weight", "birthDate", "isAlive", "lifespan", "isUnique", "habitat", "behavior", "diet", "abilities"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "species":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("species"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Species = data
		case "intelligenceLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("intelligenceLevel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntelligenceLevel = data
		case "height":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("height"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Height = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "birthDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("birthDate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BirthDate = data
		case "isAlive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isAlive"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsAlive = data
		case "lifespan":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lifespan"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lifespan = data
		case "isUnique":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isUnique"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsUnique = data
		case "habitat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("habitat"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Habitat = data
		case "behavior":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("behavior"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Behavior = data
		case "diet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("diet"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Diet = data
		case "abilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilities"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Abilities = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateEventInput(ctx context.Context, obj interface{}) (model.UpdateEventInput, error) {
	var it model.UpdateEventInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "nature", "startDate", "endDate", "isRecurring", "significance", "locations", "worlds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOEventType2ᚖordoᚑmapᚋgraphᚋmodelᚐEventType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "nature":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nature"))
			data, err := ec.unmarshalOEventNature2ᚖordoᚑmapᚋgraphᚋmodelᚐEventNature(ctx, v)
			if err != nil {
				return it, err
			}
			it.Nature = data
		case "startDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartDate = data
		case "endDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndDate = data
		case "isRecurring":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isRecurring"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsRecurring = data
		case "significance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("significance"))
			data, err := ec.unmarshalOEventSignificance2ᚖordoᚑmapᚋgraphᚋmodelᚐEventSignificance(ctx, v)
			if err != nil {
				return it, err
			}
			it.Significance = data
		case "locations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locations"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locations = data
		case "worlds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worlds"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Worlds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateFactionInput(ctx context.Context, obj interface{}) (model.UpdateFactionInput, error) {
	var it model.UpdateFactionInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "ideology", "status", "foundedDate", "disbandedDate", "influence", "locations", "worlds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOFactionType2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "ideology":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ideology"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ideology = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOFactionStatus2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionStatus(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "foundedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("foundedDate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FoundedDate = data
		case "disbandedDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disbandedDate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisbandedDate = data
		case "influence":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("influence"))
			data, err := ec.unmarshalOFactionInfluence2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionInfluence(ctx, v)
			if err != nil {
				return it, err
			}
			it.Influence = data
		case "locations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("locations"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Locations = data
		case "worlds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("worlds"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Worlds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateItemInput(ctx context.Context, obj interface{}) (model.UpdateItemInput, error) {
	var it model.UpdateItemInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "rarity", "slot", "material", "condition", "weight", "dimensions", "creationDate", "destructionDate", "isMagical", "abilities", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOItemType2ᚖordoᚑmapᚋgraphᚋmodelᚐItemType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "rarity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rarity"))
			data, err := ec.unmarshalOItemRarity2ᚖordoᚑmapᚋgraphᚋmodelᚐItemRarity(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rarity = data
		case "slot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slot"))
			data, err := ec.unmarshalOItemSlot2ᚖordoᚑmapᚋgraphᚋmodelᚐItemSlot(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slot = data
		case "material":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("material"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Material = data
		case "condition":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("condition"))
			data, err := ec.unmarshalOItemCondition2ᚖordoᚑmapᚋgraphᚋmodelᚐItemCondition(ctx, v)
			if err != nil {
				return it, err
			}
			it.Condition = data
		case "weight":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("weight"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Weight = data
		case "dimensions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dimensions"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Dimensions = data
		case "creationDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("creationDate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreationDate = data
		case "destructionDate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("destructionDate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DestructionDate = data
		case "isMagical":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isMagical"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsMagical = data
		case "abilities":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abilities"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Abilities = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateLocationInput(ctx context.Context, obj interface{}) (model.UpdateLocationInput, error) {
	var it model.UpdateLocationInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "region", "coordinates", "accessibility", "isNatural", "climate", "ecosystem"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOLocationType2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "coordinates":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("coordinates"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Coordinates = data
		case "accessibility":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accessibility"))
			data, err := ec.unmarshalOLocationAccessibility2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationAccessibility(ctx, v)
			if err != nil {
				return it, err
			}
			it.Accessibility = data
		case "isNatural":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isNatural"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsNatural = data
		case "climate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("climate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Climate = data
		case "ecosystem":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ecosystem"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ecosystem = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateUniverseInput(ctx context.Context, obj interface{}) (model.UpdateUniverseInput, error) {
	var it model.UpdateUniverseInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "startYear", "isActive"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "startYear":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startYear"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartYear = data
		case "isActive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isActive"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsActive = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateWorldInput(ctx context.Context, obj interface{}) (model.UpdateWorldInput, error) {
	var it model.UpdateWorldInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "name", "description", "type", "technologyLevel", "energySources", "gravity", "size", "moons", "stars", "climate", "ecosystem", "hasAtmosphere", "isHabitable"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOWorldType2ᚖordoᚑmapᚋgraphᚋmodelᚐWorldType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "technologyLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("technologyLevel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TechnologyLevel = data
		case "energySources":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("energySources"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EnergySources = data
		case "gravity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gravity"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Gravity = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "moons":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("moons"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Moons = data
		case "stars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stars"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Stars = data
		case "climate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("climate"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Climate = data
		case "ecosystem":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ecosystem"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ecosystem = data
		case "hasAtmosphere":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAtmosphere"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAtmosphere = data
		case "isHabitable":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isHabitable"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsHabitable = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Entity(ctx context.Context, sel ast.SelectionSet, obj model.Entity) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case model.Character:
		return ec._Character(ctx, sel, &obj)
	case *model.Character:
		if obj == nil {
			return graphql.Null
		}
		return ec._Character(ctx, sel, obj)
	case model.Creature:
		return ec._Creature(ctx, sel, &obj)
	case *model.Creature:
		if obj == nil {
			return graphql.Null
		}
		return ec._Creature(ctx, sel, obj)
	case model.Event:
		return ec._Event(ctx, sel, &obj)
	case *model.Event:
		if obj == nil {
			return graphql.Null
		}
		return ec._Event(ctx, sel, obj)
	case model.Faction:
		return ec._Faction(ctx, sel, &obj)
	case *model.Faction:
		if obj == nil {
			return graphql.Null
		}
		return ec._Faction(ctx, sel, obj)
	case model.Item:
		return ec._Item(ctx, sel, &obj)
	case *model.Item:
		if obj == nil {
			return graphql.Null
		}
		return ec._Item(ctx, sel, obj)
	case model.Location:
		return ec._Location(ctx, sel, &obj)
	case *model.Location:
		if obj == nil {
			return graphql.Null
		}
		return ec._Location(ctx, sel, obj)
	case model.Universe:
		return ec._Universe(ctx, sel, &obj)
	case *model.Universe:
		if obj == nil {
			return graphql.Null
		}
		return ec._Universe(ctx, sel, obj)
	case model.World:
		return ec._World(ctx, sel, &obj)
	case *model.World:
		if obj == nil {
			return graphql.Null
		}
		return ec._World(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var characterImplementors = []string{"Character", "Entity"}

func (ec *executionContext) _Character(ctx context.Context, sel ast.SelectionSet, obj *model.Character) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Character")
		case "id":
			out.Values[i] = ec._Character_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Character_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Character_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Character_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Character_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Character_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "birthDate":
			out.Values[i] = ec._Character_birthDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "height":
			out.Values[i] = ec._Character_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "weight":
			out.Values[i] = ec._Character_weight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlive":
			out.Values[i] = ec._Character_isAlive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isMain":
			out.Values[i] = ec._Character_isMain(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alignment":
			out.Values[i] = ec._Character_alignment(ctx, field, obj)
		case "characters":
			out.Values[i] = ec._Character_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Character_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Character_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Character_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._Character_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Character_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Character_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterCharacterImplementors = []string{"CharacterCharacter"}

func (ec *executionContext) _CharacterCharacter(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterCharacter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterCharacterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterCharacter")
		case "id":
			out.Values[i] = ec._CharacterCharacter_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterCharacter_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characterRelationLevel":
			out.Values[i] = ec._CharacterCharacter_characterRelationLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "familyRelation":
			out.Values[i] = ec._CharacterCharacter_familyRelation(ctx, field, obj)
		case "startDate":
			out.Values[i] = ec._CharacterCharacter_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterCharacter_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterCreatureImplementors = []string{"CharacterCreature"}

func (ec *executionContext) _CharacterCreature(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterCreature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterCreatureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterCreature")
		case "id":
			out.Values[i] = ec._CharacterCreature_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterCreature_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CharacterCreature_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterCreature_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterCreature_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterCreature_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterEventImplementors = []string{"CharacterEvent"}

func (ec *executionContext) _CharacterEvent(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterEvent")
		case "id":
			out.Values[i] = ec._CharacterEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterEvent_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._CharacterEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterFactionImplementors = []string{"CharacterFaction"}

func (ec *executionContext) _CharacterFaction(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterFaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterFactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterFaction")
		case "id":
			out.Values[i] = ec._CharacterFaction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterFaction_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._CharacterFaction_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterFaction_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterFaction_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterFaction_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterItemImplementors = []string{"CharacterItem"}

func (ec *executionContext) _CharacterItem(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterItem")
		case "id":
			out.Values[i] = ec._CharacterItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterItem_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "item":
			out.Values[i] = ec._CharacterItem_item(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterItem_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterItem_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterItem_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterLocationImplementors = []string{"CharacterLocation"}

func (ec *executionContext) _CharacterLocation(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterLocation")
		case "id":
			out.Values[i] = ec._CharacterLocation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterLocation_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._CharacterLocation_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterLocation_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterLocation_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterLocation_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var characterWorldImplementors = []string{"CharacterWorld"}

func (ec *executionContext) _CharacterWorld(ctx context.Context, sel ast.SelectionSet, obj *model.CharacterWorld) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, characterWorldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CharacterWorld")
		case "id":
			out.Values[i] = ec._CharacterWorld_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "character":
			out.Values[i] = ec._CharacterWorld_character(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._CharacterWorld_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CharacterWorld_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CharacterWorld_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CharacterWorld_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureImplementors = []string{"Creature", "Entity"}

func (ec *executionContext) _Creature(ctx context.Context, sel ast.SelectionSet, obj *model.Creature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Creature")
		case "id":
			out.Values[i] = ec._Creature_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Creature_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Creature_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Creature_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Creature_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Creature_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "species":
			out.Values[i] = ec._Creature_species(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "intelligenceLevel":
			out.Values[i] = ec._Creature_intelligenceLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "height":
			out.Values[i] = ec._Creature_height(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "weight":
			out.Values[i] = ec._Creature_weight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "birthDate":
			out.Values[i] = ec._Creature_birthDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isAlive":
			out.Values[i] = ec._Creature_isAlive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lifespan":
			out.Values[i] = ec._Creature_lifespan(ctx, field, obj)
		case "isUnique":
			out.Values[i] = ec._Creature_isUnique(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "habitat":
			out.Values[i] = ec._Creature_habitat(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "behavior":
			out.Values[i] = ec._Creature_behavior(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "diet":
			out.Values[i] = ec._Creature_diet(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "abilities":
			out.Values[i] = ec._Creature_abilities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Creature_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Creature_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Creature_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Creature_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Creature_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Creature_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureCreatureImplementors = []string{"CreatureCreature"}

func (ec *executionContext) _CreatureCreature(ctx context.Context, sel ast.SelectionSet, obj *model.CreatureCreature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureCreatureImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreatureCreature")
		case "id":
			out.Values[i] = ec._CreatureCreature_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CreatureCreature_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CreatureCreature_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CreatureCreature_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CreatureCreature_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureEventImplementors = []string{"CreatureEvent"}

func (ec *executionContext) _CreatureEvent(ctx context.Context, sel ast.SelectionSet, obj *model.CreatureEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreatureEvent")
		case "id":
			out.Values[i] = ec._CreatureEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CreatureEvent_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._CreatureEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CreatureEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CreatureEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CreatureEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureFactionImplementors = []string{"CreatureFaction"}

func (ec *executionContext) _CreatureFaction(ctx context.Context, sel ast.SelectionSet, obj *model.CreatureFaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureFactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreatureFaction")
		case "id":
			out.Values[i] = ec._CreatureFaction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CreatureFaction_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._CreatureFaction_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CreatureFaction_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CreatureFaction_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CreatureFaction_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureLocationImplementors = []string{"CreatureLocation"}

func (ec *executionContext) _CreatureLocation(ctx context.Context, sel ast.SelectionSet, obj *model.CreatureLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreatureLocation")
		case "id":
			out.Values[i] = ec._CreatureLocation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CreatureLocation_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._CreatureLocation_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CreatureLocation_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CreatureLocation_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CreatureLocation_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var creatureWorldImplementors = []string{"CreatureWorld"}

func (ec *executionContext) _CreatureWorld(ctx context.Context, sel ast.SelectionSet, obj *model.CreatureWorld) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, creatureWorldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CreatureWorld")
		case "id":
			out.Values[i] = ec._CreatureWorld_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creature":
			out.Values[i] = ec._CreatureWorld_creature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._CreatureWorld_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._CreatureWorld_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._CreatureWorld_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._CreatureWorld_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventImplementors = []string{"Event", "Entity"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *model.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":
			out.Values[i] = ec._Event_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Event_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Event_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Event_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Event_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Event_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nature":
			out.Values[i] = ec._Event_nature(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._Event_startDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "endDate":
			out.Values[i] = ec._Event_endDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRecurring":
			out.Values[i] = ec._Event_isRecurring(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "significance":
			out.Values[i] = ec._Event_significance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Event_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Event_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Event_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Event_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Event_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._Event_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relatedEvents":
			out.Values[i] = ec._Event_relatedEvents(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionImplementors = []string{"Faction", "Entity"}

func (ec *executionContext) _Faction(ctx context.Context, sel ast.SelectionSet, obj *model.Faction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Faction")
		case "id":
			out.Values[i] = ec._Faction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Faction_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Faction_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Faction_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Faction_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Faction_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ideology":
			out.Values[i] = ec._Faction_ideology(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Faction_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "foundedDate":
			out.Values[i] = ec._Faction_foundedDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "disbandedDate":
			out.Values[i] = ec._Faction_disbandedDate(ctx, field, obj)
		case "influence":
			out.Values[i] = ec._Faction_influence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Faction_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Faction_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Faction_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Faction_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Faction_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Faction_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._Faction_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionEventImplementors = []string{"FactionEvent"}

func (ec *executionContext) _FactionEvent(ctx context.Context, sel ast.SelectionSet, obj *model.FactionEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FactionEvent")
		case "id":
			out.Values[i] = ec._FactionEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._FactionEvent_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._FactionEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._FactionEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._FactionEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._FactionEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionFactionImplementors = []string{"FactionFaction"}

func (ec *executionContext) _FactionFaction(ctx context.Context, sel ast.SelectionSet, obj *model.FactionFaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionFactionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FactionFaction")
		case "id":
			out.Values[i] = ec._FactionFaction_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._FactionFaction_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._FactionFaction_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._FactionFaction_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._FactionFaction_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionItemImplementors = []string{"FactionItem"}

func (ec *executionContext) _FactionItem(ctx context.Context, sel ast.SelectionSet, obj *model.FactionItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FactionItem")
		case "id":
			out.Values[i] = ec._FactionItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._FactionItem_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "item":
			out.Values[i] = ec._FactionItem_item(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._FactionItem_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._FactionItem_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._FactionItem_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionLocationImplementors = []string{"FactionLocation"}

func (ec *executionContext) _FactionLocation(ctx context.Context, sel ast.SelectionSet, obj *model.FactionLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FactionLocation")
		case "id":
			out.Values[i] = ec._FactionLocation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._FactionLocation_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._FactionLocation_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._FactionLocation_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._FactionLocation_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._FactionLocation_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var factionWorldImplementors = []string{"FactionWorld"}

func (ec *executionContext) _FactionWorld(ctx context.Context, sel ast.SelectionSet, obj *model.FactionWorld) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, factionWorldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FactionWorld")
		case "id":
			out.Values[i] = ec._FactionWorld_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "faction":
			out.Values[i] = ec._FactionWorld_faction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._FactionWorld_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._FactionWorld_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._FactionWorld_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._FactionWorld_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemImplementors = []string{"Item", "Entity"}

func (ec *executionContext) _Item(ctx context.Context, sel ast.SelectionSet, obj *model.Item) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Item")
		case "id":
			out.Values[i] = ec._Item_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Item_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Item_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Item_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Item_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Item_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rarity":
			out.Values[i] = ec._Item_rarity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "slot":
			out.Values[i] = ec._Item_slot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "material":
			out.Values[i] = ec._Item_material(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "condition":
			out.Values[i] = ec._Item_condition(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "weight":
			out.Values[i] = ec._Item_weight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dimensions":
			out.Values[i] = ec._Item_dimensions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creationDate":
			out.Values[i] = ec._Item_creationDate(ctx, field, obj)
		case "destructionDate":
			out.Values[i] = ec._Item_destructionDate(ctx, field, obj)
		case "isMagical":
			out.Values[i] = ec._Item_isMagical(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "abilities":
			out.Values[i] = ec._Item_abilities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._Item_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Item_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Item_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Item_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Item_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relatedItems":
			out.Values[i] = ec._Item_relatedItems(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemEventImplementors = []string{"ItemEvent"}

func (ec *executionContext) _ItemEvent(ctx context.Context, sel ast.SelectionSet, obj *model.ItemEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemEvent")
		case "id":
			out.Values[i] = ec._ItemEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "item":
			out.Values[i] = ec._ItemEvent_item(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._ItemEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._ItemEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._ItemEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._ItemEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemItemImplementors = []string{"ItemItem"}

func (ec *executionContext) _ItemItem(ctx context.Context, sel ast.SelectionSet, obj *model.ItemItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemItem")
		case "id":
			out.Values[i] = ec._ItemItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "item":
			out.Values[i] = ec._ItemItem_item(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._ItemItem_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._ItemItem_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._ItemItem_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemLocationImplementors = []string{"ItemLocation"}

func (ec *executionContext) _ItemLocation(ctx context.Context, sel ast.SelectionSet, obj *model.ItemLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemLocation")
		case "id":
			out.Values[i] = ec._ItemLocation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "item":
			out.Values[i] = ec._ItemLocation_item(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "with":
			out.Values[i] = ec._ItemLocation_with(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._ItemLocation_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._ItemLocation_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._ItemLocation_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationImplementors = []string{"Location", "Entity"}

func (ec *executionContext) _Location(ctx context.Context, sel ast.SelectionSet, obj *model.Location) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Location")
		case "id":
			out.Values[i] = ec._Location_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Location_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Location_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Location_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Location_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Location_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "region":
			out.Values[i] = ec._Location_region(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "coordinates":
			out.Values[i] = ec._Location_coordinates(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "accessibility":
			out.Values[i] = ec._Location_accessibility(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isNatural":
			out.Values[i] = ec._Location_isNatural(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "climate":
			out.Values[i] = ec._Location_climate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ecosystem":
			out.Values[i] = ec._Location_ecosystem(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Location_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Location_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Location_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Location_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._Location_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relatedLocations":
			out.Values[i] = ec._Location_relatedLocations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Location_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationEventImplementors = []string{"LocationEvent"}

func (ec *executionContext) _LocationEvent(ctx context.Context, sel ast.SelectionSet, obj *model.LocationEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocationEvent")
		case "id":
			out.Values[i] = ec._LocationEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._LocationEvent_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._LocationEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._LocationEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._LocationEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._LocationEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationLocationImplementors = []string{"LocationLocation"}

func (ec *executionContext) _LocationLocation(ctx context.Context, sel ast.SelectionSet, obj *model.LocationLocation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationLocationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocationLocation")
		case "id":
			out.Values[i] = ec._LocationLocation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._LocationLocation_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._LocationLocation_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._LocationLocation_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._LocationLocation_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var locationWorldImplementors = []string{"LocationWorld"}

func (ec *executionContext) _LocationWorld(ctx context.Context, sel ast.SelectionSet, obj *model.LocationWorld) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, locationWorldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LocationWorld")
		case "id":
			out.Values[i] = ec._LocationWorld_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "location":
			out.Values[i] = ec._LocationWorld_location(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._LocationWorld_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._LocationWorld_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._LocationWorld_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._LocationWorld_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createCharacter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCharacter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateCharacter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCharacter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteCharacter":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteCharacter(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createCreature":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createCreature(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateCreature":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateCreature(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteCreature":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteCreature(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteItem":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteItem(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createLocation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createLocation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateLocation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateLocation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteLocation":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteLocation(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createFaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createFaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateFaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateFaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteFaction":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteFaction(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteEvent":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteEvent(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createWorld":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createWorld(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateWorld":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateWorld(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteWorld":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteWorld(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createUniverse":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createUniverse(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUniverse":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUniverse(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteUniverse":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteUniverse(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "character":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_character(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "characters":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_characters(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "creature":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_creature(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "creatures":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_creatures(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "item":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_item(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "items":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_items(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "location":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_location(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "locations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_locations(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "faction":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_faction(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "factions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_factions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "event":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_event(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_events(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "world":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_world(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "worlds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_worlds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "universe":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_universe(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "universes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_universes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var responseImplementors = []string{"Response"}

func (ec *executionContext) _Response(ctx context.Context, sel ast.SelectionSet, obj *model.Response) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, responseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Response")
		case "status":
			out.Values[i] = ec._Response_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._Response_message(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var universeImplementors = []string{"Universe", "Entity"}

func (ec *executionContext) _Universe(ctx context.Context, sel ast.SelectionSet, obj *model.Universe) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, universeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Universe")
		case "id":
			out.Values[i] = ec._Universe_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._Universe_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._Universe_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Universe_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._Universe_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startYear":
			out.Values[i] = ec._Universe_startYear(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isActive":
			out.Values[i] = ec._Universe_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "worlds":
			out.Values[i] = ec._Universe_worlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._Universe_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._Universe_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._Universe_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._Universe_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._Universe_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "items":
			out.Values[i] = ec._Universe_items(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var worldImplementors = []string{"World", "Entity"}

func (ec *executionContext) _World(ctx context.Context, sel ast.SelectionSet, obj *model.World) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, worldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("World")
		case "id":
			out.Values[i] = ec._World_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createdAt":
			out.Values[i] = ec._World_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updatedAt":
			out.Values[i] = ec._World_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._World_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._World_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._World_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "universe":
			out.Values[i] = ec._World_universe(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "technologyLevel":
			out.Values[i] = ec._World_technologyLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "energySources":
			out.Values[i] = ec._World_energySources(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "gravity":
			out.Values[i] = ec._World_gravity(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "size":
			out.Values[i] = ec._World_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "moons":
			out.Values[i] = ec._World_moons(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "stars":
			out.Values[i] = ec._World_stars(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "climate":
			out.Values[i] = ec._World_climate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ecosystem":
			out.Values[i] = ec._World_ecosystem(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasAtmosphere":
			out.Values[i] = ec._World_hasAtmosphere(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isHabitable":
			out.Values[i] = ec._World_isHabitable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "characters":
			out.Values[i] = ec._World_characters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "creatures":
			out.Values[i] = ec._World_creatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factions":
			out.Values[i] = ec._World_factions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "events":
			out.Values[i] = ec._World_events(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec._World_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "connectedWorlds":
			out.Values[i] = ec._World_connectedWorlds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var worldEventImplementors = []string{"WorldEvent"}

func (ec *executionContext) _WorldEvent(ctx context.Context, sel ast.SelectionSet, obj *model.WorldEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, worldEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorldEvent")
		case "id":
			out.Values[i] = ec._WorldEvent_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._WorldEvent_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "event":
			out.Values[i] = ec._WorldEvent_event(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._WorldEvent_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._WorldEvent_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._WorldEvent_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var worldWorldImplementors = []string{"WorldWorld"}

func (ec *executionContext) _WorldWorld(ctx context.Context, sel ast.SelectionSet, obj *model.WorldWorld) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, worldWorldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorldWorld")
		case "id":
			out.Values[i] = ec._WorldWorld_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "world":
			out.Values[i] = ec._WorldWorld_world(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "relation":
			out.Values[i] = ec._WorldWorld_relation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startDate":
			out.Values[i] = ec._WorldWorld_startDate(ctx, field, obj)
		case "endDate":
			out.Values[i] = ec._WorldWorld_endDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCharacter2ordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx context.Context, sel ast.SelectionSet, v model.Character) graphql.Marshaler {
	return ec._Character(ctx, sel, &v)
}

func (ec *executionContext) marshalNCharacter2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Character) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx context.Context, sel ast.SelectionSet, v *model.Character) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Character(ctx, sel, v)
}

func (ec *executionContext) marshalNCharacterCharacter2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterCharacterᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterCharacter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterCharacter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterCharacter(ctx context.Context, sel ast.SelectionSet, v *model.CharacterCharacter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterCharacter(ctx, sel, v)
}

func (ec *executionContext) marshalNCharacterCreature2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterCreatureᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterCreature) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterCreature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterCreature(ctx context.Context, sel ast.SelectionSet, v *model.CharacterCreature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterCreature(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterCreatureRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterCreatureRelation(ctx context.Context, v interface{}) (model.CharacterCreatureRelation, error) {
	var res model.CharacterCreatureRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterCreatureRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterCreatureRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterCreatureRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCharacterEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterEvent(ctx context.Context, sel ast.SelectionSet, v *model.CharacterEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterEventRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterEventRelation(ctx context.Context, v interface{}) (model.CharacterEventRelation, error) {
	var res model.CharacterEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterEventRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterEventRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCharacterFaction2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterFactionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterFaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterFaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterFaction(ctx context.Context, sel ast.SelectionSet, v *model.CharacterFaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterFaction(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterFactionRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterFactionRelation(ctx context.Context, v interface{}) (model.CharacterFactionRelation, error) {
	var res model.CharacterFactionRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterFactionRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterFactionRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterFactionRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCharacterItem2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterItem2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterItem2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterItem(ctx context.Context, sel ast.SelectionSet, v *model.CharacterItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterItemRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterItemRelation(ctx context.Context, v interface{}) (model.CharacterItemRelation, error) {
	var res model.CharacterItemRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterItemRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterItemRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterItemRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCharacterLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterLocationᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterLocation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterLocation(ctx context.Context, sel ast.SelectionSet, v *model.CharacterLocation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterLocation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterLocationRelation(ctx context.Context, v interface{}) (model.CharacterLocationRelation, error) {
	var res model.CharacterLocationRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterLocationRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterLocationRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNCharacterRelationLevel2ordoᚑmapᚋgraphᚋmodelᚐCharacterRelationLevel(ctx context.Context, v interface{}) (model.CharacterRelationLevel, error) {
	var res model.CharacterRelationLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterRelationLevel2ordoᚑmapᚋgraphᚋmodelᚐCharacterRelationLevel(ctx context.Context, sel ast.SelectionSet, v model.CharacterRelationLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCharacterWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCharacterWorldᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CharacterWorld) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCharacterWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCharacterWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacterWorld(ctx context.Context, sel ast.SelectionSet, v *model.CharacterWorld) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CharacterWorld(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCharacterWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterWorldRelation(ctx context.Context, v interface{}) (model.CharacterWorldRelation, error) {
	var res model.CharacterWorldRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCharacterWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐCharacterWorldRelation(ctx context.Context, sel ast.SelectionSet, v model.CharacterWorldRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNCreateCharacterInput2ordoᚑmapᚋgraphᚋmodelᚐCreateCharacterInput(ctx context.Context, v interface{}) (model.CreateCharacterInput, error) {
	res, err := ec.unmarshalInputCreateCharacterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateCreatureInput2ordoᚑmapᚋgraphᚋmodelᚐCreateCreatureInput(ctx context.Context, v interface{}) (model.CreateCreatureInput, error) {
	res, err := ec.unmarshalInputCreateCreatureInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateEventInput2ordoᚑmapᚋgraphᚋmodelᚐCreateEventInput(ctx context.Context, v interface{}) (model.CreateEventInput, error) {
	res, err := ec.unmarshalInputCreateEventInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateFactionInput2ordoᚑmapᚋgraphᚋmodelᚐCreateFactionInput(ctx context.Context, v interface{}) (model.CreateFactionInput, error) {
	res, err := ec.unmarshalInputCreateFactionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateItemInput2ordoᚑmapᚋgraphᚋmodelᚐCreateItemInput(ctx context.Context, v interface{}) (model.CreateItemInput, error) {
	res, err := ec.unmarshalInputCreateItemInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateLocationInput2ordoᚑmapᚋgraphᚋmodelᚐCreateLocationInput(ctx context.Context, v interface{}) (model.CreateLocationInput, error) {
	res, err := ec.unmarshalInputCreateLocationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateUniverseInput2ordoᚑmapᚋgraphᚋmodelᚐCreateUniverseInput(ctx context.Context, v interface{}) (model.CreateUniverseInput, error) {
	res, err := ec.unmarshalInputCreateUniverseInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateWorldInput2ordoᚑmapᚋgraphᚋmodelᚐCreateWorldInput(ctx context.Context, v interface{}) (model.CreateWorldInput, error) {
	res, err := ec.unmarshalInputCreateWorldInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreature2ordoᚑmapᚋgraphᚋmodelᚐCreature(ctx context.Context, sel ast.SelectionSet, v model.Creature) graphql.Marshaler {
	return ec._Creature(ctx, sel, &v)
}

func (ec *executionContext) marshalNCreature2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Creature) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx context.Context, sel ast.SelectionSet, v *model.Creature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Creature(ctx, sel, v)
}

func (ec *executionContext) marshalNCreatureCreature2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureCreatureᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CreatureCreature) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreatureCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreatureCreature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreatureCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreatureCreature(ctx context.Context, sel ast.SelectionSet, v *model.CreatureCreature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreatureCreature(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreatureCreatureRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureCreatureRelation(ctx context.Context, v interface{}) (model.CreatureCreatureRelation, error) {
	var res model.CreatureCreatureRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreatureCreatureRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureCreatureRelation(ctx context.Context, sel ast.SelectionSet, v model.CreatureCreatureRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreatureEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CreatureEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreatureEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐCreatureEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreatureEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐCreatureEvent(ctx context.Context, sel ast.SelectionSet, v *model.CreatureEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreatureEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreatureEventRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureEventRelation(ctx context.Context, v interface{}) (model.CreatureEventRelation, error) {
	var res model.CreatureEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreatureEventRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureEventRelation(ctx context.Context, sel ast.SelectionSet, v model.CreatureEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreatureFaction2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureFactionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CreatureFaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreatureFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐCreatureFaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreatureFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐCreatureFaction(ctx context.Context, sel ast.SelectionSet, v *model.CreatureFaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreatureFaction(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreatureFactionRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureFactionRelation(ctx context.Context, v interface{}) (model.CreatureFactionRelation, error) {
	var res model.CreatureFactionRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreatureFactionRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureFactionRelation(ctx context.Context, sel ast.SelectionSet, v model.CreatureFactionRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreatureLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureLocationᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CreatureLocation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreatureLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐCreatureLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreatureLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐCreatureLocation(ctx context.Context, sel ast.SelectionSet, v *model.CreatureLocation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreatureLocation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreatureLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureLocationRelation(ctx context.Context, v interface{}) (model.CreatureLocationRelation, error) {
	var res model.CreatureLocationRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreatureLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureLocationRelation(ctx context.Context, sel ast.SelectionSet, v model.CreatureLocationRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCreatureWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐCreatureWorldᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.CreatureWorld) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCreatureWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐCreatureWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNCreatureWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐCreatureWorld(ctx context.Context, sel ast.SelectionSet, v *model.CreatureWorld) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CreatureWorld(ctx, sel, v)
}

func (ec *executionContext) unmarshalNCreatureWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureWorldRelation(ctx context.Context, v interface{}) (model.CreatureWorldRelation, error) {
	var res model.CreatureWorldRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCreatureWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐCreatureWorldRelation(ctx context.Context, sel ast.SelectionSet, v model.CreatureWorldRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNEvent2ordoᚑmapᚋgraphᚋmodelᚐEvent(ctx context.Context, sel ast.SelectionSet, v model.Event) graphql.Marshaler {
	return ec._Event(ctx, sel, &v)
}

func (ec *executionContext) marshalNEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Event) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx context.Context, sel ast.SelectionSet, v *model.Event) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) unmarshalNEventEvent2ordoᚑmapᚋgraphᚋmodelᚐEventEvent(ctx context.Context, v interface{}) (model.EventEvent, error) {
	var res model.EventEvent
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventEvent2ordoᚑmapᚋgraphᚋmodelᚐEventEvent(ctx context.Context, sel ast.SelectionSet, v model.EventEvent) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventEvent2ᚕordoᚑmapᚋgraphᚋmodelᚐEventEventᚄ(ctx context.Context, v interface{}) ([]model.EventEvent, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.EventEvent, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEventEvent2ordoᚑmapᚋgraphᚋmodelᚐEventEvent(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNEventEvent2ᚕordoᚑmapᚋgraphᚋmodelᚐEventEventᚄ(ctx context.Context, sel ast.SelectionSet, v []model.EventEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEventEvent2ordoᚑmapᚋgraphᚋmodelᚐEventEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNEventNature2ordoᚑmapᚋgraphᚋmodelᚐEventNature(ctx context.Context, v interface{}) (model.EventNature, error) {
	var res model.EventNature
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventNature2ordoᚑmapᚋgraphᚋmodelᚐEventNature(ctx context.Context, sel ast.SelectionSet, v model.EventNature) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventSignificance2ordoᚑmapᚋgraphᚋmodelᚐEventSignificance(ctx context.Context, v interface{}) (model.EventSignificance, error) {
	var res model.EventSignificance
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventSignificance2ordoᚑmapᚋgraphᚋmodelᚐEventSignificance(ctx context.Context, sel ast.SelectionSet, v model.EventSignificance) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNEventType2ordoᚑmapᚋgraphᚋmodelᚐEventType(ctx context.Context, v interface{}) (model.EventType, error) {
	var res model.EventType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEventType2ordoᚑmapᚋgraphᚋmodelᚐEventType(ctx context.Context, sel ast.SelectionSet, v model.EventType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFaction2ordoᚑmapᚋgraphᚋmodelᚐFaction(ctx context.Context, sel ast.SelectionSet, v model.Faction) graphql.Marshaler {
	return ec._Faction(ctx, sel, &v)
}

func (ec *executionContext) marshalNFaction2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Faction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx context.Context, sel ast.SelectionSet, v *model.Faction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Faction(ctx, sel, v)
}

func (ec *executionContext) marshalNFactionEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.FactionEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFactionEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFactionEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionEvent(ctx context.Context, sel ast.SelectionSet, v *model.FactionEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FactionEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFactionEventRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionEventRelation(ctx context.Context, v interface{}) (model.FactionEventRelation, error) {
	var res model.FactionEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionEventRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionEventRelation(ctx context.Context, sel ast.SelectionSet, v model.FactionEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFactionFaction2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionFactionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.FactionFaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFactionFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionFaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFactionFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionFaction(ctx context.Context, sel ast.SelectionSet, v *model.FactionFaction) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FactionFaction(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFactionFactionRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionFactionRelation(ctx context.Context, v interface{}) (model.FactionFactionRelation, error) {
	var res model.FactionFactionRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionFactionRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionFactionRelation(ctx context.Context, sel ast.SelectionSet, v model.FactionFactionRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFactionInfluence2ordoᚑmapᚋgraphᚋmodelᚐFactionInfluence(ctx context.Context, v interface{}) (model.FactionInfluence, error) {
	var res model.FactionInfluence
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionInfluence2ordoᚑmapᚋgraphᚋmodelᚐFactionInfluence(ctx context.Context, sel ast.SelectionSet, v model.FactionInfluence) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFactionItem2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.FactionItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFactionItem2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFactionItem2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionItem(ctx context.Context, sel ast.SelectionSet, v *model.FactionItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FactionItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFactionItemRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionItemRelation(ctx context.Context, v interface{}) (model.FactionItemRelation, error) {
	var res model.FactionItemRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionItemRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionItemRelation(ctx context.Context, sel ast.SelectionSet, v model.FactionItemRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFactionLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionLocationᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.FactionLocation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFactionLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFactionLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionLocation(ctx context.Context, sel ast.SelectionSet, v *model.FactionLocation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FactionLocation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFactionLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionLocationRelation(ctx context.Context, v interface{}) (model.FactionLocationRelation, error) {
	var res model.FactionLocationRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionLocationRelation(ctx context.Context, sel ast.SelectionSet, v model.FactionLocationRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFactionStatus2ordoᚑmapᚋgraphᚋmodelᚐFactionStatus(ctx context.Context, v interface{}) (model.FactionStatus, error) {
	var res model.FactionStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionStatus2ordoᚑmapᚋgraphᚋmodelᚐFactionStatus(ctx context.Context, sel ast.SelectionSet, v model.FactionStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFactionType2ordoᚑmapᚋgraphᚋmodelᚐFactionType(ctx context.Context, v interface{}) (model.FactionType, error) {
	var res model.FactionType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionType2ordoᚑmapᚋgraphᚋmodelᚐFactionType(ctx context.Context, sel ast.SelectionSet, v model.FactionType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFactionWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐFactionWorldᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.FactionWorld) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFactionWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFactionWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionWorld(ctx context.Context, sel ast.SelectionSet, v *model.FactionWorld) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FactionWorld(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFactionWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionWorldRelation(ctx context.Context, v interface{}) (model.FactionWorldRelation, error) {
	var res model.FactionWorldRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFactionWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐFactionWorldRelation(ctx context.Context, sel ast.SelectionSet, v model.FactionWorldRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNItem2ordoᚑmapᚋgraphᚋmodelᚐItem(ctx context.Context, sel ast.SelectionSet, v model.Item) graphql.Marshaler {
	return ec._Item(ctx, sel, &v)
}

func (ec *executionContext) marshalNItem2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Item) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItem(ctx context.Context, sel ast.SelectionSet, v *model.Item) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Item(ctx, sel, v)
}

func (ec *executionContext) unmarshalNItemCondition2ordoᚑmapᚋgraphᚋmodelᚐItemCondition(ctx context.Context, v interface{}) (model.ItemCondition, error) {
	var res model.ItemCondition
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemCondition2ordoᚑmapᚋgraphᚋmodelᚐItemCondition(ctx context.Context, sel ast.SelectionSet, v model.ItemCondition) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNItemEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐItemEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ItemEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItemEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐItemEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNItemEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐItemEvent(ctx context.Context, sel ast.SelectionSet, v *model.ItemEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ItemEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNItemEventRelation2ordoᚑmapᚋgraphᚋmodelᚐItemEventRelation(ctx context.Context, v interface{}) (model.ItemEventRelation, error) {
	var res model.ItemEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemEventRelation2ordoᚑmapᚋgraphᚋmodelᚐItemEventRelation(ctx context.Context, sel ast.SelectionSet, v model.ItemEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNItemItem2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐItemItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ItemItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItemItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItemItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNItemItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItemItem(ctx context.Context, sel ast.SelectionSet, v *model.ItemItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ItemItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNItemItemRelation2ordoᚑmapᚋgraphᚋmodelᚐItemItemRelation(ctx context.Context, v interface{}) (model.ItemItemRelation, error) {
	var res model.ItemItemRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemItemRelation2ordoᚑmapᚋgraphᚋmodelᚐItemItemRelation(ctx context.Context, sel ast.SelectionSet, v model.ItemItemRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNItemLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐItemLocationᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.ItemLocation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItemLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐItemLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNItemLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐItemLocation(ctx context.Context, sel ast.SelectionSet, v *model.ItemLocation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ItemLocation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNItemLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐItemLocationRelation(ctx context.Context, v interface{}) (model.ItemLocationRelation, error) {
	var res model.ItemLocationRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐItemLocationRelation(ctx context.Context, sel ast.SelectionSet, v model.ItemLocationRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemRarity2ordoᚑmapᚋgraphᚋmodelᚐItemRarity(ctx context.Context, v interface{}) (model.ItemRarity, error) {
	var res model.ItemRarity
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemRarity2ordoᚑmapᚋgraphᚋmodelᚐItemRarity(ctx context.Context, sel ast.SelectionSet, v model.ItemRarity) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemSlot2ordoᚑmapᚋgraphᚋmodelᚐItemSlot(ctx context.Context, v interface{}) (model.ItemSlot, error) {
	var res model.ItemSlot
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemSlot2ordoᚑmapᚋgraphᚋmodelᚐItemSlot(ctx context.Context, sel ast.SelectionSet, v model.ItemSlot) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemType2ordoᚑmapᚋgraphᚋmodelᚐItemType(ctx context.Context, v interface{}) (model.ItemType, error) {
	var res model.ItemType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemType2ordoᚑmapᚋgraphᚋmodelᚐItemType(ctx context.Context, sel ast.SelectionSet, v model.ItemType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLocation2ordoᚑmapᚋgraphᚋmodelᚐLocation(ctx context.Context, sel ast.SelectionSet, v model.Location) graphql.Marshaler {
	return ec._Location(ctx, sel, &v)
}

func (ec *executionContext) marshalNLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐLocationᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Location) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx context.Context, sel ast.SelectionSet, v *model.Location) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Location(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLocationAccessibility2ordoᚑmapᚋgraphᚋmodelᚐLocationAccessibility(ctx context.Context, v interface{}) (model.LocationAccessibility, error) {
	var res model.LocationAccessibility
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLocationAccessibility2ordoᚑmapᚋgraphᚋmodelᚐLocationAccessibility(ctx context.Context, sel ast.SelectionSet, v model.LocationAccessibility) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLocationEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐLocationEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.LocationEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLocationEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLocationEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationEvent(ctx context.Context, sel ast.SelectionSet, v *model.LocationEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LocationEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLocationEventRelation2ordoᚑmapᚋgraphᚋmodelᚐLocationEventRelation(ctx context.Context, v interface{}) (model.LocationEventRelation, error) {
	var res model.LocationEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLocationEventRelation2ordoᚑmapᚋgraphᚋmodelᚐLocationEventRelation(ctx context.Context, sel ast.SelectionSet, v model.LocationEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLocationLocation2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐLocationLocationᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.LocationLocation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLocationLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationLocation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLocationLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationLocation(ctx context.Context, sel ast.SelectionSet, v *model.LocationLocation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LocationLocation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLocationLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐLocationLocationRelation(ctx context.Context, v interface{}) (model.LocationLocationRelation, error) {
	var res model.LocationLocationRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLocationLocationRelation2ordoᚑmapᚋgraphᚋmodelᚐLocationLocationRelation(ctx context.Context, sel ast.SelectionSet, v model.LocationLocationRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNLocationType2ordoᚑmapᚋgraphᚋmodelᚐLocationType(ctx context.Context, v interface{}) (model.LocationType, error) {
	var res model.LocationType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLocationType2ordoᚑmapᚋgraphᚋmodelᚐLocationType(ctx context.Context, sel ast.SelectionSet, v model.LocationType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNLocationWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐLocationWorldᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.LocationWorld) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLocationWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLocationWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationWorld(ctx context.Context, sel ast.SelectionSet, v *model.LocationWorld) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LocationWorld(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLocationWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐLocationWorldRelation(ctx context.Context, v interface{}) (model.LocationWorldRelation, error) {
	var res model.LocationWorldRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLocationWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐLocationWorldRelation(ctx context.Context, sel ast.SelectionSet, v model.LocationWorldRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUniverse2ordoᚑmapᚋgraphᚋmodelᚐUniverse(ctx context.Context, sel ast.SelectionSet, v model.Universe) graphql.Marshaler {
	return ec._Universe(ctx, sel, &v)
}

func (ec *executionContext) marshalNUniverse2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐUniverseᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.Universe) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNUniverse2ᚖordoᚑmapᚋgraphᚋmodelᚐUniverse(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNUniverse2ᚖordoᚑmapᚋgraphᚋmodelᚐUniverse(ctx context.Context, sel ast.SelectionSet, v *model.Universe) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Universe(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateCharacterInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateCharacterInput(ctx context.Context, v interface{}) (model.UpdateCharacterInput, error) {
	res, err := ec.unmarshalInputUpdateCharacterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateCreatureInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateCreatureInput(ctx context.Context, v interface{}) (model.UpdateCreatureInput, error) {
	res, err := ec.unmarshalInputUpdateCreatureInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateEventInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateEventInput(ctx context.Context, v interface{}) (model.UpdateEventInput, error) {
	res, err := ec.unmarshalInputUpdateEventInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateFactionInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateFactionInput(ctx context.Context, v interface{}) (model.UpdateFactionInput, error) {
	res, err := ec.unmarshalInputUpdateFactionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateItemInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateItemInput(ctx context.Context, v interface{}) (model.UpdateItemInput, error) {
	res, err := ec.unmarshalInputUpdateItemInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateLocationInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateLocationInput(ctx context.Context, v interface{}) (model.UpdateLocationInput, error) {
	res, err := ec.unmarshalInputUpdateLocationInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateUniverseInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateUniverseInput(ctx context.Context, v interface{}) (model.UpdateUniverseInput, error) {
	res, err := ec.unmarshalInputUpdateUniverseInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateWorldInput2ordoᚑmapᚋgraphᚋmodelᚐUpdateWorldInput(ctx context.Context, v interface{}) (model.UpdateWorldInput, error) {
	res, err := ec.unmarshalInputUpdateWorldInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorld2ordoᚑmapᚋgraphᚋmodelᚐWorld(ctx context.Context, sel ast.SelectionSet, v model.World) graphql.Marshaler {
	return ec._World(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐWorldᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.World) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx context.Context, sel ast.SelectionSet, v *model.World) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._World(ctx, sel, v)
}

func (ec *executionContext) marshalNWorldEvent2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐWorldEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.WorldEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorldEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐWorldEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorldEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐWorldEvent(ctx context.Context, sel ast.SelectionSet, v *model.WorldEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorldEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWorldEventRelation2ordoᚑmapᚋgraphᚋmodelᚐWorldEventRelation(ctx context.Context, v interface{}) (model.WorldEventRelation, error) {
	var res model.WorldEventRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorldEventRelation2ordoᚑmapᚋgraphᚋmodelᚐWorldEventRelation(ctx context.Context, sel ast.SelectionSet, v model.WorldEventRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNWorldType2ordoᚑmapᚋgraphᚋmodelᚐWorldType(ctx context.Context, v interface{}) (model.WorldType, error) {
	var res model.WorldType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorldType2ordoᚑmapᚋgraphᚋmodelᚐWorldType(ctx context.Context, sel ast.SelectionSet, v model.WorldType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNWorldWorld2ᚕᚖordoᚑmapᚋgraphᚋmodelᚐWorldWorldᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.WorldWorld) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorldWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorldWorld(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWorldWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorldWorld(ctx context.Context, sel ast.SelectionSet, v *model.WorldWorld) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WorldWorld(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWorldWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐWorldWorldRelation(ctx context.Context, v interface{}) (model.WorldWorldRelation, error) {
	var res model.WorldWorldRelation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWorldWorldRelation2ordoᚑmapᚋgraphᚋmodelᚐWorldWorldRelation(ctx context.Context, sel ast.SelectionSet, v model.WorldWorldRelation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOAlignment2ᚖordoᚑmapᚋgraphᚋmodelᚐAlignment(ctx context.Context, v interface{}) (*model.Alignment, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.Alignment)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAlignment2ᚖordoᚑmapᚋgraphᚋmodelᚐAlignment(ctx context.Context, sel ast.SelectionSet, v *model.Alignment) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCharacter2ᚖordoᚑmapᚋgraphᚋmodelᚐCharacter(ctx context.Context, sel ast.SelectionSet, v *model.Character) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Character(ctx, sel, v)
}

func (ec *executionContext) marshalOCreature2ᚖordoᚑmapᚋgraphᚋmodelᚐCreature(ctx context.Context, sel ast.SelectionSet, v *model.Creature) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Creature(ctx, sel, v)
}

func (ec *executionContext) marshalOEvent2ᚖordoᚑmapᚋgraphᚋmodelᚐEvent(ctx context.Context, sel ast.SelectionSet, v *model.Event) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Event(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEventNature2ᚖordoᚑmapᚋgraphᚋmodelᚐEventNature(ctx context.Context, v interface{}) (*model.EventNature, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.EventNature)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventNature2ᚖordoᚑmapᚋgraphᚋmodelᚐEventNature(ctx context.Context, sel ast.SelectionSet, v *model.EventNature) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEventSignificance2ᚖordoᚑmapᚋgraphᚋmodelᚐEventSignificance(ctx context.Context, v interface{}) (*model.EventSignificance, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.EventSignificance)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventSignificance2ᚖordoᚑmapᚋgraphᚋmodelᚐEventSignificance(ctx context.Context, sel ast.SelectionSet, v *model.EventSignificance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOEventType2ᚖordoᚑmapᚋgraphᚋmodelᚐEventType(ctx context.Context, v interface{}) (*model.EventType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.EventType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEventType2ᚖordoᚑmapᚋgraphᚋmodelᚐEventType(ctx context.Context, sel ast.SelectionSet, v *model.EventType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFaction2ᚖordoᚑmapᚋgraphᚋmodelᚐFaction(ctx context.Context, sel ast.SelectionSet, v *model.Faction) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Faction(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFactionInfluence2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionInfluence(ctx context.Context, v interface{}) (*model.FactionInfluence, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FactionInfluence)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFactionInfluence2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionInfluence(ctx context.Context, sel ast.SelectionSet, v *model.FactionInfluence) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFactionStatus2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionStatus(ctx context.Context, v interface{}) (*model.FactionStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FactionStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFactionStatus2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionStatus(ctx context.Context, sel ast.SelectionSet, v *model.FactionStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFactionType2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionType(ctx context.Context, v interface{}) (*model.FactionType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FactionType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFactionType2ᚖordoᚑmapᚋgraphᚋmodelᚐFactionType(ctx context.Context, sel ast.SelectionSet, v *model.FactionType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFamilyRelation2ᚖordoᚑmapᚋgraphᚋmodelᚐFamilyRelation(ctx context.Context, v interface{}) (*model.FamilyRelation, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FamilyRelation)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFamilyRelation2ᚖordoᚑmapᚋgraphᚋmodelᚐFamilyRelation(ctx context.Context, sel ast.SelectionSet, v *model.FamilyRelation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOID2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOItem2ᚖordoᚑmapᚋgraphᚋmodelᚐItem(ctx context.Context, sel ast.SelectionSet, v *model.Item) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Item(ctx, sel, v)
}

func (ec *executionContext) unmarshalOItemCondition2ᚖordoᚑmapᚋgraphᚋmodelᚐItemCondition(ctx context.Context, v interface{}) (*model.ItemCondition, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ItemCondition)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemCondition2ᚖordoᚑmapᚋgraphᚋmodelᚐItemCondition(ctx context.Context, sel ast.SelectionSet, v *model.ItemCondition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOItemRarity2ᚖordoᚑmapᚋgraphᚋmodelᚐItemRarity(ctx context.Context, v interface{}) (*model.ItemRarity, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ItemRarity)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemRarity2ᚖordoᚑmapᚋgraphᚋmodelᚐItemRarity(ctx context.Context, sel ast.SelectionSet, v *model.ItemRarity) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOItemSlot2ᚖordoᚑmapᚋgraphᚋmodelᚐItemSlot(ctx context.Context, v interface{}) (*model.ItemSlot, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ItemSlot)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemSlot2ᚖordoᚑmapᚋgraphᚋmodelᚐItemSlot(ctx context.Context, sel ast.SelectionSet, v *model.ItemSlot) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOItemType2ᚖordoᚑmapᚋgraphᚋmodelᚐItemType(ctx context.Context, v interface{}) (*model.ItemType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ItemType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemType2ᚖordoᚑmapᚋgraphᚋmodelᚐItemType(ctx context.Context, sel ast.SelectionSet, v *model.ItemType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOLocation2ᚖordoᚑmapᚋgraphᚋmodelᚐLocation(ctx context.Context, sel ast.SelectionSet, v *model.Location) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Location(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLocationAccessibility2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationAccessibility(ctx context.Context, v interface{}) (*model.LocationAccessibility, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.LocationAccessibility)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLocationAccessibility2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationAccessibility(ctx context.Context, sel ast.SelectionSet, v *model.LocationAccessibility) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLocationType2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationType(ctx context.Context, v interface{}) (*model.LocationType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.LocationType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLocationType2ᚖordoᚑmapᚋgraphᚋmodelᚐLocationType(ctx context.Context, sel ast.SelectionSet, v *model.LocationType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOUniverse2ᚖordoᚑmapᚋgraphᚋmodelᚐUniverse(ctx context.Context, sel ast.SelectionSet, v *model.Universe) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Universe(ctx, sel, v)
}

func (ec *executionContext) marshalOWorld2ᚖordoᚑmapᚋgraphᚋmodelᚐWorld(ctx context.Context, sel ast.SelectionSet, v *model.World) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._World(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWorldType2ᚖordoᚑmapᚋgraphᚋmodelᚐWorldType(ctx context.Context, v interface{}) (*model.WorldType, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.WorldType)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWorldType2ᚖordoᚑmapᚋgraphᚋmodelᚐWorldType(ctx context.Context, sel ast.SelectionSet, v *model.WorldType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
